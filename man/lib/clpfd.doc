\libdoc{clpfd}{CLP(FD): Constraint Logic Programming over Finite Domains}

\label{sec:clpfd}

\begin{tags}
    \tag{author}
\url[Markus Triska]{https://www.metalevel.at}
\end{tags}

\subsection{Introduction}

\label{sec:clpfd-intro}

This library provides CLP(FD): Constraint Logic Programming over
Finite Domains.

CLP(FD) is an instance of the general CLP(.) scheme, extending logic
programming with reasoning over specialised domains. CLP(FD) lets us
reason about \textbf{integers} in a way that fits the relational
nature of~Prolog.

There are two major use cases of CLP(FD) constraints:

\begin{enumerate}
    \item \textbf{declarative integer arithmetic} (\secref{clpfd-integer-arith})
    \item solving \textbf{combinatorial problems} such as planning, scheduling
and allocation tasks.
\end{enumerate}

\noindent
The predicates of this library can be classified as:

\begin{itemize}
    \item \textit{arithmetic} constraints like \predref{\Sceq}{2}, \predref{\Scgt}{2} and \predref{\Scne}{2} (\secref{clpfd-arithmetic})
    \item the \textit{membership} constraints \predref{in}{2} and \predref{ins}{2} (\secref{clpfd-membership})
    \item the \textit{enumeration} predicates \predref{indomain}{1}, \predref{label}{1} and \predref{labeling}{2} (\secref{clpfd-enumeration})
    \item \textit{combinatorial} constraints like \predref{all_distinct}{1} and \predref{global_cardinality}{2} (\secref{clpfd-global})
    \item \textit{reification} predicates such as
      \predref{\Scequal}{2} (\secref{clpfd-reification-predicates})
    \item \textit{reflection} predicates such as \predref{fd_dom}{2}
      (\secref{clpfd-reflection-predicates})
\end{itemize}

In most cases, \textit{arithmetic constraints}
(\secref{clpfd-arith-constraints}) are the only predicates you will
ever need from this library. When reasoning over integers, simply
replace low-level arithmetic predicates like \verb$(is)/2$ and
\verb$(>)/2$ by the corresponding CLP(FD) constraints like
\predref{\Sceq}{2} and \predref{\Scgt}{2} to honor and preserve
declarative properties of your programs. For satisfactory performance,
arithmetic constraints are implicitly rewritten at compilation time so
that low-level fallback predicates are automatically used whenever
possible.

Almost all Prolog programs also reason about integers. Therefore, it
is highly advisable that you make CLP(FD) constraints available in all
your programs. One way to do this is to put the following directive in
your \verb$~/.swiplrc$ initialisation file:

\begin{code}
:- use_module(library(clpfd)).
\end{code}

All example programs that appear in the CLP(FD) documentation assume
that you have done this.

Important concepts and principles of this library are illustrated by
means of usage examples that are available in a public git repository:
\url[\textbf{github.com/triska/clpfd}]{https://github.com/triska/clpfd}

If you are used to the complicated operational considerations that
low-level arithmetic primitives necessitate, then moving to CLP(FD)
constraints may, due to their power and convenience, at first feel to
you excessive and almost like cheating. It \textit{isn't}. Constraints are an
integral part of all popular Prolog systems, and they are designed
to help you eliminate and avoid the use of low-level and less general
primitives by providing declarative alternatives that are meant to be
used instead.

When teaching Prolog, CLP(FD) constraints should be introduced
\textit{before} explaining low-level arithmetic predicates and their
procedural idiosyncrasies. This is because constraints are easy to
explain, understand and use due to their purely relational nature. In
contrast, the modedness and directionality of low-level arithmetic
primitives are impure limitations that are better deferred to more
advanced lectures.

We recommend the following reference (PDF:
\url[metalevel.at/swiclpfd.pdf]{https://www.metalevel.at/swiclpfd.pdf}) for
citing this library in scientific publications:

\begin{code}
@inproceedings{Triska12,
  author    = {Markus Triska},
  title     = {The Finite Domain Constraint Solver of {SWI-Prolog}},
  booktitle = {FLOPS},
  series    = {LNCS},
  volume    = {7294},
  year      = {2012},
  pages     = {307-316}
}
\end{code}

More information about CLP(FD) constraints and their implementation is
contained in: \url[\textbf{metalevel.at/drt.pdf}]{https://www.metalevel.at/drt.pdf}

The best way to discuss applying, improving and extending CLP(FD)
constraints is to use the dedicated \const{clpfd} tag on
\url[stackoverflow.com]{http://stackoverflow.com}. Several of the world's
foremost CLP(FD) experts regularly participate in these discussions
and will help you for free on this platform.

\subsection{Arithmetic constraints}

\label{sec:clpfd-arith-constraints}

In modern Prolog systems, \textbf{arithmetic constraints} subsume and
supersede low-level predicates over integers. The main advantage of
arithmetic constraints is that they are true \textit{relations} and can be
used in all directions. For most programs, arithmetic constraints are
the only predicates you will ever need from this library.

The most important arithmetic constraint is \predref{\Sceq}{2}, which
subsumes both \verb$(is)/2$ and \verb$(=:=)/2$ over integers.

In total, the arithmetic constraints are:

\begin{quote}
\begin{tabular}{|l|l|}
\hline
Expr1 \verb$#=$ Expr2 & Expr1 equals Expr2 \\
Expr1 \verb$#\=$ Expr2 & Expr1 is not equal to Expr2 \\
Expr1 \verb$#>=$ Expr2 & Expr1 is greater than or equal to Expr2 \\
Expr1 \verb$#=<$ Expr2 & Expr1 is less than or equal to Expr2 \\
Expr1 \verb$#>$ Expr2 & Expr1 is greater than Expr2 \\
Expr1 \verb$#<$ Expr2 & Expr1 is less than Expr2 \\
\hline
\end{tabular}
\end{quote}

\arg{Expr1} and \arg{Expr2} denote \textbf{arithmetic expressions}, which are:

\begin{quote}
\begin{tabular}{|l|l|}
\hline
\textit{integer} & Given value \\
\textit{variable} & Unknown integer \\
?(\textit{variable}) & Unknown integer \\
-Expr & Unary minus \\
Expr + Expr & Addition \\
Expr * Expr & Multiplication \\
Expr - Expr & Subtraction \\
Expr \Shat{} Expr & Exponentiation \\
\verb$min(Expr,Expr)$ & Minimum of two expressions \\
\verb$max(Expr,Expr)$ & Maximum of two expressions \\
Expr \const{mod} Expr & Modulo induced by floored division \\
Expr \const{rem} Expr & Modulo induced by truncated division \\
\verb$abs(Expr)$ & Absolute value \\
Expr \Sidiv{} Expr & Truncated integer division \\
\hline
\end{tabular}
\end{quote}

where \arg{Expr} again denotes an arithmetic expression.

The bitwise operations \verb$(\)/1$, \verb$(/\)/2$, \verb$(\/)/2$, \verb$(>>)/2$,
\verb$(<<)/2$, \verb$lsb/1$, \verb$msb/1$, \verb$popcount/1$ and \verb$(xor)/2$ are also
supported.

\subsection{Declarative integer arithmetic}

\label{sec:clpfd-integer-arith}

The \textit{arithmetic constraints} \predref{\Sceq}{2},
\predref{\Scgt}{2} etc. (\secref{clpfd-arith-constraints}) are meant
to be used \textit{instead} of the primitives \verb$(is)/2$,
\verb$(=:=)/2$, \verb$(>)/2$ etc. over integers. Almost all Prolog
programs also reason about integers. Therefore, it is recommended that
you put the following directive in your \verb$~/.swiplrc$
initialisation file to make CLP(FD) constraints available in all your
programs:

\begin{code}
:- use_module(library(clpfd)).
\end{code}

Throughout the following, it is assumed that you have done this.

The most basic use of CLP(FD) constraints is \textit{evaluation} of
arithmetic expressions involving integers. For example:

\begin{code}
?- X #= 1+2.
X = 3.
\end{code}

This could in principle also be achieved with the lower-level
predicate \verb$(is)/2$. However, an important advantage of arithmetic
constraints is their purely relational nature: Constraints can be used
in \textit{all directions}, also if one or more of their arguments are only
partially instantiated. For example:

\begin{code}
?- 3 #= Y+2.
Y = 1.
\end{code}

This relational nature makes CLP(FD) constraints easy to explain and
use, and well suited for beginners and experienced Prolog programmers
alike. In contrast, when using low-level integer arithmetic, we get:

\begin{code}
?- 3 is Y+2.
ERROR: is/2: Arguments are not sufficiently instantiated

?- 3 =:= Y+2.
ERROR: =:=/2: Arguments are not sufficiently instantiated
\end{code}

Due to the necessary operational considerations, the use of these
low-level arithmetic predicates is considerably harder to understand
and should therefore be deferred to more advanced lectures.

For supported expressions, CLP(FD) constraints are drop-in
replacements of these low-level arithmetic predicates, often yielding
more general programs. See \secref{clpfd-factorial} for an example.

This library uses \predref{goal_expansion}{2} to automatically rewrite
constraints at compilation time so that low-level arithmetic
predicates are \textit{automatically} used whenever possible. For example,
the predicate:

\begin{code}
positive_integer(N) :- N #>= 1.
\end{code}

is executed as if it were written as:

\begin{code}
positive_integer(N) :-
        (   integer(N)
        ->  N >= 1
        ;   N #>= 1
        ).
\end{code}

This illustrates why the performance of CLP(FD) constraints is almost
always completely satisfactory when they are used in modes that can be
handled by low-level arithmetic. To disable the automatic rewriting,
set the Prolog flag \verb$clpfd_goal_expansion$ to \const{false}.

If you are used to the complicated operational considerations that
low-level arithmetic primitives necessitate, then moving to CLP(FD)
constraints may, due to their power and convenience, at first feel to
you excessive and almost like cheating. It \textit{isn't}. Constraints are an
integral part of all popular Prolog systems, and they are designed
to help you eliminate and avoid the use of low-level and less general
primitives by providing declarative alternatives that are meant to be
used instead.

% remainder, generated from Markdown and PlDoc
\input{clpfdlib.tex}

