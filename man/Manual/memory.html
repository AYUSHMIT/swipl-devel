<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog 5.6.17 Reference Manual: Section 4.41</TITLE><LINK REL=home HREF="index.html">
<LINK REL=contents HREF="Contents.html">
<LINK REL=index HREF="DocIndex.html">
<LINK REL=previous HREF="profile.html">
<LINK REL=next HREF="DDE.html">
<style type="text/css"> 
dd.defbody 
{ margin-bottom: 1em; 
}

dt.pubdef 
{ background-color: #c5e1ff; 
}

pre.code 
{ margin-left: 1.5em; 
margin-right: 1.5em; 
border: 1px dotted; 
padding-top: 5px; 
padding-left: 5px; 
padding-bottom: 5px; 
background-color: #f8f8f8; 
}

div.navigate
{ text-align: center; 
background-color: #f0f0f0; 
border: 1px dotted; 
padding: 5px;
}
</style>
</HEAD>
<BODY BGCOLOR="white"><DIV class="navigate"><A HREF="index.html"><IMG SRC="home.gif" BORDER=0 ALT="Home"></A>
<A HREF="Contents.html"><IMG SRC="index.gif" BORDER=0 ALT="Contents"></A>
<A HREF="DocIndex.html"><IMG SRC="yellow_pages.gif" BORDER=0 ALT="Index"></A>
<A HREF="profile.html"><IMG SRC="prev.gif" BORDER=0 ALT="Previous"></A>
<A HREF="DDE.html"><IMG SRC="next.gif" BORDER=0 ALT="Next"></A>
</DIV>

<H2><A NAME="sec:4.41">4.41 Memory Management</A></H2>

<A NAME="sec:memory"></A>

<P>Note: <A NAME="idx:limitstack2:1040"></A><A HREF="memory.html#limit_stack/2">limit_stack/2</A> 
and <A NAME="idx:trimstacks0:1041"></A><A HREF="memory.html#trim_stacks/0">trim_stacks/0</A> 
have no effect on machines that do not offer dynamic stack expansion. On 
these machines these predicates simply succeed to improve portability.

<DL>
<DT class="pubdef"><A NAME="garbage_collect/0"><STRONG>garbage_collect</STRONG></A></DT>
<DD class="defbody">
Invoke the global- and trail stack garbage collector. Normally the 
garbage collector is invoked automatically if necessary. Explicit 
invocation might be useful to reduce the need for garbage collections in 
time critical segments of the code. After the garbage collection
<A NAME="idx:trimstacks0:1042"></A><A HREF="memory.html#trim_stacks/0">trim_stacks/0</A> 
is invoked to release the collected memory resources.</DD>
<DT class="pubdef"><A NAME="garbage_collect_atoms/0"><STRONG>garbage_collect_atoms</STRONG></A></DT>
<DD class="defbody">
Reclaim unused atoms. Normally invoked after <CODE>agc_margin</CODE> (a 
prolog flag) atoms have been created. On multi-threaded versions the 
actual collection is delayed until there there are no threads performing 
normal garbage collection. In this case <A NAME="idx:garbagecollectatoms0:1043"></A><A HREF="memory.html#garbage_collect_atoms/0">garbage_collect_atoms/0</A> 
returns immediately. Note this implies there is no guarantee it will <EM>ever</EM> 
happen as there may always be threads performing garbage collection.</DD>
<DT class="pubdef"><A NAME="limit_stack/2"><STRONG>limit_stack</STRONG>(<VAR>+Key, 
+Kbytes</VAR>)</A></DT>
<DD class="defbody">
Limit one of the stack areas to the specified value. <VAR>Key</VAR> is 
one of
<CODE>local</CODE>, <CODE>global</CODE> or <CODE>trail</CODE>. The limit 
is an integer, expressing the desired stack limit in K bytes. If the 
desired limit is smaller than the currently used value, the limit is set 
to the nearest legal value above the currently used value. If the 
desired value is larger than the maximum, the maximum is taken. Finally, 
if the desired value is either 0 or the atom <CODE>unlimited</CODE> the 
limit is set to its maximum. The maximum and initial limit is determined 
by the command line options <STRONG>-L</STRONG>, <STRONG>-G</STRONG> and <STRONG>-T</STRONG>.</DD>
<DT class="pubdef"><A NAME="trim_stacks/0"><STRONG>trim_stacks</STRONG></A></DT>
<DD class="defbody">
Release stack memory resources that are not in use at this moment, 
returning them to the operating system. Trim stack is a relatively cheap 
call. It can be used to release memory resources in a backtracking loop, 
where the iterations require typically seconds of execution time and 
very different, potentially large, amounts of stack space. Such a loop 
should be written as follows:

<PRE class="code">
loop :-
        generator,
            trim_stacks,
            potentially_expensive_operation,
        stop_condition, !.
</PRE>

<P>The prolog top level loop is written this way, reclaiming memory 
resources after every user query.</DD>
<DT class="pubdef"><A NAME="stack_parameter/4"><STRONG>stack_parameter</STRONG>(<VAR>+Stack, 
+Key, -Old, +New</VAR>)</A></DT>
<DD class="defbody">
Query/set a parameter for the runtime stacks. <VAR>Stack</VAR> is one of <CODE>local</CODE>, <CODE>global</CODE>, <CODE>trail</CODE> 
or <CODE>argument</CODE>. The table below describes the <VAR>Key</VAR>/<VAR>Value</VAR> 
pairs. Old is first unified with the current value.

<P>
<CENTER>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD><CODE>limit</CODE> </TD><TD>Maximum size of the stack 
in bytes </TD></TR>
<TR VALIGN=top><TD><CODE>min_free</CODE> </TD><TD>Minimum free space at 
entry of foreign predicate </TD></TR>
</TABLE>

</CENTER>

<P>This predicate is currently only available on versions that use the 
stack-shifter to enlarge the runtime stacks when necessary. It's 
definition is subject to change.
</DD>
</DL>

<P></BODY></HTML>