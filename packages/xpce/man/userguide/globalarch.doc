\chapter{Global architecture}

Section~\ref{sec:starting} introduced the basic principles of PCE/Prolog
with examples.  In this section we present a conceptual overview of PCE
and the PCE/Prolog environment.


\section{What is ``Object-Oriented''?}

PCE is an object-oriented system.  This implies that the basic
entity in PCE's world is an object, which is an observable entity
with persistent state capable of performing actions.  Such an action
is activated by sending the object a {\em message}.

So far, most object oriented systems agree.  Starting from these
notions however one can find object oriented environments that take
widely different approaches for representing objects, actions on
objects and sending messages.

Rather than specifying operations on each individual object most OO
environments define some way of sharing the operation definitions
(called {\em methods}).  There are two ways to share methods.  One is
to create objects as a copy of other objects and then modify them (by
attaching and deleting attributes and methods) to fit the particular
need.  If a series of similar objects is needed, one first creates an
object that satisfies the common functionality and then creates
multiple copies of this object.  This approach is followed by
SELF \cite{chambers:89}.  The other ---more traditional--- approach is to
define a {\em class}.  A class is an entity in the object oriented
environment that defines the constituents of the persistent state
and the methods for each of its {\em instantiations}.  PCE takes the
latter approach, but adds some notions of the object-copying
approach. 


\section{PCE's objects}

Getting down to earth, a PCE object is a set of {\em values} of {\em
instance variables} bundled into a single entity which is referred
to by its {\em object reference}. An object is an instantiation of
a {\em class}.  A class holds the key to decoding the information of
its instances:% 
    \footnote{We will mix the terms {\em instance} and {\em object}
              freely in this document.  They are considered synonyms.}
the instance variables.  The class also serves as a placeholder
for storing the methods understood by its instances.  Figure~\ref
{fig:arch1} illustrates this.

\postscriptfig[width=\textwidth]{arch1}{Classes and Objects in PCE}


\subsection{Classes}

As explained above, a PCE class describes the storage-layout and the
methods of its instances.  In PCE a class is a normal object.  It is
an instance of class {\em class}.%
    \footnote{Class class is an instance of itself.  In other systems
	      (SmallTalk, \cite{Goldberg:83a}), classes are instances of a
	      {\em meta-class}.  Yet in other system, classes have
	      a completely different status (for example widgets in
	      the X11 Intrinsics)}
\index{inheritance,of classes}
As in most OO systems PCE classes may inherit from a {\em
super-class}.  PCE classes are organised in a single-inheritance
hierarchy.%
    \footnote{Multiple inheritance introduces various technical and
	      conceptual problems.  PCE uses delegation and
	      templates to achieve similar results.  This is
	      explained in section~\ref{sec:delegation} and
	      section~\ref{sec:template}.}
The root of this hierarchy is class {\em object}.  Class object is the
only class without a super-class.  Figure~\ref{fig:classhierarchy} gives
the complete hierarchy of PCE classes.

\postscriptfig[height=8in]{classhierarchy}{PCE's Class hierarchy}


\section{Objects and non-objects}

Except for integers, everything accessible to the user is represented
as an object.  By implementing classes, instance variables, methods,
messages, conditions, constants, variables, etc.\ as objects
everything in PCE may be accessed through the basic predicates
new/2, send/[2-12] and get/[3-13] from Prolog.


\section{Delegation}		\label{sec:delegation}

\index{delegation}\index{multiple inheritance}\index{inheritance,multiple}
PCE does not offer multiple inheritance.  Sharing functionality from
multiple classes is generally dealt with using {\em delegation}.
Delegation implies that messages not understood by a principal object
are forwarded to an object that is associated to it.

For example, PCE defines class \class{editor} to be a graphical object
capable of editing text.  Most applications require a \class {window}
capable of editing text.  PCE's class \class{view} is not a subclass
of both editor and window, but just of window.  The window displays an
instance of class editor and constraints the size of the editor to
occupy the entire visible area of the window.  Any message arriving on
the view that is not defined on class view (or class window) will be
forwarded to the associated editor object.

The dynamic nature of delegation makes this mechanism more flexible
than multiple inheritance.  For example, PCE defines class \class{node}.
This class defines the communication to a \class{tree} to automate the
layout of hierarchies.  A node can manipulate any graphical object.
Using multiple inheritance would require a class {\em box_node},
{\em cicle_node}, etc.%
    \footnote{A problem with PCE's current implementation of
	      delegation is that the object that is a functional
	      part of another object is not aware of this fact.}


\section{Executable Objects}

\index{statement,as object}\index{executable,object}
\index{program,as object}\index{lambda functions}
PCE defines {\em executable} objects.  Executable objects (often
called \idx{code object}s) may be compared to lambda functions is Lisp.
They are used in the contexts given below.

\begin{itemize}
    \tick{Definition of `\idx{call-back}' actions}
The traditional and most common usage of executable objects is to
specify the action undertaken by interactive UI components when they
are activated.  We have seen examples of this in
section~\ref{sec:dialogexample}.
    \tick{As implementation of a \class{method} object} 
A method describes an action associated with a class or individual
object.  It maps a {\em selector} onto an action.  This action is
either a C-function (used for most internal methods) or an
executable object.  Examples of this may be found in
section~\ref{sec:movepiece}.  See also \cite{PCE:udc}.
    \tick{As parameter to a method}
Various of PCE's method take an executable object as a parameter to
specify the action undertaken.  For example, the method `sort' of
class \class{chain} takes an executable object to compare two
elements:

\begin{code}
1 ?- new(@ch, chain(this, is, not, a, gnu)).
2 ?- send(@ch, sort, ?(@arg1, compare, @arg2)).
3 ?- object(@ch, O).
O = chain(a, gnu, is, not, this) 
\end{code}

The `?(@arg1, compare, @arg2)' construct describes a \class{function}
object, a subclass of executable objects that yield a value.  This is
further explained in section~\ref {sec:function}. 
\end{itemize}

Two major groups of code objects are distinguished: {\em procedures}
and {\em functions}.  The first only returns status information
similar to the send-operation.  The latter returns a value or failure
status information similar to the get-operation.

\subsection{Procedures}

The most important `procedure' code objects are:

\begin{shortlist}
    \tick{message(Receiver, Selector, Argument ...)}
A \class{message} object starts a send-operation when executed.  The
arguments of a message are either objects or {\em functions}.  In the
latter case these are evaluated before the message itself is evaluated.
If the evaluation of one of the argument functions fails, the message
is not executed.  The {\em Receiver} of a the message can be @prolog to
invoke a predicate in the Prolog environment.
    \tick{and(Statement, ...)}
An \class{and} is a sequence of code objects.  It fails if one of the
members fails and succeeds otherwise.  If a statement is a function,
it will be evaluated.  Functions fail only if they return the fail
control-value.  Notably, a function that returned the boolean @off (false)
is considered to have succeeded.
    \tick{if(Condition, Then, Else)}
An \class{if} implements a branch.  It first evaluates {\em Condition}
and then either of {\em Then} or {\em Else}.  The success of the entire
if is determined by the success of the executed {\em Then} or {\em
Else}.  Either or both of these statements may be omited.  The construct
\mbox{\tt if({\em Statement})} may be used to force success of a code
object.
    \tick{Conditions: (A verb$==$ B, A \verb$\==$ B, A \verb$<$ B, ...)}
These executable objects are commonly used as conditions for the
\class{if} object.
\end{shortlist}

The online manual may be used to get an overview of the other available
code objects.  See section~\ref{sec:classhierarchy}.


\subsection{Functions}		\label{sec:function}

Functions are code objects which ---when executed--- evaluate to a PCE
datum (int or object).  They may be used as arguments to other code
objects or as arguments to any method.  A function is automatically
evaluated iff:

\begin{shortlist}
    \tick{It appears as part of a code object that is executed}
    \tick{Type checking demands execution} 
\end{shortlist}

\noindent
The most important function objects are:

\begin{itemize}
    \tick{?(Receiver, Selector, Argument, ...}
Class \class{?} starts a get-operation when executed (= evaluated).  It
may be compared to \class{message}.  The classname is pronounced as
{\em \idx{obtainer}}.  All the arguments may be functions.  These
will be evaluated before the get-operation is performed.  As with
\class{message}, a failing evaluation of one of the arguments forces
failure of the whole.
    \tick{var}
Class \class{var} describes a variable.  The objects @arg1, @arg2, ...,
@arg10, @receiver and @event are the most commonly used var objects.

The objects @arg1, ...  are the message {\em forwarding} arguments.
Assume the following message.

\begin{code}
?- new(@m, message(@pce, format, 'Hello %s\n', @arg1)).
\end{code}

When executed, @arg1 (a \class{function}) will first be evaluated.  The
method `code ->forward: a1, ...' binds these \class{var} objects
locally:

\begin{code}
?- send(@m, execute),
   send(@m, forward, world),
   send(@m, execute).
@default
world
@default
\end{code}

The objects @receiver and @event are functions refering to the receiver
of the currently executing method and the current user-event.  Var
objects are rarely created explicitely by application programmers.
    \tick{arithmetic functions (+, -, *, /)}
\index{arithmetic}%
These functions define {\em integer} arithmetic and are commonly used
to deal with graphical computations in code objects.
\end{itemize}


\subsection{Example}

Code objects are most commonly used to specify the internal behaviour of
dialog windows, such that the call-back predicate can concentrate on the
real function.  We have seen an example of this in \secref{fileviewer}.

\index{PostScript}%
Below there is another example.  {\em Data} is assumed to be an XPCE
\class{string} object containing a PostScript\tm\ description of a
graphical object as can be obtained using

\begin{code}
	...,
	get(Graphical, postscript, PostScriptString),
	...,
\end{code}

In this example both the internal dynamic of the dialog window (the
label of the text-entry fields changes if the user switches from
file to printer) and grabbing the arguments from the various
dialog items is written using XPCE executable objects.  Prolog
will only be called to do the real work: printing the data to
the requested destination.

Note that XPCE/Prolog does not {\bf require} you to use XPCE executable
objects this way.  It is also possible to call Prolog from both the menu
and the buttons, passing the dialog window as argument and write all
behaviour in Prolog.  We leave this as an exercise to the user.


\begin{pcecode}
postscript(Data) :-
	  new(D, dialog('Print destination')),
	  send(D, append, new(T, menu(destination, marked))),
	  send_list(T, append, [printer, file]),
	  send(T, layout, horizontal),
	  send(D, append, new(A, text_item(printer_name, 'PostScript'))),
	  send(T, message,
	       if(T?selection == printer,
		  message(A, label, ?(A, label_name, printer_name)),
		  message(A, label, ?(A, label_name, file_name)))),
	  send(D, append,
	       button(ok, and(message(@prolog, print_postscript,
				      T?selection, A?selection, Data),
			      message(D, destroy)))),
	  send(D, append,
	       button(cancel, message(D, destroy))),
	  send(D, default_button, ok),
	  send(D, open).
	  
print_postscript(printer, Address, Data) :- !,
	  new(F, file),
	  send(F, open, write),
	  send(F, append, Data),
	  send(F, close),
	  get(F, name, TmpFile),
	  get(string('lpr -P%s %s &', Address, TmpFile),
	      value, Command),
	  unix(shell(Command)).
print_postscript(file, Address, Data) :-
	  new(F, file(Address)),
	  send(F, open, write),
	  send(F, append, Data),
	  send(F, close).
\end{pcecode}


\section{Prolog}

PCE was {\em not} designed to propose a new programming language, but
to be a system that can easily be added to another
environment to create a hybrid architecture.  In this environment,
PCE takes care of the user interface (UI) and possibly other tasks for
which it is better suited than the environment it is attached to (e.g.\
representing long text fragments is difficult in Prolog).

The small size of the interface (only four predicates) makes it easy
to connect PCE to another environment.  This simple interface
nevertheless provides a powerful and fast communication channel.

As we have seen in section~\ref{sec:starting}, activating PCE is done by
providing the user with access to PCE's message passing
primitives.  Near the end of section~\ref{sec:starting} we briefly
explained how control is passed from PCE to Prolog. The predefined
object @prolog is (the only) instance of class {\em host}.  Any
message sent to this instance will be mapped on a Prolog goal and
given to the Prolog system as a query: the {\em selector} of the
method will be used as a predicate name.  The arguments will be
translated from PCE data-types to their corresponding Prolog
data-types according to the transformation rules described in
section~\ref{sec:interface}. 

Figure~\ref{fig:control} shows the data- and control-flow between
PCE and Prolog.  The lines with arrows indicate data-flow in the
direction of the arrow.  The dotted ellipse with arrows indicates
the flow of control.

\postscriptfig[width=\textwidth]{control}{Data and Control flow in PCE/Prolog}


\section{Summary}

This section explained the basic object-oriented notions used in
PCE.  PCE's data is organised in {\em objects} and integers.  An
object represents a state.  An object is an instance of a class.
A class describes the constituents of the state represented in
its instances and the methods (actions) understood by its instances.

A class is a normal object, as are all the other constituents of
PCE's programming world: methods, instance variables, messages,
expressions, etc.  This uniformity allows for inspecting and changing
PCE using the four basic interface predicates from Prolog.

The basic interface predicates pass control from Prolog to PCE.
When control is to be passed from PCE to Prolog (for example if
the user presses a button), a message is send to @prolog, the
only instance of class host.  This object will create a goal
from the message and pass this goal to the Prolog environment to
be proven.
