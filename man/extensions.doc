\chapter{SWI-Prolog extensions}
\label{sec:extensions}

This chapter describes extensions to the Prolog language introduced with
SWI-Prolog version~7.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reserved constants}
\label{sec:ext-constants}

SWI-Prolog introduces constants that are distinct from the usual Prolog
atoms and numbers. These are introduced because text is commonly
represented using atoms. For example, a natural language parser
typically represents the input text as a list of words and punctuation
characters, where each of these is represented as an atom. At the same
time, Prolog is a dynamically typed language. This feature allows for
heterogeneous data representations that can be tested and acted on at
runtime. In particular, various predicates accept both a single item or
a list of items, e.g., load_files/2. As a result, the call
\exam{load_files([], [])} is \emph{ambiguous}, as it may mean `load no
files' or `load the file named \verb$"[]"$. Similar problems arise with
predicates that overload input text as either an atom or a list of
character codes, where \exam{[]} can both refer to the text \verb$"[]"$
(processed as an atom) or the empty string (processed as a list of
character codes).

The \textbf{syntax} for such constants is a string between \emph{back
quotes}. Backquoted constants are considered \emph{atomic} (see
atomic/1) but not atoms (see atom/1).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Lists are special}
\label{sec:ext-lists}

SWI-Prolog lists can be distinquished unambiguously at runtime from
both ordinary compound terms and the atom \const{'[]'} using the
reserved constants introduced in \secref{ext-constants}.  The
list \exam{[a,b]} is represented as the term below.

\begin{code}
`.`(a, `.`(b, `[]`))
\end{code}

This modification has minimal impact on typical Prolog code. It does
affect foreign code (see \secref{foreign}) that uses the normal atom and
compound term interface for manipulation lists. In most cases this can
be avoided by using the dedicated list functions. For convenience, the
macros \const{ATOM_nil} and \const{ATOM_dot} are provided by
\file{SWI-Prolog.h}.

Another place that is affected is write_canonical/1. Impact is minimized
by using the list syntax for lists.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax changes}
\label{sec:ext-syntax}

\subsection{Operators and quoted atoms}
\label{sec:ext-syntax-op}

As of SWI-Prolog version~7, quoted atoms loose their operator property.

\subsection{Compound terms with zero arguments}
\label{sec:ext-compound-zero}

As of SWI-Prolog version~7, the system supports compound terms that have
no arguments. This implies that e.g., \exam{name()} is valid syntax.
This extension aims at functions on maps (see \secref{maps}) as well as
the implementation of domain specific languages (DSLs). To minimise the
consequences, the classical predicates functor/3 and =../2 have not been
modified. The predicates compound_name_arity/3 and
compound_name_arguments/3 have been added. These predicates operate only
on compound terms and behave consistently for compounds with zero
arguments.  Code that \jargon{generalises} a term using the sequence
below should generally be changed to use compound_name_arity/3.

\begin{code}
    ...,
    functor(Specific, Name, Arity),
    functor(General, Name, Arity),
    ...,
\end{code}

Replacement of =../2 by compound_name_arguments/3 is typically needed
to deal with code that follow the skeleton below.

\begin{code}
    ...,
    Term0 =.. [Name|Args0],
    maplist(convert, Args0, Args),
    Term =.. [Name|Args],
    ...,
\end{code}

For predicates, goals and arithmetic functions (evaluable terms), <name>
and <name>() are \emph{equivalent}. Below are some examples that
illustrate this behaviour.

\begin{code}
go() :- format('Hello world~n').

?- go().
Hello world

?- go.
Hello world

?- Pi is pi().
Pi = 3.141592653589793.

?- Pi is pi.
Pi = 3.141592653589793.
\end{code}

\subsection{Double quoted strings}
\label{sec:ext-dquotes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Maps: structures with named arguments}
\label{sec:ext-maps}

SWI-Prolog version~7 introduces maps as an abstract object with a
concrete modern syntax and functional notation for accessing members.
The syntax for a map is illustrated below. \arg{Class} is either a
variable or an atom. As with compound terms, there is \textbf{no} space
between the class and the opening brace. The keys are either atoms or
small integers (up to \prologflag{max_tagged_integer}). The values are
arbitrary Prolog terms which are parsed using the same rules as used for
arguments in compound terms.

\begin{quote}
Class{Key1:Value1, Key2:Value2, ...}
\end{quote}

A map cannot hold duplicate keys. The map is transformed into an opaque
internal representation that does \emph{not} respect the order in which
the key value pairs appear in the input text. If a map is written, the
keys are written according to the standard order of terms (see
\secref{standardorder}). Here are some examples, where the second
example illustrates that the order is not maintained and the third
illustrates an anonymous map.

\begin{code}
?- A = point{x:1, y:2}.
A = point{x:1, y:2}.

?- A = point{y:2, x:1}.
A = point{x:1, y:2}.

?- A = _{first_name:"Mel", last_name:"Smith"}.
A = _G1476{first_name:"Mel", last_name:"Smith"}.
\end{code}

Maps can be unified following the standard symmetric Prolog unification
rules. As maps use an internal canonical form, the order in which the
named keys are represented is not relevant. This behaviour is
illustrated by the following example.

\begin{code}
?- point{x:1, y:2} = Class{y:2, x:X}.
Class = point,
X = 1.
\end{code}


\subsection{Functions on maps}
\label{ext-map-functions}

The infix operator dot (.) is used to extract values and evaluate
functions on maps. Functions are recognised if they appear in the
argument of a \jargon{goal} in the source text.  The keys act as
field selector, which is illustrated in this example.

\begin{code}
?- X = point{x:1,y:2}.x.
X = 1.

?- X = point{x:1,y:2}.C.
X = 1,
C = x ;
X = 2,
C = y.
\end{code}

The class of a map associates the map to a module.  If the dot
notation uses a compound term, this calls the goal below.

\begin{quote}
<module>:<name>(Arg1, ..., +Map, -Value)
\end{quote}

Functions are normal Prolog predicates. The map infrastructure provides
a more convient syntax for representing the head of such predicates
comfortably. The code below defines a function \term{multiply}{Times} on
a point that creates a new point by multiplying both coordinates. and
\term{len}{}\footnote{as \term{length}{} would result in a predicate
length/2, this name cannot be used. This might change in future
versions} to compute the length from the origin. The . and \verb$=>$
operators are used to abstract the location of the predicate arguments.
It is allowed to define multiple a function with multiple clauses,
providing overloading and non-determinism.

\begin{code}
:- module(point, []).

M.multiply(F) => point{x:X, y:Y} :-
	X is M.x*F,
	Y is M.y*F.

M.len() => Len :-
	Len is sqrt(M.x**2 + M.y**2).
\end{code}

After these definitions, we can evaluate the following functions:

\begin{code}
?- X = point{x:1, y:2}.multiply(2).
X = point{x:2, y:4}.

?- X = point{x:1, y:2}.multiply(2).len().
X = 4.47213595499958.
\end{code}


\subsection{A motivation for maps as primary citizens}
\label{sec:ext-maps-motivation}

Maps, or key-value associations, are a common datastructure. A good old
example are \jargon{property lists} as found in Lisp, while a good
recent example is formed by JavaScript \jargon{objects}. Traditional
Prolog does not offer native properly lists. As a result, people are
using a wide range of data structures for key-value associations:

\begin{itemize}
    \item Using compound terms and positional arguments.
    \item Using compound terms with library \pllib{record}.
    \item Using lists of terms \exam{Name=Value}, \exam{Name-Value},
          \exam{Name:Value} or \exam{Name(Value)}.
    \item Using library \pllib{assoc} which represents the
          associations as a balanced binary tree.
\end{itemize}

This situation is unfortunate. Each of these have their advantages and
disadvantages. E.g., compound terms are compact and fast, but inflexible
and using positional arguments quickly breaks down. Library
\pllib{record} fixes this, but the syntax is considered hard to use.
Lists are flexible, but expensive and the alternative key-value
representation complicate the matter even more. Library \pllib{assoc}
allows for efficient manipulation of changing associations, but the
syntactical representation of an assoc is complex, which makes them
unsuitable for e.g., \jargon{options lists} as seen in predicates such
as write_term/3.
