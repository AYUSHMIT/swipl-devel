\chapter{CHR: Constraint Handling Rules} 		\label{sec:chr}

This chapter is written by Tom Schrijvers, K.U. Leuven, and adjustments by
Jan Wielemaker.

The CHR system of SWI-Prolog is the K.U.Leuven CHR system.  The runtime
environment is written by Christian Holzbaur and Tom Schrijvers while the
compiler is written by Tom Schrijvers. Both are integrated with SWI-Prolog
and licenced under compatible conditions with permission from the authors.

The main reference for SWI-Prolog's CHR system is:
\begin{itemize}
\item T. Schrijvers, and B. Demoen, {\em The K.U.Leuven CHR System: Implementation
and Application}, First Workshop on Constraint Handling Rules: Selected
Contributions (Fr\"uhwirth, T. and Meister, M., eds.), pp. 1--5, 2004.
\end{itemize}


\section{Introduction}
%=====================

Constraint Handling Rules (CHR) is a committed-choice rule-based language
embedded in Prolog. It is designed for writing constraint solvers and is
particularily useful for providing application-specific constraints.
It has been used in many kinds of applications, like scheduling,
model checking, abduction, type checking among many others.

CHR has previously been implemented in other Prolog systems (SICStus,
Eclipse, Yap), Haskell and Java. This CHR system is based on the
compilation scheme and runtime environment of CHR in SICStus.

In this documentation we restrict ourselves to giving a short overview
of CHR in general and mainly focus on elements specific to this
implementation. For a more thorough review of CHR we refer the reader to
\cite{Freuhwirth:98}. More background on CHR can be found at
\cite{chrSite}.

In \secref{SyntaxAndSemantics} we present the syntax of CHR in Prolog and
explain informally its operational semantics. Next, \secref{practical}
deals with practical issues of writing and compiling Prolog programs
containing CHR. \Secref{debugging} explains the currently primitive CHR
debugging facilities. \Secref{predicates} provides a few useful predicates
to inspect the constraint store and \secref{examples} illustrates CHR with
two example programs. In \secref{sicstus-chr} some compatibility issues with
older versions of this system and SICStus' CHR system. Finally, \secref{guidelines} concludes with a few
practical guidelines for using CHR.


\section{Syntax and Semantics} 		\label{sec:SyntaxAndSemantics}
%=============================

\subsection{Syntax}
%-----------------

The syntax of CHR rules is the following:

\begin{code}
rules --> rule, rules.
rules --> [].

rule --> name, actual_rule, pragma, [atom('.')].

name --> atom, [atom('@')].
name --> [].

actual_rule --> simplification_rule.
actual_rule --> propagation_rule.
actual_rule --> simpagation_rule.

simplification_rule --> head, [atom('<=>')], guard, body.
propagation_rule --> head, [atom('==>')], guard, body.
simpagation_rule --> head, [atom('\')], head, [atom('<=>')], 
                     guard, body.

head --> constraints.

constraints --> constraint, constraint_id.
constraints --> constraint, constraint_id, [atom(',')], constraints.

constraint --> compound_term.

constraint_id --> [].
constraint_id --> [atom('#')], variable.

guard --> [].
guard --> goal, [atom('|')].

body --> goal.

pragma --> [].
pragma --> [atom('pragma')], actual_pragmas.

actual_pragmas --> actual_pragma.
actual_pragmas --> actual_pragma, [atom(',')], actual_pragmas.

actual_pragma --> [atom('passive(')], variable, [atom(')')].

\end{code}

Note that the guard of a rule may not contain any goal that binds a variable
in the head of the rule with a nonvariable or with another variable in the
head of the rule. It may however bind variables that do not appear in the
head of the rule, e.g. an auxiliary variable introduced in the guard.

\subsection{Semantics}
%--------------------

In this subsection the operational semantics of CHR in Prolog are presented
informally. They do not differ essentially from other CHR systems.

When a constraint is called, it is considered an active constraint and
the system will try to apply the rules to it. Rules are tried and executed
sequentially in the order they are written. 

A rule is conceptually tried for an active constraint in the following
way. The active constraint is matched with a constraint in the head of
the rule. If more constraints appear in the head they are looked for
among the suspended constraints, which are called passive constraints in
this context. If the necessary passive constraints can be found and all
match with the head of the rule and the guard of the rule succeeds, then
the rule is committed and the body of the rule executed. If not all the
necessary passive constraint can be found, the matching fails or the
guard fails, then the body is not executed and the process of trying and
executing simply continues with the following rules. If for a rule,
there are multiple constraints in the head, the active constraint will
try the rule sequentially multiple times, each time trying to match with
another constraint.

This process ends either when the active constraint disappears, i.e.\ it
is removed by some rule, or after the last rule has been processed. In
the latter case the active constraint becomes suspended.

A suspended constraint is eligible as a passive constraint for an active
constraint. The other way it may interact again with the rules, is when
a variable appearing in the constraint becomes bound to either a nonvariable
or another variable involved in one or more constraints. In that case the
constraint is triggered, i.e.\ it becomes an active constraint and all
the rules are tried.

\paragraph{Rule Types}
%- - - - - - - - - - 

There are three different kinds of rules, each with their specific semantics:

\begin{itemlist}
    \item [simplification]
The simplification rule removes the constraints in its head and calls its body.

    \item [propagation]
The propagation rule calls its body exactly once for the constraints in
its head.

    \item [simpagation]
The simpagation rule removes the constraints in its head after the
$\backslash$ and then calls its body. It is an optimization of
simplification rules of the form: \[constraints_1, constraints_2 <=>
constraints_1, body \] Namely, in the simpagation form: \[ constraints_1
\backslash constraints_2 <=> body \] The $\mathit{constraints}_1$
constraints are not called in the body.
\end{itemlist}

\paragraph{Rule Names}
%- - - - - - - - - - 
Naming a rule is optional and has no semantical meaning. It only functions
as documentation for the programmer.

\paragraph{Pragmas}
%- - - - - - - - -
The semantics of the pragmas are:

\begin{description}
    \termitem{passive}{Identifier}
The constraint in the head of a rule \arg{Identifier} can only match a
passive constraint in that rule.
\end{description}

Additional pragmas may be released in the future.

\paragraph{Options}
%- - - - - - - - -
It is possible to specify options that apply to all the CHR rules in the module.
Options are specified with the \texttt{chr_option/2} declaration:

\begin{code}
                :- chr_option(Option,Value).
\end{code}

and may appear in the file anywhere after the first constraints declaration.

Available options are:
\begin{description}
        \termitem{check_guard_bindings}{}
This option controls whether guards should be checked for (illegal) variable
bindings or not. Possible values for this option are \texttt{on}, to enable
the checks, and \texttt{off}, to disable the checks. If this option is on,
any guard fails when it binds a variable that appears in the head of the rule.
When the option is off, the behavior of a binding in the guard is undefined.

        \termitem{optimize}{}
This option controls the degree of optimization.
Possible values are \texttt{full}, to enable all available
optimizations, and \texttt{off} (default), to disable all optimizations.  
The default is derived from the SWI-Prolog flag \const{optimise}, where
\const{true} is mapped to \const{full}.  Therefore the commandline
option \cmdlineoption{-O} provides full CHR optimization.
If optimization is enabled, debugging must be disabled.

	\termitem{debug}{}
This options enables or disables the possibility to debug the CHR code.
Possible values are \texttt{on} (default) and \texttt{off}. See
\secref{debugging} for more details on debugging.  The default is
derived from the prolog flag \const{generate_debug_info}, which
is \const{true} by default.  See \cmdlineoption{-nodebug}.
If debugging is enabled, optimization must be disabled.

% 	\termitem{mode}{}
% This option specifies the mode for a particular constraint. The
% value is a term with functor and arity equal to that of a constraint.
% The arguments can be one of \texttt{-}, \texttt{+} or \texttt{?}.
% The latter is the default. The meaning is the following:
% 	\begin{description}
% 	\termitem{-}{} The corresponding argument of every occurrence
% 	of the constraint is always unbound.
% 	\termitem{+}{} The corresponding argument of every occurrence
% 	of the constraint is always ground.
% 	\termitem{?}{} The corresponding argument of every occurrence
% 	of the constraint can have any instantiation, which may change
% 	over time. This is the default value.
% 	\end{description}
% The declaration is used by the compiler for various optimizations. 
% Note that it is up to the user the ensure that the mode declaration
% is correct with respect to the use of the constraint.
% This option may occur once for each constraint.
% 
% 	\termitem{type_declaration}{}
% This option specifies the argument types for a particular constraint. The
% value is a term with functor and arity equal to that of a constraint.
% The arguments can be a user-defined type or one of
% the built-in types:
% 	\begin{description}
% 	\termitem{int}{} The corresponding argument of every occurrence
% 	of the constraint is an integer number.
% 	\termitem{float}{} \ldots a floating point number.
% 	\termitem{number}{} \ldots a number.
% 	\termitem{natural}{} \ldots a positive integer.
% 	\termitem{any}{} The corresponding argument of every occurrence
% 	of the constraint can have any type. This is the default value.
% 	\end{description}
% 
% Currently, type declarations are only used to improve certain
% optimizations (guard simplification, occurrence subsumption, \ldots).
% 
% 	\termitem{type_definition}{}
% This option defines a new user-defined type which can be used in
% type declarations. The value is a term of the form
% \texttt{type(} \textsf{name} \texttt{,} \textsf{list} \texttt{)}, where
% \textsf{name} is a term and \textsf{list} is a list of alternatives.
% Variables can be used to define generic types. Recursive definitions
% are allowed. Examples are 
% 
% \begin{code}
% type(bool,[true,false]).
% type(complex_number,[float + float * i]).
% type(binary_tree(T),[ leaf(T) | node(binary_tree(T),binary_tree(T)) ]).
% type(list(T),[ [] | [T | list(T)]).
% \end{code}
% 
 
\end{description}
 
% The above mode, type_declaration and type_definition options are deprecated. 
% The new syntax is described below.

\section{CHR in SWI-Prolog Programs}		\label{sec:practical}
%===========================


\subsection{Embedding in Prolog Programs}

The CHR constraints defined in a \fileext{pl} file are
associated with a module. The default module is \const{user}. One should
never load different \fileext{pl} files with the same CHR module name.

\subsection{Constraint declaration}

Every constraint used in CHR rules has to be declared with a
chr_constraint/1. declaration by the {\em constraint
specifier}. For convenience multiple consttraints may be declared at once with
the same \predref{chr_constraint} declaration followed by a comma-separated
list of constraint specifiers.

A constraint specifier is, in its compact form, \texttt{$F$/$A$} where $F$ and $A$ are respectively
the functor name and arity of the constraint, e.g.: 

\begin{code}
:- chr_constraint foo/1.
:- chr_constraint bar/2, baz/3.
\end{code}

In its extended form, a constraint specifier is \texttt{$c$($A_1$,\ldots,$A_n$)}
where $c$ is the constraint's functor, $n$ its arity and the $A_i$ are argument
specifiers. An argument specifier is a mode, optionally followed by a type. E.g.
\begin{code}
:- chr_constraint get_value(+,?).
:- chr_constraint domain(?int,+list(int)), 
                   alldifferent(?list(int)).
\end{code}

A mode is one of:
	\begin{description}
	\termitem{-}{} The corresponding argument of every occurrence
	of the constraint is always unbound.
	\termitem{+}{} The corresponding argument of every occurrence
	of the constraint is always ground.
	\termitem{?}{} The corresponding argument of every occurrence
	of the constraint can have any instantiation, which may change
	over time. This is the default value.
	\end{description}

A type can be a user-defined type or one of the built-in types. A type
comprises a (possibly inifinite) set of values. The type declaration for
a constraint argument means that for every instance of that constraint the
corresponding argument is only ever bound to values in that set. It does not
state that the argument necessarily has to be bound to a value.

The built-in types are:
	\begin{description}
	\termitem{int}{} The corresponding argument of every occurrence
	of the constraint is an integer number.
	\termitem{float}{} \ldots a floating point number.
	\termitem{number}{} \ldots a number.
	\termitem{natural}{} \ldots a positive integer.
	\termitem{any}{} The corresponding argument of every occurrence
	of the constraint can have any type. This is the default value.
	\end{description}

A user-defined type is defined with a chr_type/1 declaration. For example, types
for lists, trees and colors are defined as:
\begin{code}
:- chr_type list(T) ---> [] ; [T|list(T)].
:- chr_type tree(T) ---> nil ; tree(T,tree(T),tree(T)).
:- chr_type color   ---> red ; blue ; green.
\end{code}

\subsection{Compilation}
%--------------------

The SWI-Prolog CHR compiler exploits term_expansion/2 rules to
translate the constraint handling rules to plain Prolog. These rules are
loaded from the library \pllib{chr}. They are activated if the compiled
file has the \fileext{chr} extension or after finding a declaration of
the format below.

\begin{code}
:- chr_constraint ...
\end{code}

It is adviced to define CHR rules in a module file, where the module
declaration is immediately followed by including the library(chr) library
as exemplified below:

\begin{code}
:- module(zebra, [ zebra/0 ]).
:- use_module(library(chr)).

:- chr_constraint ...
\end{code}

Using this style CHR rules can be defined in ordinary Prolog .pl files and
the operator definitions required by CHR do not leak into modules where they
might cause conflicts.

\section{Debugging}			\label{sec:debugging}
%=================

The CHR debugging facilities are currently rather limited. Only tracing
is currently available. To use the CHR debugging facilities for a CHR
file it must be compiled for debugging. Generating debug info is
controlled by the CHR option \const{debug}, whose default is derived
from the SWI-Prolog flag \const{generate_debug_info}.  Therefore debug
info is provided unless the \cmdlineoption{-nodebug} is used.


\subsection{Ports}				\label{sec:chrports}
%===============

For CHR constraints the four standard ports are defined:

\begin{itemlist}
	\termitem{call}{}
A new constraint is called and becomes active.
	\termitem{exit}{}
An active constraint exits: it has either been inserted in the store after
trying all rules or has been removed from the constraint store.
	\termitem{fail}{}
An active constraint fails.
	\termitem{redo}{}
An active constraint starts looking for an alternative solution.
\end{itemlist}

In addition to the above ports, CHR constraints have five additional
ports:

\begin{itemlist}
	\termitem{wake}{}
A suspended constraint is woken and becomes active.
	\termitem{insert}{}
An active constraint has tried all rules and is suspended in
the constraint store.
	\termitem{remove}{}
An active or passive constraint is removed from the constraint
store.
\termitem{try}{}
	An active constraints tries a rule with possibly
	some passive constraints. The try port is entered
	just before committing to the rule.
\termitem{apply}{}
	An active constraints commits to a rule with possibly
	some passive constraints. The apply port is entered
	just after committing to the rule.
\end{itemlist}

\subsection{Tracing}
%=================

Tracing is enabled with the chr_trace/0 predicate
and disabled with the chr_notrace/0 predicate.

When enabled the tracer will step through the \const{call},
\const{exit}, \const{fail}, \const{wake} and \const{apply} ports,
accepting debug commands, and simply write out the other ports.

The following debug commans are currently supported:

\begin{verbatim}
        CHR debug options:

                <cr>    creep           c       creep
		s	skip
		g	ancestors
                n       nodebug
		b	break
                a       abort
                f       fail
                ?       help            h       help
\end{verbatim}

Their meaning is:

\begin{itemlist}
	\termitem{creep}{}
Step to the next port.
	\termitem{skip}{}
Skip to exit port of this call or wake port.
	\termitem{ancestors}{}
Print list of ancestor call and wake ports.
	\termitem{nodebug}{}
Disable the tracer.
	\termitem{break}{}
Enter a recursive Prolog toplevel.  See break/0.
	\termitem{abort}{}
Exit to the toplevel.  See abort/0.
	\termitem{fail}{}
Insert failure in execution.
	\termitem{help}{}
Print the above available debug options.
\end{itemlist}

\subsection{CHR Debugging Predicates} 		\label{sec:predicates}
%====================================

The \pllib{chr} module contains several predicates that allow
inspecting and printing the content of the constraint store.

\begin{description}
    \predicate{chr_trace}{0}{}
Activate the CHR tracer.  By default the CHR tracer is activated and
deactivated automatically by the Prolog predicates trace/0 and
notrace/0.

    \predicate{chr_notrace}{0}{}
De-activate the CHR tracer.  By default the CHR tracer is activated and
deactivated automatically by the Prolog predicates trace/0 and
notrace/0.
    
    \predicate{chr_leash}{1}{+Spec}
Define the set of CHR ports on which the CHR tracer asks for user
intervention (i.e.\ stops). \arg{Spec} is either a list of ports as
defined in \secref{chrports} or a predefined `alias'. Defined aliases
are: \const{full} to stop at all ports, \const{none} or \const{off} to
never stop, and \const{default} to stop at the \const{call},
\const{exit}, \const{fail}, \const{wake} and \const{apply} ports.
See also leash/1.

    \predicate{chr_show_store}{1}{+Mod}
Prints all suspended constraints of module \arg{Mod} to the standard
output. This predicate is automatically called by the SWI-Prolog toplevel at
the end of each query for every CHR module currently loaded.  The prolog-flag
\const{chr_toplevel_show_store} controls whether the toplevel shows the
constraint stores. The value \const{true} enables it.  Any other value
disables it.


\end{description}


\section{Examples}			\label{sec:examples}
%================

Here are two example constraint solvers written in CHR.

\begin{itemize}
    \item
The program below defines a solver with one constraint, 
leq/2, which is a less-than-or-equal constraint, also known as
a partial order constraint.

\begin{code}
:- module(leq,[leq/2]).
:- use_module(library(chr)).

:- chr_constraint leq/2.
reflexivity  @ leq(X,X) <=> true.
antisymmetry @ leq(X,Y), leq(Y,X) <=> X = Y.
idempotence  @ leq(X,Y) \ leq(X,Y) <=> true.
transitivity @ leq(X,Y), leq(Y,Z) ==> leq(X,Z).
\end{code}

When the above program is saved in a file and loaded in SWI-Prolog, you can
call the leq/2 constraints in a query, e.g.:
\begin{code}
?- leq(X,Y), leq(Y,Z).
leq(_G23837, _G23841)
leq(_G23838, _G23841)
leq(_G23837, _G23838)

X = _G23837{leq = ...}
Y = _G23838{leq = ...}
Z = _G23841{leq = ...}

Yes
\end{code}
When the query succeeds, the SWI-Prolog toplevel prints the content of the
CHR constraint store and displays the bindings generate during the query. Some of the query variables may have been bound to
attributed variables, as you see in the above example.

    \item
The program below implements a simple finite domain
constraint solver.

\begin{code}
:- module(dom,[dom/2]).
:- use_module(library(chr)).

:- chr_constraint dom(?int,+list(int)). 
:- chr_type list(T) ---> [] ; [T|list(T)].

dom(X,[]) <=> fail.
dom(X,[Y]) <=> X = Y.
dom(X,L) <=> nonvar(X) | memberchk(X,L).
dom(X,L1), dom(X,L2) <=> intersection(L1,L2,L3), dom(X,L3).
\end{code}

When the above program is saved in a file and loaded in SWI-Prolog, you can
call the dom/2 constraints in a query, e.g.:

\begin{code}	
?- dom(A,[1,2,3]), dom(A,[3,4,5]).

A = 3

Yes
\end{code}
	
\end{itemize}

\section{Backwards Compatibility} 		\label{sec:sicstus-chr}
%==================

There are small differences between the current K.U.Leuven CHR system
in SWI-Prolog, older versions of the same system and SICStus' CHR system.

The current system maps old syntactic elements onto new ones and ignores a
number of no longer required elements. However, for each a {\em deprecated}
warning is issued. You are strongly urged to replace or remove deprecated
features.

Besides differences in available options and pragmas, the following differences
should be noted:

\begin{itemlist}
        \item [The constraints/1 declaration]
This declaration is deprecated. It has been replaced with the
chr_constraint/1 declaration.

        \item [The option/2 declaration]
This declaration is deprecated. It has been replaced with the
chr_option/2 declaration.

        \item [The handler/1 declaration]
In SICStus every CHR module requires a handler/1
declaration declaring a unique handler name. This declaration is valid
syntax in SWI-Prolog, but will have no effect. A warning will be given
during compilation.

        \item [The rules/1 declaration]
In SICStus, for every CHR module it is possible to only enable a subset
of the available rules through the rules/1 declaration. The
declaration is valid syntax in SWI-Prolog, but has no effect. A
warning is given during compilation.

	\item [Guard bindings]
The \texttt{check_guard_bindings} option only turns invalid calls to
unification into failure. In SICStus this option does more: it intercepts
instantiation errors from Prolog built-ins such as is/2 and
turns them into failure. In SWI-Prolog, we do not go this far, as we like
to separate concerns more. The CHR comiler is aware of the CHR code, the Prolog
system and programmer should be aware of the appropriate meaning of the
Prolog goals used in guards and bodies of CHR rules.
\end{itemlist}


\section{Guidelines} 			\label{sec:guidelines}
%==================

In this section we cover several guidelines on how to use CHR to write
constraint solvers and how to do so efficiently.

\begin{itemlist}

   \item [Check guard bindings yourself]
It is considered bad practice to write guards that bind variables of 
the head and to rely on the system to detect this at runtime. It is
inefficient and obscures the working of the program.

    \item [Set semantics]
The CHR system allows the presence of identical constraints, i.e.
multiple constraints with the same functor, arity and arguments. For
most constraint solvers, this is not desirable: it affects efficiency
and possibly termination. Hence appropriate simpagation rules should be
added of the form: \[ constraint \backslash constraint <=> true \]

    \item [Multi-headed rules]
Multi-headed rules are executed more efficiently when the constraints
share one or more variables.

    \item [Mode and type declarations]
Provide mode and type declarations to get more efficient program execution.
Make sure to disable debug (-nodebug) and enable optimization (-O).

    \item [Compile once, run many times]
Does consulting your CHR program take a long time in SWI-Prolog? Probably
it takes the CHR compiler a long time to compile the CHR rules into Prolog
code. When you disable optimizations the CHR compiler will be a lot quicker,
but you may loose performance. Alternatively, you can just use SWI-Prolog's
qcompile/1 to generate a \fileext{qlf} file once from your
\fileext{pl} file. This fileext{qlf} contains the generated code of the
CHR compiler (be it in a binary format). When you consult the \fileext{qlf}
file, the CHR compiler is not invoked and consultation is much faster.
\end{itemlist}
