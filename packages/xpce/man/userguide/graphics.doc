\chapter{Simple graphics}	\label{sec:graphics}

In chapter~\ref{sec:starting} we introduced the basic notions of PCE.
For the examples we used standard UI components.  The standard UI
components are easy to use because they have been specialised to serve
a particular role.  In this section we present some of the basic
graphical components.  These are less specialised and therefore more
general but also more difficult to use.

This section only introduces the basics of graphics in PCE.
See also Chapter~\ref{sec:chess}, \cite{PCE:overview} and \cite{PCE:draw}.   
The online manual and the demo programs provide more information on using
PCE's graphics.


\section{Primitive graphicals}

PCE defines various primitives graphical objects.  This section
discusses how these may be used.  An overview of the graphical
capabilities of PCE may be found in \cite{PCE:overview} or using the
online manual.

\begin{code}
1 ?- new(@p, picture('Demo Picture')),
     send(@p, open).
\end{code}

\index{graphical,window}\index{window,coordinates}%
A picture is a window for displaying drawings (collections of
graphical objects). The default picture may be scrolled using its
scrollbars. The drawing area is two-dimensional and infinitely
large (both positive and negative). 

The following queries draw various primitive graphicals on the
picture.

\begin{code}
2 ?- send(@p, display, new(@bo, box(100,100))).
3 ?- send(@p, display, new(@ci, circle(50)), point(25,25)).
4 ?- send(@p, display, new(@bm, bitmap('pce.bm')), point(100,100)).
5 ?- send(@p, display, new(@tx, text('Hello')), point(120, 50)).
\end{code}

The result is shown in figure~\ref{fig:graphics}.

\postscriptfig{graphics}{Example graphics}

PCE's graphics infrastructure automatically takes care of necessary
repaint operations when graphical objects are manipulated.  Try the
following queries to test this:

\begin{code}
6 ?- send(@bo, radius, 10).
7 ?- send(@ci, fill_pattern, @grey25_image).
8 ?- send(@tx, font, font(times, bold, 18)).
\end{code}

PCE avoids unnecessary repaint operations and expensive computations
involved in updating the screen.  The screen is only updated {\em
after} all available input has been processed or on an explicit
request to update it.


\section{Compound graphicals}

Sometimes one would like to combine two or more primitive graphical
objects into a single unit.  This is achieved using class \class{device}.
Below we create an icon, consisting of a bitmap and a textual label
displayed below it.

\begin{code}
9 ?- new(@ic, device),
     send(@ic, display, bitmap('happy.bm')),
     send(@ic, display, text('Happy'), point(0, 64)),
     send(@p, display, @ic, point(250, 20)).
\end{code}

A compound graphical may be treated as a unit.  It may be moved, erased,
coloured, etc.\ by sending a single message to the compound.  Compound
graphicals are normal graphicals and thus may de displayed on other
compound graphicals, resulting in a consists-of hierarchy of nested
graphicals.  See also section\ref{sec:vishierarchy}.


\section{Constraints}

PCE allows the user to specify constraints between pairs of
objects.  In the example above  we would like the text to
be centered relative to the bitmap.  This may be achieved using:

\begin{code}
10 ?- get(@ic, member, bitmap, Bitmap),
      get(@ic, member, text, Text),
      new(_, constraint(Bitmap, Text, identity(center_x))).
\end{code}

Each time either the bitmap or the text changes this constraint will
invoke <-center_x on the changed object and ->center_x with the return
value on the other object.  Class \class{spatial} defines more
general geometrical constraints between graphicals.


\section{Activating graphicals using the mouse}		\label{sec:recogniser}

\index{event,processing}\index{sensitive}\index{moving graphicals} {\em
Recogniser} objects enable detection of mouse- and keyboard activities.
PCE defines both primitive and complex recognisers. The first (called
{\em handler}) processes a single event. The latter processes a {\em
gesture}: sequence of events starting with a mouse-button-down up to the
corresponding mouse-button-up. The following example allows us to move
the icon by dragging with the middle mouse button:

\begin{code}
11 ?- send(@ic, recogniser, new(move_gesture)).
\end{code}

The second example allow us to double-click on the icon.  This is a common
way to `open'\index{open,icon} an icon.  In the example we will just
print 'hello' in the Prolog window.

\begin{code}
12 ?- send(@ic, recogniser,
           click_gesture(left, '', double,
			 message(@pce, write_ln, hello))).
\end{code}


\section{Summary}

In this section we have introduced some of graphics capabilities of
PCE as well as some more advance possibilities of the PCE/Prolog
interface.  PCE's graphics are build from primitive and compound
graphicals.  A compound graphical has its own coordinate system in
which it can display any graphical object including other compound
objects.

Graphical objects are made sensitive to mouse and keyboard activities
by attaching recogniser objects to them.  PCE defines standard
recognisers for various complex operations such as moving, resizing,
popup-menu's, linking graphicals and clicking on graphicals.

