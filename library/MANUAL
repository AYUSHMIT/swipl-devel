
                    University of Amsterdam

                       Dept.  of Social
                      Science Informatics

                             (SWI)
                     Roeterstraat 15, 1018
                         WB  Amsterdam
                        The Netherlands
                    Tel.  (+31) 20 5256121

                         SSWWII--PPrroolloogg 22..99
                        RReeffeerreennccee MMaannuuaall

              U_p_d_a_t_e_d_ f_o_r_ v_e_r_s_i_o_n_ 2_._9_._0_,_ J_u_n_e_ 1_9_9_7_

                         J_a_n_ W_i_e_l_e_m_a_k_e_r_

                       jan@swi.psy.uva.nl

SWI-Prolog  is a Prolog implementation based on a subset of the
WAM  (Warren Abstract Machine ).   SWI-Prolog has been designed
and  implemented  such  that  it  can  easily  be modified  for
experiments  with  logic programming  and the  relation between
logic  programming and other programming paradigms (such as the
object  oriented XPCE environment ).  SWI-Prolog has a rich set
of  built-in predicates and reasonable performance, which makes
it  possible to  develop substantial applications  in it.   The
current  version offers a module system, garbage collection and
an interface to the C language.

This  document gives an overview of the features, system limits
and built-in predicates.

Copyright Oc 1990--1997, University of Amsterdam


CChhaapptteerr 11..  IINNTTRROODDUUCCTTIIOONN


11..11 SSWWII--PPrroolloogg

SWI-Prolog  has   been  designed  and  implemented   to  get  a   Prolog
implementation which can be used for experiments  with logic programming
and  the  relation  to other  programming  paradigms.     The  intention
was  to  build  a Prolog  environment  which  offers  enough  power  and
flexibility to  write substantial applications,  but is  straightforward
enough to  be modified for experiments  with debugging, optimisation  or
the introduction of  non-standard data types.  Performance  optimisation
is  limited due  to the  main objectives:    portability (SWI-Prolog  is
entirely written in C and Prolog) and modifiability.

SWI-Prolog  is based  on  a very  restricted  form  of the  WAM  (Warren
Abstract  Machine) described  in   which  defines only  7  instructions.
Prolog  can easily  be  compiled into  this  language and  the  abstract
machine code  is easily  decompiled back  into Prolog.   As  it is  also
possible  to wire  a standard  4-port debugger  in  the WAM  interpreter
there is  no need  for a  distinction between  compiled and  interpreted
code.    Besides simplifying  the  design of  the Prolog  system  itself
this  approach has  advantages for  program development:   the  compiler
is  simple and  fast,  the  user does  not  have  to decide  in  advance
whether debugging is  required and the system only runs  slightly slower
when in  debug mode.    The price  we have  to pay  is some  performance
degradation (taking out  the debugger from the WAM interpreter  improves
performance by about  20%) and somewhat additional memory usage  to help
the decompiler and debugger.

SWI-Prolog  extends  the  minimal  set  of   instructions  described  in
to  improve  performance.    While  extending  this set  care  has  been
taken  to  maintain  the advantages  of  decompilation  and  tracing  of
compiled  code.     The  extensions   include  specialised  instructions
for unification,  predicate  invocation, some  frequently used  built-in
predicates, arithmetic, and  control (;//22, |//22), if-then (->//22)  and not
(\+//11).

This  manual  does  not  describe  the  full  syntax  and  semantics  of
SWI-Prolog,  nor how  one  should write  a  program in  Prolog.    These
subjects have  been described extensively  in the literature.   See ,  ,
and .   For  more advanced Prolog material  see .   Syntax and  standard
operator declarations confirm  to the `Edinburgh standard'.   Most built
in predicates are compatible with those described in .   SWI-Prolog also
offers a number  of primitive predicates compatible with Quintus  Prolog
and BIM_Prolog .

ISO compliant predicates are based on ``Prolog:  The Standard'', .


11..22 SSttaattuuss

This manual describes  version 2.9 of SWI-Prolog.   SWI-Prolog has  been
used  now for  several years.    The application  range includes  Prolog
course  material,  meta-interpreters,  simulation  of  parallel  Prolog,
learning systems, natural language processing and  two large workbenches
for knowledge engineering.   Although we experienced rather  obvious and
critical bugs can remain unnoticed for a remarkable long  period, we can
assume the basic Prolog  system is fairly stable.  Bugs can  be expected
in infrequently used builtin predicates.

Some bugs are known to  the author.  They are described as  footnotes in
this manual.


11..33 SShhoouulldd yyoouu bbee UUssiinngg SSWWII--PPrroolloogg??

There are a number of reasons why you better  choose a commercial Prolog
system, or another academic product:

  o S_W_I_-_P_r_o_l_o_g_ i_s_ n_o_t_ s_u_p_p_o_r_t_e_d_
    Although  I usually fix bugs shortly  after a bug report arrives,  I
    cannot  promise anything.   Now that the  sources are provided,  you
    can always dig into them yourself.

  o M_e_m_o_r_y_ r_e_q_u_i_r_e_m_e_n_t_s_ a_n_d_ p_e_r_f_o_r_m_a_n_c_e_ a_r_e_ y_o_u_r_ f_i_r_s_t_ c_o_n_c_e_r_n_s_
    A  number  of  commercial compilers  are  more  keen on  memory  and
    performance  than SWI-Prolog.   I do not  wish to sacrifice some  of
    the  nice features of the system, nor its portability to  compete on
    raw performance.

  o Y_o_u_ n_e_e_d_ f_e_a_t_u_r_e_s_ n_o_t_ o_f_f_e_r_e_d_ b_y_ S_W_I_-_P_r_o_l_o_g_
    In  this case you  may wish to  give me suggestions for  extensions.
    If  you  have great  plans, please  contact me  (you  might have  to
    implement them yourself however).

On the other hand, SWI-Prolog offers some nice facilities:

  o N_i_c_e_ e_n_v_i_r_o_n_m_e_n_t_
    This includes `Do  What I Mean', automatic completion of atom names,
    history mechanism and  a tracer that operates on single key-strokes.
    Interfaces  to standard  Unix editors  are  provided, as  well as  a
    facility to maintain programs (see mmaakkee//00).

  o V_e_r_y_ f_a_s_t_ c_o_m_p_i_l_e_r_
    The  compiler handles  about  100K bytes  per second  on a  SPARC-II
    processor.

  o T_r_a_n_s_p_a_r_e_n_t_ c_o_m_p_i_l_e_d_ c_o_d_e_
    SWI-Prolog  compiled code can be  treated just as interpreted  code:
    you  can list  it,  trace it,  assert to  or retract  from it,  etc.
    This  implies you do not have to decide beforehand whether  a module
    should  be loaded for debugging or  not.  Also, performance  is much
    better than the performance of most interpreters.

  o P_r_o_f_i_l_i_n_g_
    SWI-Prolog offers tools  for performance analysis, which can be very
    useful  to optimise  programs.   Unless you  are very familiar  with
    Prolog  and Prolog  performance  considerations this  might be  more
    helpful than a better compiler without these facilities.

  o F_l_e_x_i_b_i_l_i_t_y_
    SWI-Prolog  allows  for   easy  and  flexible  integration  with  C,
    both  Prolog calling  C functions  as C  calling Prolog  predicates.
    SWI-Prolog  is provided  in source  form,  which implies  SWI-Prolog
    can  be linked in  with another package.   Command line options  and
    predicates  to obtain information from the system and  feedback into
    the system are provided.

  o I_n_t_e_g_r_a_t_i_o_n_ w_i_t_h_ X_P_C_E_
    SWI-Prolog  offers  a  tight  integration  to  the  Object  Oriented
    Package  for User Interface Development,  called XPCE . XPCE  allows
    you  to implement  graphical  user interfaces  that are  source-code
    compatible over Unix/X11 and Win32 (Windows 95 and NT).


11..44 TThhee XXPPCCEE GGUUII ssyysstteemm ffoorr PPrroolloogg

The  XPCE GUI  system  for dynamically  typed  languages has  been  with
SWI-Prolog for  a long time.   It is  developed by Anjo Anjewierden  and
Jan  Wielemaker from  the department  of SWI,  University of  Amsterdam.
It  aims at  a  high-productive  development environment  for  graphical
applications based on Prolog.

Object  oriented  technology has  proven  to  be a  suitable  model  for
implementing GUIs, which  typically deal with things Prolog is  not very
good  at:   event-driven  control  and global  state.    With  XPCE,  we
designed  a system  that has  similar characteristics  that make  Prolog
such  a powerful  tool:   dynamic typing,  meta-programming and  dynamic
modification of the running system.

XPCE is  an object-system written  in the C-language.   It provides  for
the implementation of methods  in multiple languages.  New  XPCE classes
may be defined from Prolog using a simple, natural syntax.   The body of
the method is executed  by Prolog itself, providing a  natural interface
between the two systems.  Below is a very simple class definition.

:- pce_begin_class(prolog_lister, frame,
                   "List Prolog predicates").

initialise(Self) :->
        "As the C++ constructor"::
        send(Self, send_super, initialise, 'Prolog Lister'),
        send(Self, append, new(D, dialog)),
        send(D, append,
             text_item(predicate, message(Self, list, @arg1))),
        send(new(view), below, D).

list(Self, From:name) :->
        "List predicates from specification"::
        (   term_to_atom(Term, From)
        ->  get(Self, member, view, V),
            pce_open(V, write, Fd),
            set_output(Fd),
            listing(Term),
            close(Fd)
        ;   send(Self, report, error, 'Syntax error')
        ).

:- pce_end_class.

test :- send(new(prolog_lister), open).

The  165  built-in   classes  deal  with  the  meta-environment,   data-
representation  and---of  course---graphics.     The   graphics  classes
concentrate on direct-manipulation of diagrammatic representations.

AAvvaaiillaabbiilliittyy.. XPCE  runs  on  most  Unixtm  platforms,  Windows  95  and
Windows NT. It has been connected to SWI-Prolog, SICStustm and Quintustm
Prolog as well  as some Lisp dialects and  C++.  The Quintus version  is
commercially distributed and supported as ProWindows-3tm.

IInnffoo.. further        information        is         available        from
http://www.swi.psy.uva.nl/projects/xpce/home.html   or  by   E-mail   to
xpce-request@swi.psy.uva.nl.   There is  a demo  version for Windows  95
and  NT  in  ftp://swi.psy.uva.nl/pub/xpce/Windows/bin/,   and  one  for
the  i386/Linux  system in  ftp://swi.psy.uva.nl/pub/xpce/linux.     For
information  on  ProWindows-3,  please  see  http://www.aiil.co.uk,   or
contact sales@aiil.co.uk.


11..55 VVeerrssiioonn 11..55 RReelleeaassee NNootteess

There are not many  changes between version 1.4 and 1.5.   The C-sources
have been  cleaned and  comments have been  updated.   The stack  memory
management based on  using the MMU has been  changed to run on a  number
of System-V  Unix systems offering  shared memory.   Handling dates  has
been  changed.   All  functions  handling dates  now return  a  floating
point number,  expressing the  time in  seconds since  January 1,  1970.
A predicate  ccoonnvveerrtt__ttiimmee//88 is available to  get the  year, month,  etc.
The predicate  ttiimmee//66 has  been deleted.   ggeett__ttiimmee//11 and ccoonnvveerrtt__ttiimmee//88
together do the same.

From version 1.5, the system is distributed in source  form, rather than
in object  form as used with  previous releases.   This allows users  to
port SWI-Prolog  to new  machines, extend and  improve the  system.   If
you want  your changes to  be incorporated in  the next release,  please
indicate  all changes  using  a C-preprocessor  flag and  send  complete
source files  back to  me.   Difference  listings are  of no  use, as  I
generally won't have exactly the same version around.


11..66 VVeerrssiioonn 11..66 RReelleeaassee NNootteess

Version  1.6 is  completely  compatible with  version  1.5.    Some  new
features have  been added,  the system  has been ported  to various  new
platforms and  there is  a provisional  interface to  GNU Emacs.    This
interface will be improved and documented later.

The WAM  virtual-machine interpreter  has been modified  to use  GCC-2's
support for threaded code.

From version 1.6,  the sources are now  versioned using the CVS  version
control system.


11..77 VVeerrssiioonn 11..77 RReelleeaassee NNootteess

Version  1.7  integrates the  GNU-readline  library,  offering  powerful
history and command-line editing both using Emacs and vi key-bindings.


11..88 VVeerrssiioonn 11..88 RReelleeaassee NNootteess

Version  1.8 offers  a stack-shifter  to  provide dynamically  expanding
stacks  on machines  that  do  not offer  operating-system  support  for
implementing dynamic stacks.


11..99 VVeerrssiioonn 11..99 RReelleeaassee NNootteess

Version  1.9  offers  better portability  including  an  MS-Windows  3.1
version.  Changes to the Prolog system include:

  o R_e_d_e_f_i_n_i_t_i_o_n_ o_f_ s_y_s_t_e_m_ p_r_e_d_i_c_a_t_e_s_
    Redefinition  of system  predicates  was allowed  silently in  older
    versions.    Version 1.9  only allows it  if the  new definition  is
    headed by a :- rreeddeeffiinnee__ssyysstteemm__pprreeddiiccaattee//11directive.

  o `_A_n_s_w_e_r_'_ r_e_u_s_e_
    The  toplevel maintains  a table  of bindings  returned by  toplevel
    goals  and  allows for  reuse  of these  bindings by  prefixing  the
    variables with the $ sign.  See section 2.5.

  o B_e_t_t_e_r_ s_o_u_r_c_e_ c_o_d_e_ a_d_m_i_n_i_s_t_r_a_t_i_o_n_
    Allows  for proper updating of multifile predicates and  finding the
    sources of individual clauses.


11..1100 VVeerrssiioonn 22..00 RReelleeaassee NNootteess

Version 2.0 is  first of all a freeze  of all the features added to  the
various 1.9.x releases.  Version 2.0.6 for PC has  moved from the WATCOM
C  32-bit windows  extender to  Windows NT  and runs  under Windows  3.1
using the Win32s NT emulator.

New features offered:

  o 3_2_-_b_i_t_ V_i_r_t_u_a_l_ M_a_c_h_i_n_e_
    Removes various limits and improves performance.

  o I_n_l_i_n_e_ f_o_r_e_i_g_n_ f_u_n_c_t_i_o_n_s_
    `Simple'  foreign predicates no  longer build a Prolog  stack-frame,
    but are directly  called from the VM. Notably provides a speedup for
    the test predicates such as vvaarr//11, etc.

  o V_a_r_i_o_u_s_ c_o_m_p_a_t_i_b_i_l_i_t_y_ i_m_p_r_o_v_e_m_e_n_t_s_

  o S_t_r_e_a_m_ b_a_s_e_d_ I_/_O_ l_i_b_r_a_r_y_
    All  SWI-Prolog's I/O is now  handled by the stream-package  defined
    in  the foreign include file SWI-Stream.h.   Physical I/O of  Prolog
    streams  may be  redefined through the  foreign language  interface,
    facilitating much simpler integration in window environments.

Version 2.0.6 offers a few incompatibilities:

  o rreettrraaccttaallll//11
    In previous releases, the definition of rreettrraaccttaallll//11 was:

    retractall(Term) :-
            retract(Term),
            fail.
    retractall(_).

    As   from  version   2.0.6,   rreettrraaccttaallll//11  is   implemented  as   a
    deterministic foreign predicate  compatible with Quintus Prolog.  It
    behaves as:

    retractall(Head) :-
            retract(Head),
            fail.
    retractall(Head) :-
            retract((Head :- _)),
            fail.
    retractall(_).

    I.e.  the  definition  behaves  the same  when  handling  predicates
    consisting  of  facts.     Clauses with  a  non-true  body  will  be
    retracted if their head matches.

  o F_o_r_e_i_g_n_ i_n_t_e_r_f_a_c_e_ t_y_p_e_s_
    All  foreign interface types now  have names ending in  _t to  lessen
    the  chance for conflicts.   term, atomic,  functor and module  have
    #define's for backward compatibility.

  o PPLL__rreeggiisstteerr__ffoorreeiiggnn(())
    The  attributes is now  a bitwise or  of the attribute flags  rather
    than  a 0 terminated list.  This has no consequences  for predicates
    that  have no attributes (99%  of them), while predicates with  just
    one  attribute will generate a  compiler warning, but work  properly
    otherwise.     Predicates with  more  than  one attributes  must  be
    changed.

  o PL_dispatch_events
    This  pointer  is replaced  by PPLL__ddiissppaattcchh__hhooookk(()).    A function  was
    necessary for the Win32 .DLL interface.


11..1111 VVeerrssiioonn 22..11 RReelleeaassee NNootteess

In addition  to several  bug fixes,  the 2.1 versions  provide some  new
features:

  o sseettaarrgg//33
    A new  predicate sseettaarrgg//33 for extra-logical (destructive) assignment
    to arguments of terms is provided.

  o M_o_d_i_f_i_e_d_ kkeeyyssoorrtt//22
    kkeeyyssoorrtt//22  is now stable with regard to multiple values on  the same
    key.  Makes this predicate compatible with SICStus and Quintus.

  o M_o_d_i_f_i_e_d_ g_r_a_m_m_a_r_ r_u_l_e_ e_x_p_a_n_s_i_o_n_
    DCG  translation of  free variables  now calls  pphhrraassee//33, which  has
    been  changed slightly to deal  with `un-parsing'.  Modification  is
    probably  not complete,  but it fixes  some problems encountered  by
    Michael B"ohlen.

  o E_x_c_e_p_t_i_o_n_ h_a_n_d_l_i_n_g_
    The  top of the runtime  stack are automatically dumped on  floating
    point exceptions.

  o F_o_r_e_i_g_n_ i_n_t_e_r_f_a_c_e_
    Added   facilities  to   allow   for  embedding   SWI-Prolog  in   C
    applications.


11..1122 VVeerrssiioonn 22..55 RReelleeaassee NNootteess

Version 2.5  is an  intermediate release on  the path  from 2.1 to  3.0.
All  changes  are to  the  foreign-language  interface,  both  to  user-
and  system predicates  implemented  in the  C-language.    The  aim  is
twofold.   First of all  to make garbage-collection and  stack-expansion
(stack-shifts)  possible  while  foreign  code  is  active  without  the
C-programmer having  to worry  about locking  and unlocking  C-variables
pointing  to Prolog  terms.    The new  approach is  closely  compatible
to the  Quintus and  SICStus Prolog  foreign interface  using the  +term
argument specification (see their respective manuals).   This allows for
writing foreign  interfaces that  are easily portable  over these  three
Prolog platforms.

According  to the  current plan,  ISO compliant  exception handling  and
hooks for source-code debugging will be added before the  system will be
called 3.0.

Apart from  various bug fixes  listed in the  Changelog file, these  are
the main changes since 2.1.0:

  o I_S_O_ c_o_m_p_a_t_i_b_i_l_i_t_y_
    Many   ISO  compatibility  features   have  been  added:     ooppeenn//44,
    arithmetic functions, syntax, etc.

  o W_I_N_3_2_
    Many  fixes for the Win32 (NT,  '95 and win32s) platforms.   Notably
    many  problems related  to pathnames  and a problem  in the  garbage
    collector.

  o P_e_r_f_o_r_m_a_n_c_e_
    Many  changes to  the clause  indexing system:   added  hash-tables,
    lazy computation of the index information, etc.

  o P_o_r_t_a_b_l_e_ s_a_v_e_d_-_s_t_a_t_e_s_
    The   predicate  qqssaavvee__pprrooggrraamm//[[11,,22]] allows  for  the   creating  of
    machine independent saved-states that load very quickly.


11..1133 VVeerrssiioonn 22..66 RReelleeaassee NNootteess

Version 2.6  provides a stable implementation  of the features added  in
the 2.5.x  releases, but  at the same  time implements  a number of  new
features that may have impact on the system stability.

  o 3_2_-_b_i_t_ i_n_t_e_g_e_r_ a_n_d_ d_o_u_b_l_e_ f_l_o_a_t_ a_r_i_t_h_m_e_t_i_c_
    The  biggest change is the  support for full 32-bit signed  integers
    and  raw  machine-format  double precision  floats.    The  internal
    data  representation as well as  the arithmetic instruction set  and
    interface to the arithmetic functions has been changed for this.

  o E_m_b_e_d_d_i_n_g_ f_o_r_ W_i_n_3_2_ a_p_p_l_i_c_a_t_i_o_n_s_
    The  Win32 version has been reorganised.   The Prolog kernel is  now
    implemented  as Win32  DLL that may  be embedded in  C-applications.
    Two front ends  are provided, one for window-based operation and one
    to run as a Win32 console application.

  o C_r_e_a_t_i_n_g_ s_t_a_n_d_-_a_l_o_n_e_ e_x_e_c_u_t_a_b_l_e_s_
    Version  2.6.0 can create  stand-alone executables by attaching  the
    saved-state to the emulator.  See qqssaavvee__pprrooggrraamm//22.


11..1144 VVeerrssiioonn 22..77 RReelleeaassee NNootteess

Version 2.7  reorganises the  entire data-representation  of the  Prolog
data  itself.   The  aim is  to remove  most of  the  assumption on  the
machine's memory  layout to  improve portability in  general and  enable
embedding on  systems where the memory  layout may depend on  invocation
or on  how the executable is  linked.  The  latter is notably a  problem
on  the Win32  platforms.   Porting  to 64-bit  architectures should  be
feasible now.

Furthermore, 2.7 lifts the  limits on arity of predicates and  number of
variables in  a clause considerably and  allow for further expansion  at
minimal cost.


11..1155 VVeerrssiioonn 22..88 RReelleeaassee NNootteess

data-representation changes of  2.7.x stable.  Version 2.8  exploits the
changes of of 2.7 to  support 64-bit processors like the DEC Alpha.   As
of version 2.8.5, the representation of recorded the  terms has changed,
and  terms  on the  heap  are  now  represented in  a  compiled  format.
SWI-Prolog no longer limits  the use of mmaalllloocc(()) or uses  assumptions on
the addresses returned by this function.


11..1166 VVeerrssiioonn 22..99 RReelleeaassee NNootteess

Version  2.9  is  the next  step  towards  version  3.0,  improving  ISO
compliance  and introducing  ISO  compliant  exception handling.     New
are ccaattcchh//33, tthhrrooww//11,  aabboolliisshh//11, wwrriittee__tteerrmm//[[22,,33]], wwrriittee__ccaannoonniiccaall//[[11,,22]]
and  the  C-functions PPLL__eexxcceeppttiioonn(()) and  PPLL__tthhrrooww(()).    The  predicates
ddiissppllaayy//[[11,,22]] and ddiissppllaayyqq//[[11,,22]]  have been moved to  library(backcomp),
so old code referring to them will autoload them.

The interface  to PPLL__ooppeenn__qquueerryy(()) has changed.   The  d_e_b_u_g_ argument  is
replaced  by a  bitwise or'ed  f_l_a_g_s_ argument.    The  values FALSE  and
TRUE have their familiar meaning, making old code  using these constants
compatible.   Non-zero values  other than TRUE  (1) will be  interpreted
different.


11..1177 AAcckknnoowwlleeddggeemmeennttss

Some  small  parts  of  the  Prolog  code  of  SWI-Prolog  are  modified
versions of  the corresponding  Edinburgh C-Prolog code:   grammar  rule
compilation  and wwrriitteeff//22.    Also some  of the  C-code originates  from
C-Prolog:  finding the path of the currently running  executable and the
code underlying  aabbssoolluuttee__ffiillee__nnaammee//22.   Ideas on  programming style  and
techniques originate from  C-Prolog and Richard O'Keefe's t_h_i_e_f_  editor.
An  important  source  of inspiration  are  the  programming  techniques
introduced by Anjo Anjewierden in PCE version 1 and 2.

I also  would like to thank  those who had the  fade of using the  early
versions of this system,  suggested extensions or reported bugs.   Among
them are Anjo Anjewierden, Huub Knops, Bob  Wielinga, Wouter Jansweijer,
Luc Peerdeman, Eric Nombden, Frank van Harmelen, Bert Rengel.

Martin Jansche  (jansche@novell1.gs.uni-heidelberg.de) has been so  kind
to reorganise the sources for version 2.1.3 of this manual.

Horst  von Brand  has been  so  kind to  fix many  typos  in the  2.7.14
manual.  Thanks!


CChhaapptteerr 22..  OOVVEERRVVIIEEWW


22..11 SSttaarrttiinngg SSWWII--PPrroolloogg ffrroomm tthhee UUnniixx SShheellll

It  is  advised to  install  SWI-Prolog  as  `pl' in  the  local  binary
directory.    SWI-Prolog can  then be  started from  the  Unix shell  by
typing `pl'.  The system will boot from the  system's default boot file,
perform the  necessary initialisations  and then  enter the  interactive
top level.

After  the necessary  system  initialisation  the system  consults  (see
ccoonnssuulltt//11) the  user's initialisation  file.   This initialisation  file
should be named  `.plrc' and reside either  in the current directory  or
in the  user's home directory.   If both  exist the initialisation  file
from the current  directory is loaded.   The name of the  initialisation
file  can be  changed with  the `-f file'  option.    After loading  the
initialisation  file SWI-Prolog  executes  a user  initialisation  goal.
The default goal is  a system predicate that prints the  banner message.
The  default can  be  modified with  the `-g goal'  option.    Next  the
toplevel goal is started.   Default is the interactive Prolog  loop (see
pprroolloogg//00).  The  user can overwrite this default with  the `-t toplevel'
option.


22..11..11 CCoommmmaanndd LLiinnee OOppttiioonnss

The full set of command line options is given below:

--hheellpp
    When  given as  the only  option, it summarises  the most  important
    options.

--vv
    When  given as the  only option, it  summarises the version and  the
    architecture identifier.

--aarrcchh
    When   given  as  the  only  option,  it  prints   the  architecture
    identifier (see feature(arch, Arch)) and exits.

--LLs_i_z_e_[_k_m_]_
    Give  local stack limit (2 Mbytes default).   Note that there  is no
    space  between the size option  and its argument.   By default,  the
    argument  is interpreted in  Kbytes.   Postfixing the argument  with
    m  causes the argument to be  interpreted in Mbytes.  The  following
    example specifies 32 Mbytes local stack.

    % pl -L32m

    A maximum is  useful to stop buggy programs from claiming all memory
    resources.  -L0 sets the limit to the highest possible value.

--GGs_i_z_e_[_k_m_]_
    Give  global  stack limit  (4 Mbytes  default).    See -L  for  more
    details.

--TTs_i_z_e_[_k_m_]_
    Give  trail  stack  limit  (4  Mbytes  default).     This  limit  is
    relatively  high because trail-stack overflows are not  often caused
    program bugs.  See -L for more details.

--AAs_i_z_e_[_k_m_]_
    Give  argument stack limit (1 Mbytes  default).  The argument  stack
    limits  the  maximum  nesting of  terms  that  can be  compiled  and
    executed.    The  SWI-Prolog  does `last-argument  optimisation'  to
    avoid  many deeply  nested structure  using this stack.    Enlarging
    this  limit is only  necessary in extreme  cases.   See -L for  more
    details.

--HHs_i_z_e_[_k_m_]_
    Give  mmaalllloocc(()) heap limit.   The  default is to  raise the limit  as
    high  as possible.  This  option only applies to machines using  the
    mmmmaapp(())  function for allocating the Prolog stacks.  See -L  for more
    details.

--cc f_i_l_e_ ._._._
    Compile files into an `intermediate code file'.  See section 2.7.

--oo o_u_t_p_u_t_
    Used  in combination  with -c  or -b  to determine  output file  for
    compilation.

--OO
    Optimised compilation.  See pplleeaassee//33.

--ff f_i_l_e_
    Use  f_i_l_e_ as  initialisation  file instead  of `.plrc'.    `-f none'
    stops SWI-Prolog from searching for an initialisation file.

--FF s_c_r_i_p_t_
    Selects  a startup-script from the  SWI-Prolog home directory.   The
    script-file  is  named <s_c_r_i_p_t_>.rc.    The  default s_c_r_i_p_t_  name  is
    deduced  from  the  executable,  taking the  leading  alphanumerical
    characters  (letters, digits and underscore) from  the program-name.
    -F none stops looking  for a script.  Intended for simple management
    of  slightly  different  versions.    One  could for  example  write
    a  script  iso.rc  and  then select  ISO  compatibility  mode  using
    pl -F iso or make a link from iso-pl to pl.

--gg g_o_a_l_
    G_o_a_l_  is executed just before entering the top level.  Default  is a
    predicate  which prints the  welcome message.   The welcome  message
    can  thus be suppressed by  giving -g true.   g_o_a_l_ can be a  complex
    term.   In this case quotes  are normally needed to protect  it from
    being expanded by the Unix shell.

--tt g_o_a_l_
    Use  g_o_a_l_  as  interactive  toplevel instead  of  the  default  goal
    pprroolloogg//00.    g_o_a_l_  can be  a complex  term.   If  the toplevel  goal
    succeeds  SWI-Prolog exits  with status  0.   If it  fails the  exit
    status  is  1.    This  flag also  determines  the goal  started  by
    bbrreeaakk//00  and aabboorrtt//00.   If you want to  stop the user from  entering
    interactive  mode  start the  application  with `-g goal'  and  give
    `halt' as toplevel.

--ttttyy
    Switches  tty  control (using  ioctl(2)) on  (+tty)  or off  (-tty).
    Normally  tty  control is  switched on.    This  default depends  on
    the  installation.    You may  wish  to switch  tty control  off  if
    Prolog  is used  from an  editor such  as Emacs.    If switched  off
    ggeett__ssiinnggllee__cchhaarr//11and the tracer will wait for a return.

--xx b_o_o_t_f_i_l_e_
    Boot  from b_o_o_t_f_i_l_e_ instead  of the system's default  boot file.   A
    bootfile is a  file resulting from a Prolog compilation using the -b
    or -c option or a program saved using qqssaavvee__pprrooggrraamm//[[11,,22]].

--rr r_e_s_t_o_r_e_f_i_l_e_
    Restore  a state  created by ssaavvee__pprrooggrraamm//[[11,,22]] or ssaavvee//[[11,,22]]  using
    the  new-style  saved-states.   Equivalent  to  restore(restorefile)
    from Prolog.

--pp a_l_i_a_s_=_p_a_t_h_1_[_:_p_a_t_h_2_ ._._._]_
    Define  a path  alias for  file_search_path.    a_l_i_a_s_ is  the name  of
    the  alias, p_a_t_h_1_  ._._._   is  a : separated  list of  values for  the
    alias.    A  value is  either a  term of  the  form alias(value)  or
    pathname.    The  computed  aliases are  added to  ffiillee__sseeaarrcchh__ppaatthh//22
    using  aasssseerrttaa//11, so they precede  predefined values for the  alias.
    See  ffiillee__sseeaarrcchh__ppaatthh//22 for  details  on  using  this  file-location
    mechanism.

--
    Stops  scanning for more  arguments, so you  can pass arguments  for
    your application after this one.

The following options  are for system maintenance.   They are given  for
reference only.

--bb i_n_i_t_f_i_l_e_ ._._._-c f_i_l_e_ ._._._
    Boot  compilation.   i_n_i_t_f_i_l_e_  ._._._   are compiled  by the  C-written
    bootstrap  compiler,  f_i_l_e_  ._._._    by  the normal  Prolog  compiler.
    System maintenance only.

--dd l_e_v_e_l_
    Set  debug  level to  l_e_v_e_l_.    Only  has effect  if the  system  is
    compiled with the -DO_DEBUG flag.  System maintenance only.


22..22 GGNNUU EEmmaaccss IInntteerrffaaccee

A provisional  interface to emacs  has been  included since version  1.6
of  SWI-Prolog.    The interface  is  based  on the  freely  distributed
interface  delivered  with Quintus  Prolog.    When  running  Prolog  as
an  inferior process  under  GNU-Emacs,  there  is support  for  finding
predicate  definitions,  completing  atoms,  finding  the  locations  of
compilation-warnings  and  many  more.    For  details,  see  the  files
pl/lisp/README and pl/lisp/swi-prolog.el.


22..33 OOnnlliinnee HHeellpp

Online  help  provides a  fast  lookup  and browsing  facility  to  this
manual.   The online  manual can show predicate  definitions as well  as
entire sections of the manual.


hheellpp
    Equivalent to help(hheellpp//11).


hheellpp((+_W_h_a_t_))
    Show specified part of the manual.  W_h_a_t_ is one of:

          <N_a_m_e_>/<A_r_i_t_y_> give help on specified predicate
          <N_a_m_e_>         give  help on  named  predicate with  any
                         arity or  C interface function  with that
                         name
          <S_e_c_t_i_o_n_>      display  specified  section.      section
                         numbers are dash-separated  numbers:  2-3
                         refers  to  section 2.3  of  the  manual.

                         Section   numbers  are   obtained   using
                         aapprrooppooss//11.

    Examples

       ?- help(assert).     give help on predicate assert
       ?- help(3-4).        display section 3.4 of the manual
       ?- help('PL_retry'). give    help   on    interface   function
                            PPLL__rreettrryy(())


aapprrooppooss((+_P_a_t_t_e_r_n_))
    Display all predicates,  functions and sections that have P_a_t_t_e_r_n_ in
    their  name or summary  description.   Lowercase letters in  P_a_t_t_e_r_n_
    also match a corresponding uppercase letter.  Example:

        ?- apropos(file).  Display  predicates,  functions and  sec-
                           tions that have  `file' (or `File', etc.)
                           in their summary description.


eexxppllaaiinn((+_T_o_E_x_p_l_a_i_n_))
    Give an explanation on  the given `object'.  The argument may be any
    Prolog data object.   If the argument is an atom, a term of the form
    N_a_m_e_/_A_r_i_t_y_  or a term  of the  form M_o_d_u_l_e_:_N_a_m_e_/_A_r_i_t_y_, explain  will
    try to explain the predicate as well as possible references to it.


eexxppllaaiinn((+_T_o_E_x_p_l_a_i_n_,_ -_E_x_p_l_a_n_a_t_i_o_n_))
    Unify  E_x_p_l_a_n_a_t_i_o_n_ with an explanation for T_o_E_x_p_l_a_i_n_.   Backtracking
    yields further explanations.


22..44 QQuueerryy SSuubbssttiittuuttiioonnss

SWI-Prolog  offers a  query substitution  mechanism similar  to that  of
Unix csh (csh(1)), called `history'.  It allows the  user to compose new
queries from those typed  before and remembered by the system.   It also
allows to correct queries and syntax errors.   SWI-Prolog does not offer
the Unix csh capabilities  to include arguments.  This is omitted  as it
is unclear how the first, second, etc. argument should be defined.

The available  history commands  are shown  in table  2.1.   Figure  2.1
gives some examples.
       __________________________________________________________
       | !!.            |Repeat last query                        |
       | !nr.           |Repeat query numbered <n_r_>               |
       | !str.          |Repeat last query starting with <s_t_r_>    |
       | !?str.         |Repeat last query holding <s_t_r_>          |
       | ^old^new.      |Substitute <o_l_d_> into <n_e_w_> of last query |

       | !nr^old^new.   |Substitute in query numbered <n_r_>        |
       | !str^old^new.  |Substitute in query starting with <s_t_r_>  |
       | !?str^old^new. |Substitute in query holding <s_t_r_>        |
       | h.             |Show history list                        |
       |_!h.____________|Show_this_list__________________________ |

                      Table 2.1:  History commands

/staff/jan/.plrc consulted, 0.066667 seconds, 591 bytes
Welcome to SWI-Prolog (Version \plversion)
Copyright (c) 1993-1996 University of Amsterdam.  All rights reserved.

For help, use ?- help(Topic). or ?- apropos(Word).

1 ?- append("Hello ", "World", L).

L = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]

Yes
2 ?- !!, writef('L = %s\n', [L]).
append("Hello ", "World", L), writef('L = %s\n', [L]).

L = Hello World

L = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]

Yes
3 ?- sublist(integer, [3, f, 3.4], L).

L = [3]

Yes
4 ?- ^integer^number.
sublist(number, [3, f, 3.4], L).

L = [3, 3.400000]

Yes
5 ?- h.
    1   append("Hello ", "World", L).
    2   append("Hello ", "World", L), writef('L = %s\n', [L]).
    3   sublist(integer, [3, f, 3.4], L).
    4   sublist(number, [3, f, 3.4], L).

5 ?- !2^World^Universe.

append("Hello ", "Universe", L), writef('L = %s\n', [L]).
L = Hello Universe

L = [72, 101, 108, 108, 111, 32, 85, 110, 105, 118, 101, 114, 115, 101]

Yes
6 ?- halt.

           Figure 2.1:  Some examples of the history facility


22..44..11 LLiimmiittaattiioonnss ooff tthhee HHiissttoorryy SSyysstteemm

When  in   top  level   SWI-Prolog  reads  the   user's  queries   using
rreeaadd__hhiissttoorryy//66 rather  than rreeaadd//11.    This  predicate first  reads  the
current input  stream up to  a full stop.   While doing  so it maps  all
contiguous blank  space onto  a single  space and  deletes /* ...*/  and
% ...<c_r_> comments.   Parts between double quotes  (") or single  quotes
(') are  left unaltered.   Note that  a Prolog full  stop consists of  a
`non-symbol' character,  followed by a period  (.), followed by a  blank
character.    `Symbol' characters  are:   #$&*+-./:<=>?@^`~.   A  single
quote immediately preceded  by a digit (0-9)  is considered part of  the
<d_i_g_i_t_>'<d_i_g_i_t_>...(e.g. 2'101; binary number 101) sequence.

After this initial parsing  the result is first checked for  the special
^<o_l_d_>^<n_e_w_>.construction.  If this fails the string is  checked for all
occurrences of  the !,  followed by  a !,  ?, a  digit, a  letter or  an
underscore.   These special sequences  are analysed and the  appropriate
substitution from the history list is made.

From the  above it  follows that  it is  hard or  impossible to  correct
quotation with single or double quotes, comment delimiters and spacing.


22..55 RReeuussee ooff ttoopplleevveell bbiinnddiinnggss

Bindings resulting from the successful execution of a  toplevel goal are
asserted in a database.  These values may be  reused in further toplevel
queries as $Var.  Only the latest binding is available.  Example:
1 ?- maplist(plus(1), "hello", X).

X = [105,102,109,109,112]

2 ?- format('~s~n', [$X]).
ifmmp

                 Figure 2.2:  Reusing toplevel bindings

Note that variables may be set by executing =//22:

6 ?- X = statistics.

X = statistics

7 ?- $X.
28.00 seconds cpu time for 183,128 inferences
4,016 atoms, 1,904 functors, 2,042 predicates, 52 modules
55,915 byte codes; 11,239 external references

                      Limit    Allocated       In use
Heap         :                                624,820 Bytes
Local  stack :    2,048,000        8,192          404 Bytes
Global stack :    4,096,000       16,384          968 Bytes
Trail  stack :    4,096,000        8,192          432 Bytes


22..66 OOvveerrvviieeww ooff tthhee DDeebbuuggggeerr

SWI-Prolog has a  standard 4-port tracer   with an optional fifth  port.
This fifth  port, called  u_n_i_f_y_ allows  the user to  inspect the  result
after unification of the head.   The ports are called call,  exit, redo,
fail and unify.   The tracer is  started by the ttrraaccee//00 command, when  a
spy point  is reached  and the system  is in  debugging mode (see  ssppyy//11
and ddeebbuugg//00) or  when an error is  detected at run time.   Note that  in
the interactive  toplevel goal ttrraaccee//00 means  ``trace the next  query''.
The tracer shows the  port, displaying the port name, the  current depth
of the  recursion and the goal.   The goal  is printed using the  Prolog
predicate pprriinntt//11  (default), wwrriittee//11  or ddiissppllaayy//11.   An example  using
all five ports is shown in figure 2.3.
Yes
2 ?- visible(+all), leash(-exit).

Yes
3 ?- trace, min([3, 2], X).
  Call:  ( 3) min([3, 2], G235) ? creep
  Unify: ( 3) min([3, 2], G235)
  Call:  ( 4) min([2], G244) ? creep
  Unify: ( 4) min([2], 2)

  Exit:  ( 4) min([2], 2)
  Call:  ( 4) min(3, 2, G235) ? creep
  Unify: ( 4) min(3, 2, G235)
  Call:  ( 5) 3 < 2 ? creep
  Fail:  ( 5) 3 < 2 ? creep
  Redo:  ( 4) min(3, 2, G235) ? creep
  Exit:  ( 4) min(3, 2, 2)
  Exit:  ( 3) min([3, 2], 2)

                       Figure 2.3:  Example trace

On l_e_a_s_h_e_d_  p_o_r_t_s_ (set  with the  predicate lleeaasshh//11,  default are  call,
exit, redo and  fail) the user is prompted  for an action.  All  actions
are single character  commands which are executed wwiitthhoouutt waiting  for a
return (Unix  `cbreak' mode),  unless the  command line  option -tty  is
active.  Tracer options:

+ ((SSppyy))
    Set a spy point (see ssppyy//11) on the current predicate.

- ((NNoo ssppyy))
    Remove the spy point (see nnoossppyy//11) from the current predicate.

/ ((FFiinndd))
    Search  for a port.   After the  `/', the user  can enter a line  to
    specify  the port to  search for.   This line consists  of a set  of
    letters  indicating the  port type,  followed by  an optional  term,
    that  should unify with  the goal run by  the port.   If no term  is
    specified  it is taken as a variable, searching for any port  of the
    specified  type.  If an atom is given, any goal whose  functor has a
    name equal to that atom matches.  Examples:

            /f               Search for any fail port
            /fe solve        Search for a  fail or exit  port of
                             any goal with name solve
            /c solve(a, _)   Search for a call to  solve/2 whose

                             first argument is a variable or the
                             atom a
            /a member(_, _)  Search for  any  port on  mmeemmbbeerr//22.
                             This is equivalent to setting a spy
                             point on mmeemmbbeerr//22.

. ((RReeppeeaatt ffiinndd))
    Repeat the last find command (see `/')

A ((AAlltteerrnnaattiivveess))
    Show all goals that have alternatives.

C ((CCoonntteexxtt))
    Toggle  `Show Context'.   If on  the context module  of the goal  is
    displayed between square brackets (see section 4).  Default is off.

L ((LLiissttiinngg))
    List the current predicate with lliissttiinngg//11.

a ((AAbboorrtt))
    Abort Prolog execution (see aabboorrtt//00).

b ((BBrreeaakk))
    Enter a Prolog break environment (see bbrreeaakk//00).

c ((CCrreeeepp))
    Continue execution, stop at next port.  (Also return, space).

d ((DDiissppllaayy))
    Write goals using the Prolog predicate ddiissppllaayy//11.

e ((EExxiitt))
    Terminate Prolog (see hhaalltt//00).

f ((FFaaiill))
    Force failure of the current goal

g ((GGooaallss))
    Show the list of  parent goals (the execution stack).  Note that due
    to  tail recursion optimization a  number of parent goals might  not
    exist any more.

h ((HHeellpp))
    Show available options (also `?').

i ((IIggnnoorree))
    Ignore the current goal, pretending it succeeded.

l ((LLeeaapp))
    Continue execution, stop at next spy point.

n ((NNoo ddeebbuugg))
    Continue execution in `no debug' mode.

p ((PPrriinntt))
    Write goals using the Prolog predicate pprriinntt//11 (default).

r ((RReettrryy))
    Undo  all actions (except for database and i/o actions) back  to the
    call  port of  the current  goal and  resume execution  at the  call
    port.

s ((SSkkiipp))
    Continue  execution,  stop  at the  next  port  of tthhiiss  goal  (thus
    skipping all calls to children of this goal).

u ((UUpp))
    Continue  execution, stop at the next port of tthhee ppaarreenntt  goal (thus
    skipping  this goal and all calls to  children of this goal).   This
    option is useful to stop tracing a failure driven loop.

w ((WWrriittee))
    Write goals using the Prolog predicate wwrriittee//11.

The  ideal  4  port  model  as  described  in  many  Prolog  books    is
not visible  in many  Prolog implementations  because code  optimisation
removes  part  of  the  choice- and  exit  points.     Backtrack  points
are not  shown if  either the  goal succeeded  deterministically or  its
alternatives were  removed using the  cut.  When  running in debug  mode
(ddeebbuugg//00) choice points are only destroyed when removed by the  cut.  In
debug mode tail recursion optimisation is switched off.


22..77 CCoommppiillaattiioonn

Collections  of  SWI-Prolog  source  files  can  be   compiled  into  an
i_n_t_e_r_m_e_d_i_a_t_e_ c_o_d_e_ f_i_l_e_.   An intermediate code file is a data  file from
which SWI-Prolog  can be started.   The command  to compile a bundle  of
source files is:

pl [options] [-o output] -c file ...

The individual source  files may include other files using  the standard
list notation,  ccoonnssuulltt//11,  eennssuurree__llooaaddeedd//11and  uussee__mmoodduullee//[[11,,22]].    When
the -o file option is  omitted a file named a.out is created  that holds
the intermediate code file.

Intermediate code files  start with the BSD  Unix magic code #! and  are
executable.  This implies they can be started as a command:

% pl -o my_program -c ...
...
% my_program [options]

Alternatively, my_program can be started with

% pl -x my_program [options]

The  following  restrictions  apply to  source  files  that  are  to  be
compiled with `-c':

  o tteerrmm__eexxppaannssiioonn//22 should  not  use aasssseerrtt//11  and or  rreettrraacctt//11  other
    than for local computational purposes.

  o Files  can  only be  included by  the  standard include  directives:
    [...],   ccoonnssuulltt//11,  eennssuurree__llooaaddeedd//11 and  uussee__mmoodduullee//[[11,,22]].     User
    defined loading predicate invocations will not be compiled.

Directives  are  executed  both when  compiling  the  program  and  when
loading the intermediate code file.


22..88 EEnnvviirroonnmmeenntt CCoonnttrrooll

The current  system defines 3 different  mechanisms to query and/or  set
properties  of the  environment:    pplleeaassee//33,  ffllaagg//33 and  ffeeaattuurree//22  as
well  as a  number of  special purpose  predicates  of which  uunnkknnoowwnn//22,
ffiilleeeerrrroorrss//22 are examples.  The ISO standard defines prolog_flag.  It is
likely that all  these global features will  be merged into a single  in
the future.


pplleeaassee((+_K_e_y_,_ -_O_l_d_,_ +_N_e_w_))
    The  predicate pplleeaassee//33  is  a solution  to avoid  large numbers  of
    environment  control  predicates.     Later  versions  will  support
    other  environment  control  as  now  provided  via  the  predicates
    ssttyyllee__cchheecckk//11,  lleeaasshh//11,  uunnkknnoowwnn//22,  the  tracer  predicates,  etc.
    These  predicates  are  then  moved into  a  library  for  backwards
    compatibility.  The currently available options are:

    ooppttiimmiissee o_n_/_o_f_f_ (default:  o_f_f_)_
         Switch optimise  mode  for the  compiler on  or  off (see  also
         the command line  option -O).   Currently optimise  compilation
         only  implies  compilation  of  arithmetic,   making  it  fast,
         but  invisible to  the  tracer.    Later versions  might  imply
         various  other optimisations  such  as incorporating  a  number
         of basic  predicates  in the  virtual machine  (vvaarr//11,  ffaaiill//00,
         =/2,  etc.)    to  gain speed  at  the  cost of  crippling  the
         debugger.  Also source level optimisations  such as integrating
         small  predicates  into  their  callers,  eliminating  constant
         expressions and  other  predictable constructs.    Source  code
         optimisation is never  applied to predicates that are  declared
         dynamic (see ddyynnaammiicc//11).

    aauuttoollooaadd o_n_/_o_f_f_ (default:  o_n_)_
         If on  autoloading of  library functions is  enabled.   If  off
         autoloading is disabled.  See section 2.10.

    vveerrbboossee__aauuttoollooaadd o_n_/_o_f_f_ (default:  o_f_f_)_
         If on the normal  consult message will be printed if  a library
         is  autoloaded.     By  default  this  message  is  suppressed.
         Intended to  be used  for debugging purposes  (e.g. where  does
         this predicate come from?).


ffeeaattuurree((?_K_e_y_,_ -_V_a_l_u_e_))
    The  predicate   ffeeaattuurree//22  defines  an  interface  to  installation
    features:   options  compiled in,  version, home,  etc.   With  both
    arguments unbound, it  will generate all defined features.  With the
    `Key'  instantiated it  unify the value  of the  feature.   Features
    come in three  types:  boolean features, features with an atom value
    and  features with an integer value.  A boolean feature is  true iff
    the  feature is present aanndd the V_a_l_u_e_  is the atom true.   Currently
    defined keys:

    aarrcchh ((a_t_o_m_))
         Identifier for the hardware and operating system  SWI-Prolog is
         running on.  Used  to determine the startup file as well  as to
         select foreign  files for  the right  architecture.   See  also
         llooaadd__ffoorreeiiggnn//55.

    vveerrssiioonn ((i_n_t_e_g_e_r_))
         The version identifier is an integer with value:

                          10000*_Major+ 100*_Minor+P_a_t_c_h_

         Note  that  in  releases  upto  2.7.10  this   feature  yielded
         an  atom   holding  the  three   numbers  separated  by   dots.
         The  current representation  is  much easier  for  implementing
         version-conditional statements.

    hhoommee ((a_t_o_m_))
         SWI-Prolog's  notion  of   the  home-directory.      SWI-Prolog
         uses  it's  home  directory   to  find  its  startup  file   as
         <h_o_m_e_>/startup/startup.<a_r_c_h_> and  to   find  its  library   as
         <h_o_m_e_>/library.

    ppiippee ((b_o_o_l_))
         If true, tell(pipe(command)), etc. are supported.

    llooaadd__ffoorreeiiggnn ((b_o_o_l_))
         If true, llooaadd__ffoorreeiiggnn//[[22,,55]]are implemented.

    ooppeenn__sshhaarreedd__oobbjjeecctt ((b_o_o_l_))
         If  true,  ooppeenn__sshhaarreedd__oobbjjeecctt//22 and  friends  are  implemented,
         providing  access  to shared  libraries  (.so  files).     This
         requires the C-library  functions dlopen() and friends as  well
         as the configuration option --with-dlopen.

    ddyynnaammiicc__ssttaacckkss ((b_o_o_l_))
         If  true,  the  system  provides  virtual  memory  based  stack
         expansion.  This makes stack-expansion safe when  called from C
         and while running  C-defined functions without these  functions
         taking any precautions.  Pure Prolog programs  are not affected
         by  this feature  as  the  system will  use  stack-shifting  to
         expand the stacks at runtime.

    cc__lliibbss ((a_t_o_m_))
         Libraries passed  to the C-linker  when SWI-Prolog was  linked.
         May  be  used to  determine  the  libraries  needed  to  create
         statically linked extensions for SWI-Prolog.

    cc__ssttaattiicclliibbss ((a_t_o_m_))
         On  some machines,  the  SWI-Prolog executable  is  dynamically
         linked, but requires some libraries to be statically linked.

    cc__cccc ((a_t_o_m_))
         Name of the  C-compiler used to  compile SWI-Prolog.   Normally
         either gcc or cc.

    cc__llddffllaaggss ((a_t_o_m_))
         Special linker flags passed to link SWI-Prolog.

    ssaavvee ((b_o_o_l_))
         If true, ssaavvee//[[11,,22]] is implemented.

    ssaavvee__pprrooggrraamm ((b_o_o_l_))
         If true, ssaavvee__pprrooggrraamm//[[11,,22]]is implemented.

    rreeaaddlliinnee ((b_o_o_l_))
         If true, SWI-Prolog is linked with the readline library.   This
         is done by default  if you have this library installed  on your
         system.

    ssaavveedd__pprrooggrraamm ((b_o_o_l_))
         If  true,   Prolog  is   started  from   a  state  saved   with
         qqssaavvee__pprrooggrraamm//[[11,,22]].

    rruunnttiimmee ((b_o_o_l_))
         If true,  SWI-Prolog  is compiled  with  -DO_RUNTIME,  disabling
         various useful development  features (currently the tracer  and
         profiler).

    mmaaxx__iinntteeggeerr ((i_n_t_e_g_e_r_))
         Maximum  integer  value.     Most  arithmetic  operations  will
         automatically convert  to floats if  integer values above  this
         are returned.

    mmiinn__iinntteeggeerr ((i_n_t_e_g_e_r_))
         Minimum integer value.

    mmaaxx__ttaaggggeedd__iinntteeggeerr ((i_n_t_e_g_e_r_))
         Maximum integer value represented as a `tagged' value.   Tagged
         integers require  4-bytes storage  and are  used for  indexing.
         Larger integers are represented as `indirect data'  and require
         16-bytes  on  the  stacks  (though  a  copy   requires  only  4
         additional bytes).

    mmiinn__ttaaggggeedd__iinntteeggeerr ((i_n_t_e_g_e_r_))
         Start of the tagged-integer value range.

    ffllooaatt__ffoorrmmaatt ((a_t_o_m_))
         C printf()  format specification  used by  wwrriittee//11 and  friends
         to determine  how  floating point  numbers are  printed.    The
         default is %g.  May be changed.  The  specified value is passed
         to printf()  without further  checking.   For  example, if  you
         want more  digits printed,  %.12g will print  all floats  using
         12 digits  instead of the  default 6.   See also  ffoorrmmaatt//[[11,,22]],
         wwrriittee//11, pprriinntt//11 and ppoorrttrraayy//11.

    ccoommppiilleedd__aatt ((a_t_o_m_))
         Describes when the  system has been  compiled.  Only  available
         if  the C-compiler  used  to  compile SWI-Prolog  provides  the
         __DATE__and __TIME__macros.

    cchhaarraacctteerr__eessccaappeess ((b_o_o_l_))
         If true  (default),  rreeaadd//11 interprets  \  escape sequences  in
         quoted atoms and strings.  May be changed.

    ggcc ((b_o_o_l_))
         If true (default), the garbage collector is active.   If false,
         neither garbage-collection,  nor stack-shifts will take  place,
         even not on explicit request.  May be changed.

    ttrraaccee__ggcc ((b_o_o_l_))
         If  true  (false  is  the  default),  garbage  collections  and
         stack-shifts  will  be  reported on  the  terminal.     May  be
         changed.

    mmaaxx__aarriittyy ((u_n_b_o_u_n_d_e_d_))
         ISO feature describing  there is no  maximum arity to  compound
         terms.

    iinntteeggeerr__rroouunnddiinngg__ffuunnccttiioonn ((d_o_w_n_,_t_o_w_a_r_d___z_e_r_o_))
         ISO  feature  describing rounding  by  //  and  rem  arithmetic
         functions.  Value depends on the C-compiler used.

    bboouunnddeedd ((t_r_u_e_))
         ISO  feature  describing integer  representation  is  bound  by
         min_integer and min_integer.

    ttttyy__ccoonnttrrooll ((b_o_o_l_))
         Determines whether  the terminal  is switched to  raw mode  for
         ggeett__ssiinnggllee__cchhaarr//11, which  also reads  the  user-actions for  the
         trace.  May be set.  See also the +/-tty command-line option.

    ddeebbuugg__oonn__eerrrroorr ((b_o_o_l_))
         If  true,  start  the  tracer  after   an  error  is  detected.
         Otherwise just continue  execution.   The goal that raised  the
         error  will normally  fail.    See  also ffiilleeeerrrroorrss//22  and  the
         feature report_error.  May be changed.  Default is true, except
         for the runtime version.

    rreeppoorrtt__eerrrroorr ((b_o_o_l_))
         If true, print  error messages, otherwise  suppress them.   May
         be changed.   See also the debug_on_error feature.  Default  is
         true, except for the runtime version.

    uunniixx ((b_o_o_l_))
         If  true,  the  operating  system  is  some  version  of  Unix.
         Defined  if the  C-compiler used  to  compile this  version  of
         SWI-Prolog either defines __unix__ or unix.

    wwiinnddoowwss ((b_o_o_l_))
         If  true,   the  operating  system  is  an  implementation   of
         Microsoft Windows (3.1, 95, NT, etc.).


sseett__ffeeaattuurree((+_K_e_y_,_ +_V_a_l_u_e_))
    Define  a new feature or change its  value.  Both arguments  must be
    atoms.


22..99 SSaavveedd SSttaatteess


22..99..11 TTyyppeess ooff SSaavveedd SSttaatteess aanndd PPoorrttaabbiilliittyy

On  some   architectures,   SWI-Prolog  allows  for   the  creation   of
saved  states.     Currently,  the   C-sources  define  two  alternative
implementations for  them.  The  old implementation creates an  entirely
self-contained  executable.    It supports  only  the ssaavvee__pprrooggrraamm//[[11,,22]]
predicates.  The  new implementation creates a file that is read  by the
`base' program.    This file  contains the data-area  of the  SWI-Prolog
process and optionally  the Prolog- and C  stacks.  This  implementation
supports ssaavvee__pprrooggrraamm//[[11,,22]], ssaavvee//[[11,,22]] and  rreessttoorree//11.  The  state-file
depends entirely on e_x_a_c_t_l_y_ the Unix program-file used to create it.


22..99..22 SSaavvee PPrreeddiiccaatteess


ssaavvee__pprrooggrraamm((+_N_e_w_P_r_o_g_r_a_m_,_ +_L_i_s_t_O_f_O_p_t_i_o_n_s_))
    Create   a  new   executable   which  will   be  named   N_e_w_P_r_o_g_r_a_m_.
    L_i_s_t_O_f_O_p_t_i_o_n_s_  is  a  list of  K_e_y_ = V_a_l_u_e_  pairs that  specify  the
    default  command  line  options that  will  be  saved into  the  new
    program.   If a default  is not specified the default compiled  into
    the  currently running  Prolog executable  is used.   The  available
    keys are given in table 2.2
      _____________________________________________________________
      |__KKeeyy____________||OOppttiioonn____||__TTyyppee____||DDeessccrriippttiioonn________________________________________||__
      || local    | --LL    ||K-bytes |Size (Limit) of local stack    |
      | global   | --GG    ||K-bytes |Size (Limit) of global stack   |
      | trail    | --TT    ||K-bytes |Size (Limit) of trail stack    |
      | argument | --AA    ||K-bytes |Size (Limit) of argument stack |

      | goal     | --gg    ||  atom  |Initialisation goal            |
      | toplevel | --tt    ||  atom  |Prolog toplevel goal           |
      | init_file |--ff    ||  atom  |Personal initialisation file   |
      |_tty______|++//----ttttyy_||on/off_|Use_ioctl(2)_calls_____________|_

            Table 2.2:  Key = Value pairs for ssaavvee__pprrooggrraamm//22

    As  the entire data  image of the current  process will be saved  on
    the new executable it  is desirable to keep this small.  Notably the
    Prolog  machine stacks should  be kept small.   The  best way to  do
    this  is first to compile the program using the -c option.   If this
    is  not possible try  to find the  smallest possible stack sizes  to
    compile the program.   On machines with dynamic stack allocation the
    stacks  are nnoott written to file  and so their size does not  matter.
    Figure 2.4 shows a  possible session.  Note the use of `initialise',
    which  is supposed to be a  predicate of the application doing  time
    consuming initialisation.

sun% pl -c load
foreign file dbase loaded 0.066667 seconds, 1578 bytes.
setup consulted, 0.500000 seconds, 5091 bytes.
main consulted, 0.333333 seconds, 3352 bytes.
load consulted, 1.000000 seconds, 9867 bytes.
sun% a.out -f none -L10 -G10 -T5

foreign file dbase loaded 0.066667 seconds, 1578 bytes.
Welcome to SWI-Prolog (Version \plversion)
Copyright (c) 1993-1996 University of Amsterdam.  All rights reserved.

For help, use ?- help(Topic). or ?- apropos(Word).

1 ?- initialise.

Yes
2 ?- save_program(my_program,
        [ local     = 500
        , goal      = go
        , init_file = none
        ]).
Running executable: /usr/local/bin/pl

Saving to my_program; text: 204800 ... data: 357000 ... sym-
bols ... done.
Yes
2 ?- halt.
sun%

              Figure 2.4:  Create a stand-alone executable

    The resulting program  can be used for incremental compilation using
    -c or another ssaavvee__pprrooggrraamm//22.


ssaavvee__pprrooggrraamm((+_N_e_w_P_r_o_g_r_a_m_))
    Equivalent to `save_program(NewProgram, [])'.


ssaavvee((+_S_t_a_t_e_))
    Writes  the current status on  the program, Prolog- and C-stacks  to
    the  file S_t_a_t_e_.   When  this file is  restored, ssaavvee//11 succeeds  in
    the  restored state  and execution continues  as illustrated by  the
    following example:

    1 ?- save(state), format('Hello World~n').
    Hello World

    Yes
    2 ?- halt.
    machine% ./state
    Hello World

    Yes
    2 ?- h.
        1   save(state), format('Hello World~n').
    2 ?-

    The  ssaavvee//11  predicate  is  normally used  for  debugging  purposes.
    ssaavvee__pprrooggrraamm//[[11,,22]] is the preferred way to create a new program.


ssaavvee((+_S_t_a_t_e_,_ -_R_v_a_l_))
    Like  ssaavvee//11, but  unifies R_v_a_l_ with  0 when  ssaavvee//22 returns from  a
    real save and with 1 when ssaavvee//22 returns from a restore.


rreessttoorree((+_S_t_a_t_e_))
    Equivalent to restarting S_t_a_t_e_.


22..1100 AAuuttoommaattiicc llooaaddiinngg ooff lliibbrraarriieess

If ---at  runtime--- an undefined predicate  is trapped the system  will
first try  to import  the predicate  from the  module's default  module.
If this  fails the a_u_t_o_  l_o_a_d_e_r_ is  activated.   On first activation  an
index to all library files in all library directories  is loaded in core
(see lliibbrraarryy__ddiirreeccttoorryy//11).   If the undefined  predicate can be  located
in the one  of the libraries that  library file is automatically  loaded
and the  call to the  (previously undefined) predicate is  resumed.   By
default this  mechanism loads the  file silently.   The pplleeaassee//33  option
verbose_autoload is provided to get verbose loading.   The please option
autoload can be used to enable/disable the entire auto load system.

Autoloading  only handles  (library) source  files that  use the  module
mechanism  described  in  chapter  4.     The  files   are  loaded  with
uussee__mmoodduullee//22 and only the trapped  undefined predicate will be  imported
to the module  where the undefined predicate  was called.  Each  library
directory  must hold  a file  INDEX.pl  that contains  an index  to  all
library files  in the directory.    This file consists  of lines of  the
following format:

index(Name, Arity, Module, File).

The  predicate mmaakkee//00  scans  the  autoload libraries  and  updates  the
index if  it exists,  is writable  and out-of-date.   It  is advised  to
create an empty  file called INDEX.pl in  a library directory meant  for
auto loading  before doing  anything else.    This index  file can  then
be updated  by running the prolog  mmaakkee__lliibbrraarryy__iinnddeexx//11(`%' is the  Unix
prompt):

% mkdir ~/lib/prolog
% cd !$
% pl -g true -t 'make_library_index(.)'

If  there  are  more than  one  library  files  containing  the  desired
predicate the following search schema is followed:

 1. If  a there is a library file  that defines the module in  which the
    undefined predicate is trapped, this file is used.

 2. Otherwise  library files  are considered  in the  order they  appear
    in  the  lliibbrraarryy__ddiirreeccttoorryy//11  predicate  and  within  the  directory
    alphabetically.


mmaakkee__lliibbrraarryy__iinnddeexx((+_D_i_r_e_c_t_o_r_y_))
    Create  an index for this  directory.  The  index is written to  the
    file  'INDEX.pl' in the specified directory.   Fails with a  warning
    if the directory does not exist or is write protected.


22..1100..11 NNootteess oonn AAuuttoommaattiicc LLooaaddiinngg

The autoloader is a new  feature to SWI-Prolog.  Its aim is  to simplify
program development and program  management.  Common lisp has  a similar
feature, but here the user has to specify which library  is to be loaded
if a specific  function is called which is  not defined.  The  advantage
of the  SWI-Prolog schema  is that  the user  does not  have to  specify
this.   The  disadvantage however is  that the  user might be  wondering
``where  the hell  this predicate  comes from''.    Only experience  can
learn  whether  the  functionality of  the  autoloader  is  appropriate.
Comments are welcome.

The autoloader only works if the unknown flag (see  uunnkknnoowwnn//22) is set to
trace (default).  A more appropriate interaction with  this flag will be
considered.


22..1111 GGaarrbbaaggee CCoolllleeccttiioonn

SWI-Prolog  version  1.4  was  the  first  release  to  support  garbage
collection.   Together with tail-recursion optimisation this  guaranties
forward chaining  programs do  not waste indefinite  amounts of  memory.
Previous releases of this manual stressed on  using failure-driven loops
in those  cases that  no information  needed to  be passed  to the  next
iteration via arguments.  This to avoid large amounts of  garbage.  This
is no longer strictly  necessary, but it should be noticed  that garbage
collection is a time  consuming activity.  Failure driven loops  tend to
be faster for this reason.


22..1122 SSyynnttaaxx NNootteess

SWI-Prolog uses  standard `Edinburgh'  syntax.   A  description of  this
syntax can be found in the Prolog books referenced  in the introduction.
Below are some  non-standard or non-common constructs that are  accepted
by SWI-Prolog:

  o 0'<c_h_a_r_>
    This  construct is not accepted by all Prolog systems that  claim to
    have  Edinburgh compatible syntax.  It describes the ASCII  value of
    <c_h_a_r_>.   To  test whether C is  a lower case character  one can use
    between(0'a, 0'z, C).

  o /* .../* ...*/ ...*/
    The  /* ...*/  comment statement  can be  nested.    This is  useful
    if  some  code with  /* ...*/  comment statements  in it  should  be
    commented out.


22..1122..11 IISSOO SSyynnttaaxx SSuuppppoorrtt

SWI-Prolog offers ISO compatible extensions to the Edinburgh syntax.


22..1122..11..11 CChhaarraacctteerr EEssccaappee SSyynnttaaxx

Within quoted  atoms (using single quotes:   '<a_t_o_m_>'special  characters
are represented  using escape-sequences.    An escape  sequence is  lead
in  by the  backslash  (\) character.    The  list of  escape  sequences
is compatible  with the  ISO standard,  but contains  one extension  and
the interpretation of numerically specified characters  is slightly more
flexible to improve compatibility.

\a
    Alert character.  Normally the ASCII character 7 (beep).

\b
    Backspace character.

\c
    No  output.    All  input  characters  upto but  not  including  the
    first  non-layout  character  are skipped.     This allows  for  the
    specification of pretty-looking  long lines.  For compatibility with
    Quintus Prolog.  Nor supported by ISO. Example:

    format('This is a long line that would look better if it was \c
           split across multiple physical lines in the input')

\<RETURN>
    No  output.   Skips input till the  next non-layout character or  to
    the end of the next line.  Same intention as \c but ISO compatible.

\f
    Form-feed character.

\n
    Next-line character.

\r
    Carriage-return only (i.e. go back to the start of the line).

\t
    Horizontal tab-character.

\v
    Vertical tab-character (ASCII 11).

\x23
    Hexadecimal  specification of a character.   23 is just an  example.
    The  `x'  may be  followed by  a maximum  of  2 hexadecimal  digits.
    The  closing \  is optional.   The  code \xa\3  emits the  character
    10  (hexadecimal `a')  followed by  `3'.   The code  \x201 emits  32
    (hexadecimal  `20') followed by `1'.  According to ISO,  the closing
    \  is  obligatory and  the  number  of digits  is  unlimited.    The
    SWI-Prolog  definition allows for ISO compatible specification,  but
    is compatible with other implementations.

\40
    Octal   character  specification.     The  rules  and   remarks  for
    hexadecimal  specifications apply to  octal specifications too,  but
    the maximum allowed number of octal digits is 3.

\<c_h_a_r_a_c_t_e_r_>
    Any  character  immediately  preceded by  a  \ is  copied  verbatim.
    Thus,  '\\' is an atom  consisting of a single  \ and '\'' and  ''''
    both describe the atom with a single '.

Character      escaping      is     only      available      if      the
feature(character_escapes, true) is  active (default).   See  ffeeaattuurree//22.
Character  escapes  conflict  with  wwrriitteeff//22  in  two  ways:     \40  is
interpreted as  decimal 40 by wwrriitteeff//22,  but character escapes  handling
by  read has  already  interpreted  as 32  (40  octal).    Also,  \l  is
translated to  a single  `l'.   Double  the \  (e.g. \\,  use the  above
escape sequences or use ffoorrmmaatt//22.


22..1122..11..22 SSyynnttaaxx ffoorr NNoonn--DDeecciimmaall NNuummbbeerrss

SWI-Prolog  implements  both  Edinburgh  and  ISO   representations  for
non-decimal numbers.   According to  Edinburgh syntax, such numbers  are
written as <r_a_d_i_x_>'<n_u_m_b_e_r_>, where <r_a_d_i_x_> is  a number between 2 and 36.
ISO defines binary,  octal and hexadecimal numbers using 0[bxo]<n_u_m_b_e_r_>.
For example:  A is 0b100 \/ 0xf00  is a valid expression.   Such numbers
are always unsigned.


22..1133 SSyysstteemm LLiimmiittss


22..1133..11 LLiimmiittss oonn MMeemmoorryy AArreeaass

SWI-Prolog has  a number of  memory areas which are  only enlarged to  a
certain limit.   The  default sizes for these  areas should suffice  for
most applications, but big  applications may require larger ones.   They
are modified  by command  line options.    The table  below shows  these
areas.   The first column  gives the option name  to modify the size  of
the area.  The option character is immediately followed  by a number and
optionally by  a k or  m.   With k or  no unit  indicator, the value  is
interpreted in Kbytes (1024 bytes), with m, the  value is interpreted in
Mbytes (10241* 024 bytes).

The  local-, global-  and trail-stack  are limited  to 64  Mbytes on  32
bit processors,  or more in general to  2 to the power bits-per-long - 6
bytes.
       ___________________________________________________________
       |_Option_|Default_|Area_name______|Description____________|_||-L||2Mllooccaa||llTssttaacckkhe|l||||ocal|stack is used

       |        |                        to  store   the  execu- |             |            ||
       |        |                        tion  environments   of |             |            ||
       |        |                        procedure  invocations. |             |            ||
       |        |                        The  space for  an  en- |             |            ||
       |        |                        vironment is  reclaimed |             |            ||
       |        |                        when  it  fails,  exits |             |            ||
       |        |                        without leaving  choice |             |            ||
       |        |                        points,   the  alterna- |             |            ||
       |        |                        tives are  cut of  with |             |            ||
       |        |                                                |             |            ||

       |        |                        the  !/0  predicate  or |             |            ||
       |        |                        no  choice points  have |             |            ||
       |        |                        been created  since the |             |            ||
       |        |                        invocation and the last |             |            ||
       |        |                        subclause  is   started |             |            ||
       |        |                        (tail recursion optimi- |             |            ||
       ||       ||      |               ||sation).                ||            |            ||

       |   -G   | 4M    |gglloobbaall ssttaacckk   ||Theusglobaled stacktois store| terms
       |        |       |               ||created during Prolog's |
       |        |       |               ||execution.    Terms  on |
       |        |       |               ||                        |
       |        |       |               ||this stack will  be re- |
       |        |       |               ||claimed by backtracking |
       |        |       |               ||to a  point before  the |
       |        |       |               ||term  was   created  or |
       |        |       |               ||by  garbage  collection |

       |        |       |               ||(provided  the term  is |
       ||       ||      ||              ||no||longer referenced).  ||
       |   -T   | 4M    |ttrraaiill ssttaacckk    ||Theusetraild stackto isstore|  as-
       |        |       |               ||signments during execu- |
       |        |       |               ||                        |
       |        |       |               ||tion.   Entries on this |
       |        |       |               ||stack remain  alive un- |

       |        |       |               ||til backtracking before |
       |        |       |               ||the  point of  creation |
       |        |       |               ||or the  garbage collec- |
       |        |       |               ||tor determines they are |
       ||       ||      ||              ||nor||needed any longer.  ||

       |   -A   | 1M    |aarrgguummeenntt ssttaacckk ||Theusargumentestackd isto|  store   one
       |        |       |               ||of   the   intermediate |
       |        |       |               ||code interpreter's reg- |
       |        |       |               ||isters.     The  amount |
       |        |       |               ||of space needed on this |
       |        |       |               ||stack is determined en- |
       |        |       |               ||                        |
       |        |       |               ||tirely by the  depth in |
       |        |       |               ||which terms  are nested |
       |        |       |               ||in  the   clauses  that |

       |        |       |               ||constitute the program. |
       |        |       |               ||Overflow is most likely |
       |        |       |               ||when using long strings |
       |________|_______|_______________||in_a_clause.____________|_

                        Table 2.3:  Memory areas


22..1133..11..11 TThhee hheeaapp

With  the heap,  we  refer  to the  memory  area  used by  mmaalllloocc(())  and
friends.  SWI-Prolog uses the area to store  atoms, functors, predicates
and their  clauses, records and  other dynamic data.   As of  SWI-Prolog
2.8.5, no limits are  imposed on the addresses returned by  mmaalllloocc(()) and
friends.

On  some machines,  the  runtime stacks  described above  are  allocated
using `sparse allocation'.   Virtual space upto the limit is  claimed at
startup and  committed and released  while the  area grows and  shrinks.
On Win32  platform this  is realised using  VViirrttuuaallAAlllloocc(()) and  friends.
On Unix systems this is realised using mmmmaapp(()),  either mapping /dev/zero
or a temporary file created in /tmp.

As Unix  provides no  way to  reserve part  of the  address space,  this
process may  lead to  conflicts.   By default,  SWI-Prolog computes  the
required virtual address  space for the runtime  stacks.  If  available,
it uses ggeettrrlliimmiitt(()) to  determine the top of the virtual  space reserved
for mmaalllloocc(()) usage and locates  the stacks in the top of this area.   It
assumes no  other mmmmaapp(()) activity  such as  mapping shared libraries  or
mmmmaapp(()) by foreign  modules will use the  area reserved for the heap  and
mmaalllloocc(()), mmaalllloocc(())  will grow the  heap from low  to high addresses  and
will notice the existence of the Prolog stacks.

These  assumptions appear  to  hold.    The user  may  using the  -H  to
specify the  maximum heap-size.   In this case,  the Prolog stacks  will
be allocated  at the indicated  size from the current  top of the  heap.
On  these system,  ssttaattiissttiiccss//[[00,,22]] reports  heaplimit and  heap.    The
heaplimit value is the  distance between the b_r_e_a_k_ and the  first Prolog
stack.   The heap value is the  distance between what Prolog assumes  to
be the base of the heap and the current location of the break.


22..1133..22 OOtthheerr LLiimmiittss

CCllaauusseess  Currently the  following limitations  apply to  clauses.    The
    arity  may not be more than 1024 and the number of  variables should
    be less than 65536.

AAttoommss aanndd SSttrriinnggss  SWI-Prolog  has no  limits  on  the  sizes  of  atoms
    and  strings.   rreeaadd//11  and its derivatives  however normally  limit
    the  number  of newlines  in  an  atom or  string  to 5  to  improve
    error  detection  and recovery.    This  can  be switched  off  with
    ssttyyllee__cchheecckk//11.

AAddddrreessss ssppaaccee  SWI-Prolog  data  is  packed  in  a 32-bit  word,   which
    contains  both type and value information.  The size of  the various
    memory areas is limited  to 128 Mb for each of the areas.  With some
    redesign,  the program area could be split into data that  should be
    within  this range and  the rest of  the data, virtually  unlimiting
    the program size.

IInntteeggeerrss  Integers are 32-bit to the  user, but integers upto the  value
    of the max_tagged_integer feature are represented more efficiently.

FFllooaattss  Floating  point  numbers   are  represented  as  native   double
    precision floats, 64 bit IEEE on most machines.


22..1133..33 RReesseerrvveedd NNaammeess

The boot  compiler (see -b  option) does not  support the module  system
(yet).    As large  parts of  the system  are written  in Prolog  itself
we  need some  way to  avoid name  clashes with  the user's  predicates,
database keys, etc.   Like Edinburgh C-Prolog  all  predicates, database
keys, etc. that should  be hidden from the user start with a  dollar ($)
sign (see ssttyyllee__cchheecckk//11).

The  compiler uses  the  special  functor $VAR$/1  while  analysing  the
clause  to  compile.      Using  this   functor  in  a  program   causes
unpredictable behaviour of the compiler and resulting program.


CChhaapptteerr 33..  BBUUIILLTT--IINN PPRREEDDIICCAATTEESS


33..11 NNoottaattiioonn ooff PPrreeddiiccaattee DDeessccrriippttiioonnss

We have  tried to  keep the  predicate descriptions  clear and  concise.
First  the predicate  name is  printed  in bold  face, followed  by  the
arguments in  italics.   Arguments  are preceded by  a `+',  `-' or  `?'
sign.    `+'  indicates the  argument is  input  to the  predicate,  `-'
denotes output and  `?'  denotes `either  input or output'.   Constructs
like `oopp//33' refer to the predicate `op' with arity `3'.


33..22 CCoonnssuullttiinngg PPrroolloogg SSoouurrccee ffiilleess

SWI-Prolog source files  normally have a suffix  `.pl'.  Specifying  the
suffix  is optional.    All predicates  that handle  source files  first
check  whether a  file with  suffix  `.pl' exists.    If  not the  plain
file name  is checked  for existence.   Library  files are specified  by
embedding the file name using the functor lliibbrraarryy//11.   Thus `foo' refers
to `foo.pl'  or `foo'  in the current  directory, `library(foo)'  refers
to `foo.pl'  or `foo'  in one  of the library  directories specified  by
the dynamic predicate  lliibbrraarryy__ddiirreeccttoorryy//11.   The user may specify  other
`aliases'  than library  using the  predicate ffiillee__sseeaarrcchh__ppaatthh//22.    This
is strongly  encouraged for  managing complex  applications.   See  also
aabbssoolluuttee__ffiillee__nnaammee//[[22,,33]].

SWI-Prolog  recognises grammar  rules as  defined in  .    The user  may
define  additional  compilation  of the  source  file  by  defining  the
dynamic predicate  tteerrmm__eexxppaannssiioonn//22.   Transformations by this  predicate
overrule  the  systems  grammar  rule  transformations.      It  is  not
allowed to  use aasssseerrtt//11, rreettrraacctt//11 or  any other database predicate  in
tteerrmm__eexxppaannssiioonn//22other than for local computational purposes.

Directives  may be  placed  anywhere  in a  source  file,  invoking  any
predicate.    They are  executed when  encountered.    If the  directive
fails, a warning is printed.  Directives are specified  by :-/1 or ?-/1.
There is no difference between the two.

SWI-Prolog   does   not   have   a   separate   rreeccoonnssuulltt//11   predicate.
Reconsulting  is  implied automatically  by  the  fact that  a  file  is
consulted which is already loaded.


llooaadd__ffiilleess((+_F_i_l_e_s_,_ +_O_p_t_i_o_n_s_))
    The  predicate llooaadd__ffiilleess//22 is the parent  of all the other  loading
    predicates.    It  currently supports  a subset  of  the options  of
    Quintus  llooaadd__ffiilleess//22.    F_i_l_e_s_ is either  specifies a  single, or  a
    list  of  source-files.    The specification  for a  source-file  is
    handled  aabbssoolluuttee__ffiillee__nnaammee//22.   See this predicate for  the supported
    expansions.  O_p_t_i_o_n_s_ is a list of options using the format

         O_p_t_i_o_n_N_a_m_e_(O_p_t_i_o_n_V_a_l_u_e_)

    The following options are currently supported:

    iiff((C_o_n_d_i_t_i_o_n_))
         Load the  file only  if the specified  condition is  satisfied.
         The value  true loads the  file unconditionally, changed  loads
         the file  if it  was not loaded  before, or  has been  modified
         since it was loaded the last time, not_loaded loads the file if
         it was not loaded before.

    mmuusstt__bbee__mmoodduullee((B_o_o_l_))
         If true,  raise an  error if  the file  is not  a module  file.
         Used by uussee__mmoodduullee//[[11,,22]].

    iimmppoorrttss((L_i_s_t_O_r_A_l_l_))
         If  all and  the  file is  a  module file,  import  all  public
         predicates.  Otherwise import only the named predicates.   Each
         predicate is refered to  as <n_a_m_e_>/<a_r_i_t_y_>.  This  option has no
         effect if the file is not a module file.

    ssiilleenntt((B_o_o_l_))
         If  true, load  the  file  without printing  a  message.    The
         specified  value is  the  default for  all  files loaded  as  a
         result of loading the specified files.


ccoonnssuulltt((+_F_i_l_e_))
    Read  F_i_l_e_ as a Prolog  source file.  F_i_l_e_  may be a list of  files,
    in  which case all members  are consulted in turn.   F_i_l_e_ may  start
    with  the csh(1) special sequences ~,  ~<u_s_e_r_>and $<v_a_r_>.  F_i_l_e_  may
    also be library(Name),  in which case the libraries are searched for
    a  file with the specified  name.   See also lliibbrraarryy__ddiirreeccttoorryy//11 and
    ffiillee__sseeaarrcchh__ppaatthh//22.   ccoonnssuulltt//11 may be  abbreviated by just typing  a
    number of file names in a list.  Examples:

        ?- consult(load).       % consult load or load.pl
        ?- [library(quintus)].  % load Quintus compatibility library

    Equivalent to load_files(Files, []).


eennssuurree__llooaaddeedd((+_F_i_l_e_))
    If the file  is not already loaded, this is equivalent to ccoonnssuulltt//11.
    Otherwise,   if  the  file  defines  a  module,  import  all  public
    predicates.    Finally,  if the  file is  already loaded,  is not  a
    module  file and the context module  is not the global user  module,
    eennssuurree__llooaaddeedd//11 will call ccoonnssuulltt//11.

    With the semantics, we  hope to get as closely possible to the clear
    semantics  without the presence  of a module  system.   Applications
    using modules should consider using uussee__mmoodduullee//[[11,,22]].

    Equivalent to load_files(Files, [if(changed)]).


rreeqquuiirree((+_L_i_s_t_O_f_N_a_m_e_A_n_d_A_r_i_t_y_))
    Declare  that  this file/module  requires the  specified  predicates
    to  be defined ``with  their commonly accepted  definition''.   This
    predicate originates from  the Prolog portability layer for XPCE. It
    is  intended to  provide a  portable mechanism  for specifying  that
    this module requires the specified predicates.

    The implementation normally  first verifies whether the predicate is
    already defined.   If not, it will search the libraries and load the
    required library.

    SWI-Prolog, having autoloading,  does nnoott load the library.  Instead
    it  creates a procedure  header for the  predicate if this does  not
    exist.    This will flag  the predicate  as `undefined'.   See  also
    cchheecckk//00 and aauuttoollooaadd//00.


mmaakkee
    Consult  all source  files that  have been changed  since they  were
    consulted.   It checks a_l_l_  loaded source files:  files loaded  into
    a  compiled state  using pl -c ...  and files  loaded using  consult
    or  one of  its  derivatives.   mmaakkee//00  is normally  invoked by  the
    eeddiitt//[[00,,11]]  and eedd//[[00,,11]] predicates.   mmaakkee//00  can be combined  with
    the  compiler to speed  up the  development of large  packages.   In
    this case compile the package using

    sun% pl -g make -o my_program -c file ...

    If  `my_program' is started it will first reconsult  all source files
    that have changed since the compilation.


lliibbrraarryy__ddiirreeccttoorryy((?_A_t_o_m_))
    Dynamic  predicate used  to specify  library directories.    Default
    ./lib,  ~/lib/prolog and  the system's library  (in this order)  are
    defined.    The  user may  add library  directories using  aasssseerrtt//11,
    aasssseerrttaa//11 or remove system defaults using rreettrraacctt//11.


ffiillee__sseeaarrcchh__ppaatthh((+_A_l_i_a_s_,_ ?_P_a_t_h_))
    Dynamic  predicate used to specify `path-aliases'.  This  feature is
    best described using an example.  Given the definition

    file_search_path(demo, '~/demo').

    the   file   specification   demo(myfile)  will   be   expanded   to
    ~/demo/myfile.    The second  argument of  ffiillee__sseeaarrcchh__ppaatthh//22may  be
    another alias.

    Below  is the  initial definition  of the file  search path.    This
    path  implies  swi(<P_a_t_h_>)  refers  to  a  file  in  the  SWI-Prolog
    home   directory.     The  alias  foreign(<P_a_t_h_>) is   intended  for
    storing   shared  libraries  (.so  or   .DLL  files).     See   also
    llooaadd__ffoorreeiiggnn__lliibbrraarryy//[[11,,22]].

    user:file_search_path(library, X) :-
            library_directory(X).
    user:file_search_path(swi, Home) :-
            feature(home, Home).
    user:file_search_path(foreign, swi(ArchLib)) :-
            feature(arch, Arch),
            concat('lib/', Arch, ArchLib).
    user:file_search_path(foreign, swi(lib)).

    The  ffiillee__sseeaarrcchh__ppaatthh//22expansion is used  by all loading  predicates
    as well as by aabbssoolluuttee__ffiillee__nnaammee//22.


eexxppaanndd__ffiillee__sseeaarrcchh__ppaatthh((+_S_p_e_c_,_ -_P_a_t_h_))
    Unifies  P_a_t_h_  will   all  possible  expansions  of  the  file  name
    specification S_p_e_c_.  See also aabbssoolluuttee__ffiillee__nnaammee//33.


ssoouurrccee__ffiillee((?_F_i_l_e_))
    Succeeds  if  F_i_l_e_ was  loaded using  ccoonnssuulltt//11  or eennssuurree__llooaaddeedd//11.
    F_i_l_e_   refers   to   the  full   path   name   of  the   file   (see
    eexxppaanndd__ffiillee__nnaammee//22).  The predicate ssoouurrccee__ffiillee//11 backtracks over all
    loaded source files.


ssoouurrccee__ffiillee((?_P_r_e_d_,_ ?_F_i_l_e_))
    Is  true if  the predicate specified  by P_r_e_d_  was loaded from  file
    F_i_l_e_,  where F_i_l_e_ is an absolute path  name (see eexxppaanndd__ffiillee__nnaammee//22).
    Can  be used with any  instantiation pattern, but the database  only
    maintains  the source file for each predicate.   Predicates declared
    multifile (see mmuullttiiffiillee//11) cannot be found this way.


pprroolloogg__llooaadd__ccoonntteexxtt((?_K_e_y_,_ ?_V_a_l_u_e_))
    Determine loading context.  The following keys are defined:

      ________________________________________________________________
      |__KKeeyy______________________||DDeessccrriippttiioonn________________________________________________________________________||
      || module        |Module into which file is loaded               |
      | file          |File loaded                                    |
      | stream        |Stream identifier (see ccuurrrreenntt__iinnppuutt//11)        |

      | directory     |Directory in which F_i_l_e_ lives.                 |
      | term_position |Position of last  term read.  Term of  the form|
      |_______________|'$stream_position'(0,<L_i_n_e_>,0,0,0)_____________|

    Quintus compatibility predicate.  See also ssoouurrccee__llooccaattiioonn//22.


ssoouurrccee__llooccaattiioonn((-_F_i_l_e_,_ -_L_i_n_e_))
    If  the last term has been read from a physical file (i.e.  not from
    the file user or  a string), unify F_i_l_e_ with an absolute path to the
    file  and L_i_n_e_ with the  line-number in the file.   New code  should
    use pprroolloogg__llooaadd__ccoonntteexxtt//22.


tteerrmm__eexxppaannssiioonn((+_T_e_r_m_1_,_ -_T_e_r_m_2_))
    Dynamic  predicate, normally not defined.  When defined by  the user
    all  terms read during consulting that are given to  this predicate.
    If  the predicate succeeds Prolog will assert T_e_r_m_2_ in  the database
    rather  then the read term  (T_e_r_m_1_).  T_e_r_m_2_ may  be a term of a  the
    form  `?- G_o_a_l_' or `:- G_o_a_l_'.  G_o_a_l_ is then treated  as a directive.
    If T_e_r_m_2_ is a  list all terms of the list are stored in the database
    or  called (for directives).   If  T_e_r_m_2_ is of  the form below,  the
    system  will assert C_l_a_u_s_e_ and record the  indicated source-location
    with it.

         '$source_location'(<F_i_l_e_>, <L_i_n_e_>):<C_l_a_u_s_e_>

    When compiling a  module (see chapter 4 and the directive mmoodduullee//22),
    eexxppaanndd__tteerrmm//22 will  first try  tteerrmm__eexxppaannssiioonn//22in  the module  being
    compiled  to  allow  for  term-expansion rules  that  are  local  to
    a  module.     If  there  is  no  local  definition,  or  the  local
    definition  fails  to  translate the  term,  eexxppaanndd__tteerrmm//22 will  try
    user:tteerrmm__eexxppaannssiioonn//22.   For compatibility with SICStus and  Quintus
    Prolog, this feature should not be used.  See also eexxppaanndd__tteerrmm//22.


eexxppaanndd__tteerrmm((+_T_e_r_m_1_,_ -_T_e_r_m_2_))
    This  predicate  is  normally  called by  the  compiler  to  perform
    preprocessing.   First it calls tteerrmm__eexxppaannssiioonn//22.   If this predicate
    fails  it performs  a grammar-rule translation.    If this fails  it
    returns the first argument.


aatt__iinniittiiaalliizzaattiioonn((+_G_o_a_l_))
    Register   G_o_a_l_   to   be   ran   when   the   system   initialises.
    Initialisation  takes place after  reloading a .qlf (formerly  .wic)
    file  as well as after reloading a  saved-state.  The hooks  are run
    in  the order they were registered.  A warning message is  issued if
    G_o_a_l_ fails, but execution continues.  See also aatt__hhaalltt//11


aatt__hhaalltt((+_G_o_a_l_))
    Register  G_o_a_l_ to be ran when the  system halts.  The hooks  are run
    in  the order they were registered.  Success or failure  executing a
    hook is ignored.  These hooks may not call hhaalltt//[[00,,11]].


iinniittiiaalliizzaattiioonn((+_G_o_a_l_))
    Call  G_o_a_l_ and  register it  using aatt__iinniittiiaalliizzaattiioonn//11.    Directives
    that  do  other things  that  creating clauses,  records,  flags  or
    setting  predicate attributes should normally be written  using this
    tag  to ensure the  initialisation is executed  when a saved  system
    starts.  See also qqssaavvee__pprrooggrraamm//[[11,,22]].


ccoommppiilliinngg
    Succeeds if the  system is compiling source files with the -c option
    into  an  intermediate code  file.    Can be  used to  perform  code
    optimisations in eexxppaanndd__tteerrmm//22 under this condition.


pprreepprroocceessssoorr((-_O_l_d_,_ +_N_e_w_))
    Read  the input file via a  Unix process that acts as  preprocessor.
    A  preprocessor is specified  as an atom.   The first occurrence  of
    the  string `%f' is replaced by the  name of the file to  be loaded.
    The  resulting atom  is called as  a Unix  command and the  standard
    output  of this command is loaded.   To use the Unix  C preprocessor
    one should define:

    ?- preprocessor(Old, '/lib/cpp -C -P %f'), consult(...).

    Old = none


33..22..11 QQuuiicckk LLooaadd FFiilleess

The features described in this section should be regarded aallpphhaa.

As of  version 2.0.0, SWI-Prolog  supports compilation of individual  or
multiple Prolog  sourcefiles into  `Quick Load  Files'.   A `Quick  Load
Files' (.qlf  file) stores  the contents  of the file  in a  precompiled
format very similar to compiled files created using the  -b and -c flags
(see section 2.7).

These files load  considerably faster than sourcefiles and are  normally
more compact.    They are  machine independent  and may  thus be  loaded
on any  implementation of  SWI-Prolog.   Note however  that clauses  are
stored as virtual  machine instructions.   Changes to the compiler  will
generally make old compiled files unusable.

Quick Load  Files are  created using  qqccoommppiillee//11.   They  may be  loaded
explicitly using  qqllooaadd//11 or implicitly  using ccoonnssuulltt//11  or one of  the
other file-loading predicates described  in section 3.2.  If  consult is
given the  explicit .pl  file, it  will load  the Prolog source.    When
given the .qlf  file, it will  call qqllooaadd//11 to load the  file.  When  no
extension is specified, it will load the .qlf file  when present and the
fileextpl file otherwise.


qqccoommppiillee((+_F_i_l_e_))
    Takes  a  single file  specification  like ccoonnssuulltt//11  (i.e.  accepts
    constructs like library(LibFile)  and creates a Quick Load File from
    F_i_l_e_.   The file-extension of this file  is .qlf.  The base  name of
    the Quick Load File is the same as the input file.

    If   the   file   contains   `:- consult(+File)'   or   `:- [+File]'
    statements,  the  referred files  are compiled  into  the same  .qlf
    file.    Other  directives  will  be stored  in  the .qlf  file  and
    executed in the same fashion as when loading the .pl file.

    For  tteerrmm__eexxppaannssiioonn//22,  the same  rules as described  in section  2.7
    apply.

    Source  references (ssoouurrccee__ffiillee//22)  in the Quick  Load File refer  to
    the Prolog source file from which the compiled code originates.


qqllooaadd((+_F_i_l_e_))
    Loads  the  `Quick  Load  File'.    It  has the  same  semantics  as
    ccoonnssuulltt//11 for a  normal sourcefile.  Equivalent to consult(File) iff
    F_i_l_e_ refers to a `Quick Load File'.


33..33 LLiissttiinngg PPrreeddiiccaatteess aanndd EEddiittoorr IInntteerrffaaccee

SWI-Prolog offers an interface  to the Unix vi editor and the  GNU Emacs
invocations emacs and emacsclient.   Which editor is used  is determined
by the  Unix environment  variable EDITOR,  which should  hold the  full
pathname of the editor.  If this variable is not defined, vi is used.

After  the user  quits  the editor,  mmaakkee//00  is  invoked to  reload  all
modified source files using  ccoonnssuulltt//11.  If the editor can be  quit such
that  an exit  status non-equal  to 0  is returned  mmaakkee//00  will not  be
invoked.  t_o_p_ can do this by typing control-C, v_i_ cannot do this.

A predicate  specification is either  a term with  the same functor  and
arity  as the  predicate wanted,  a term  of the  form F_u_n_c_t_o_r_/A_r_i_t_y_  or
a single  atom.   In  the latter  case the  database is  searched for  a
predicate of  this name  and arbitrary arity  (see ccuurrrreenntt__pprreeddiiccaattee//22).
When  more  than  one such  predicate  exists  the  system  will  prompt
for  confirmation  on  each of  the  matched  predicates.     Predicates
specifications  are  given   to  the  `Do  What  I  Mean'   system  (see
ddwwiimm__pprreeddiiccaattee//22) if the requested predicate does not exist.


eedd((+_P_r_e_d_))
    Invoke  the user's  preferred  editor on  the source  file of  P_r_e_d_,
    providing  a search specification  which searches for the  predicate
    at the start of a line.


eedd
    Invoke eedd//11 on the  predicate last edited using eedd//11.  Asks the user
    to confirm before starting the editor.


eeddiitt((+_F_i_l_e_))
    Invoke  the  user's preferred  editor  on  F_i_l_e_.    F_i_l_e_ is  a  file
    specification  as for ccoonnssuulltt//11  (but not  a list).   Note that  the
    file should exist.


eeddiitt
    Invoke  eeddiitt//11 on the file last edited using eeddiitt//11.  Asks  the user
    to confirm before starting the editor.


lliissttiinngg((+_P_r_e_d_))
    List  specified predicates  (when an  atom is  given all  predicates
    with  this name will  be listed).   The listing  is produced on  the
    basis  of the  internal representation,  thus loosing user's  layout
    and variable name information.  See also ppoorrttrraayy__ccllaauussee//11.


lliissttiinngg
    List all predicates of the database using lliissttiinngg//11.


ppoorrttrraayy__ccllaauussee((+_C_l_a_u_s_e_))
    Pretty  print a  clause  as good  as we  can.   A  clause should  be
    specified  as a  term `<H_e_a_d_> :- <B_o_d_y_>' (put  brackets around it  to
    avoid  operator  precedence problems).    Facts  are represented  as
    `<H_e_a_d_> :- true'.


eeddiitt__ssoouurrccee((+_S_p_e_c_))
    A  hook that may be  defined in the module  user to specify how  the
    predicates  eedd//11 and eeddiitt//11  call the editor.   If eedd//11 is  invoking
    this hook, S_p_e_c_ is a term of the format

         File:LineNo:Name/Arity

    Where  F_i_l_e_  and L_i_n_e_N_o_  represents the  location  of the  predicate
    remembered by Prolog, and  N_a_m_e_ and A_r_i_t_y_ specify the predicate.  If
    invoked by eeddiitt//11, S_p_e_c_  is an atom denoting the name of the file to
    be edited.   This hook is defined by the library library(swi_prolog)
    distributed  with the  XPCE package  for using XPCE  to edit  Prolog
    files.


33..44 VVeerriiffyy TTyyppee ooff aa TTeerrmm


vvaarr((+_T_e_r_m_))
    Succeeds if T_e_r_m_ currently is a free variable.


nnoonnvvaarr((+_T_e_r_m_))
    Succeeds if T_e_r_m_ currently is not a free variable.


iinntteeggeerr((+_T_e_r_m_))
    Succeeds if T_e_r_m_ is bound to an integer.


ffllooaatt((+_T_e_r_m_))
    Succeeds if T_e_r_m_ is bound to a floating point number.


nnuummbbeerr((+_T_e_r_m_))
    Succeeds if T_e_r_m_ is bound to an integer or a floating point number.


aattoomm((+_T_e_r_m_))
    Succeeds if T_e_r_m_ is bound to an atom.


ssttrriinngg((+_T_e_r_m_))
    Succeeds if T_e_r_m_ is bound to a string.


aattoommiicc((+_T_e_r_m_))
    Succeeds  if T_e_r_m_ is bound to  an atom, string, integer or  floating
    point number.


ccoommppoouunndd((+_T_e_r_m_))
    Succeeds  if T_e_r_m_ is bound to a  compound term.  See  also ffuunnccttoorr//33
    and =../2.


ggrroouunndd((+_T_e_r_m_))
    Succeeds if T_e_r_m_ holds no free variables.


33..55 CCoommppaarriissoonn aanndd UUnniiffiiccaattiioonn oorr TTeerrmmss


33..55..11 SSttaannddaarrdd OOrrddeerr ooff TTeerrmmss

Comparison and  unification of arbitrary  terms.   Terms are ordered  in
the so called ``standard order''.  This order is defined as follows:

 1. V_a_r_i_a_b_l_e_s_ <A_t_o_m_s_ <S_t_r_i_n_g_s_ <N_u_m_b_e_r_s_ <T_e_r_m_s_

 2. O_l_d_ V_a_r_i_a_b_l_e_ <N_e_w_ V_a_r_i_a_b_l_e_

 3. A_t_o_m_s_ are compared alphabetically.

 4. S_t_r_i_n_g_s_ are compared alphabetically.

 5. N_u_m_b_e_r_s_  are compared  by value.   Integers  and floats are  treated
    identically.

 6. T_e_r_m_s_  are first checked on their functor (alphabetically),  then on
    their  arity and  finally recursively on  their arguments,  leftmost
    argument first.


+_T_e_r_m_1_ == +_T_e_r_m_2_
    Succeeds  if T_e_r_m_1_  is  equivalent to  T_e_r_m_2_.   A  variable is  only
    identical to a sharing variable.


+_T_e_r_m_1_ \== +_T_e_r_m_2_
    Equivalent to \+Term1 == Term2.


+_T_e_r_m_1_ = +_T_e_r_m_2_
    Unify T_e_r_m_1_ with T_e_r_m_2_.  Succeeds if the unification succeeds.


+_T_e_r_m_1_ \= +_T_e_r_m_2_
    Equivalent to \+Term1 = Term2.


+_T_e_r_m_1_ =@= +_T_e_r_m_2_
    Succeeds  if T_e_r_m_1_  is `structurally  equal' to T_e_r_m_2_.    Structural
    equivalence  is weaker  than equivalence (==//22),  but stronger  than
    unification  (=//22).  Two terms are structurally equal if  their tree
    representation  is identical  and they  have the  same `pattern'  of
    variables.  Examples:

               a  =@=  A       false
               A  =@=  B       true
          x(A,A)  =@=  x(B,C)  false
          x(A,A)  =@=  x(B,B)  true
          x(A,B)  =@=  x(C,D)  true


+_T_e_r_m_1_ \=@= +_T_e_r_m_2_
    Equivalent to `\+Term1 =@= Term2'.


+_T_e_r_m_1_ @< +_T_e_r_m_2_
    Succeeds if T_e_r_m_1_ is before T_e_r_m_2_ in the standard order of terms.


+_T_e_r_m_1_ @=< +_T_e_r_m_2_
    Succeeds if both terms  are equal (==//22) or T_e_r_m_1_ is before T_e_r_m_2_ in
    the standard order of terms.


+_T_e_r_m_1_ @> +_T_e_r_m_2_
    Succeeds if T_e_r_m_1_ is after T_e_r_m_2_ in the standard order of terms.


+_T_e_r_m_1_ @>= +_T_e_r_m_2_
    Succeeds  if both terms are equal (==//22) or T_e_r_m_1_ is after  T_e_r_m_2_ in
    the standard order of terms.


ccoommppaarree((?_O_r_d_e_r_,_ +_T_e_r_m_1_,_ +_T_e_r_m_2_))
    Determine or test  the O_r_d_e_r_ between two terms in the standard order
    of terms.  O_r_d_e_r_ is one of <, >  or =, with the obvious meaning.


33..66 CCoonnttrrooll PPrreeddiiccaatteess

The predicates of  this section implement control structures.   Normally
these constructs  are translated  into virtual  machine instructions  by
the compiler.   It is still  necessary to implement these constructs  as
true predicates  to support meta-calls,  as demonstrated in the  example
below.  The  predicate finds all currently defined atoms of  1 character
long.   Note that  the cut has no  effect when called  via one of  these
predicates (see !/0).

one_character_atoms(As) :-
        findall(A, (current_atom(A), atom_length(A, 1)), As).


ffaaiill
    Always  fail.   The  predicate ffaaiill//00  is translated  into a  single
    virtual machine instruction.


ttrruuee
    Always  succeed.  The predicate  ttrruuee//00 is translated into a  single
    virtual machine instruction.


rreeppeeaatt
    Always succeed, provide an infinite number of choice points.


!
    Cut.    Discard choice  points of  parent frame  and frames  created
    after  the parent  frame.   Note  that the  control structures  ;//22,
    |//22,  ->//22  and \+//11  are normally handled  by the  compiler and  do
    not  create a frame,  which implies the  cut operates through  these
    predicates.   Some  examples are given below.   Note the  difference
    between t3/1 and t4/1.   Also note the effect of ccaallll//11 in t5/0.  As
    the  argument of ccaallll//11 is  evaluated by predicates rather than  the
    compiler the cut has no effect.

       t1 :- (a, !, fail ; b).        % cuts a/0 and t1/0
       t2 :- (a -> b, !  ; c).        % cuts b/0 and t2/0
       t3(G) :- a, G, fail.           % if `G = !'  cuts a/0 and t1/1
       t4(G) :- a, call(G), fail.     % if `G = !'  cut has no effect
       t5 :- call((a, !, fail ; b)).  % Cut has no effect

       t6 :- \+(a, !, fail ; b).      % cuts a/0 and t6/0


+_G_o_a_l_1_ , +_G_o_a_l_2_
    Conjunction.   Succeeds if both  `Goal1' and `Goal2' can be  proved.
    It  is defined as (this  definition does not lead  to a loop as  the
    second comma is handled by the compiler):

    Goal1, Goal2 :- Goal1, Goal2.


+_G_o_a_l_1_ ; +_G_o_a_l_2_
    The `or' predicate is defined as:

    Goal1 ; _Goal2 :- Goal1.
    _Goal1 ; Goal2 :- Goal2.


+_G_o_a_l_1_ | +_G_o_a_l_2_
    Equivalent  to ;//22.    Retained for compatibility  only.   New  code
    should use ;//22.  Still nice though for grammar rules.


+_C_o_n_d_i_t_i_o_n_ -> +_A_c_t_i_o_n_
    If-then  and  If-Then-Else.    The  ->//22  construct commits  to  the
    choices  made  at  its  left-hand  side,   destroying  choice-points
    created  inside the  clause (by  ;//22), or  by goals  called by  this
    clause.   Unlike !//00,  the choicepoint of  the predicate as a  whole
    (due  to multiple clauses)  is nnoott destroyed.   The combination  ;//22
    and ->//22  is defines as:

    If -> Then; _Else :- If, !, Then.
    If -> _Then; Else :- !, Else.
    If -> Then :- If, !, Then.

    Note   that  the   operator  precedence  relation   between  ;   and
    ->   ensure  If -> Then ; Else  is  actually  a  term  of  the  form
    ;(->(If, Then), Else).     The  first  two  clauses  belong  to  the
    definition of ;//22), while only the last defines ->//22 .


+_C_o_n_d_i_t_i_o_n_ *-> +_A_c_t_i_o_n_ ;_ +_E_l_s_e_
    This  construct implements  the so-called `soft-cut'.   The  control
    is  defined as follows:   If C_o_n_d_i_t_i_o_n_ succeeds  at least once,  the
    semantics  is the same  as (C_o_n_d_i_t_i_o_n_, A_c_t_i_o_n_).   If C_o_n_d_i_t_i_o_n_  does
    not  succeed, the semantics is that of (C_o_n_d_i_t_i_o_n_, E_l_s_e_).   In other
    words,  If C_o_n_d_i_t_i_o_n_ succeeds  at least once,  simply behave as  the
    conjunction of C_o_n_d_i_t_i_o_n_ and A_c_t_i_o_n_, otherwise execute E_l_s_e_.


\+ +_G_o_a_l_
    Succeeds  if  `Goal'  cannot  be  proven (mnemonic:    +  refers  to
    p_r_o_v_a_b_l_e_  and  the  backslash  (\)  is  normally  used  to  indicate
    negation).


33..77 MMeettaa--CCaallll PPrreeddiiccaatteess

Meta call  predicates are used  to call terms  constructed at run  time.
The basic meta-call mechanism offered by SWI-Prolog is  to use variables
as a  subclause (which  should of  course be bound  to a  valid goal  at
runtime).   A  meta-call is  slower than a  normal call  as it  involves
actually searching the database at runtime for the  predicate, while for
normal calls this search is done at compile time.


ccaallll((+_G_o_a_l_))
    Invoke  G_o_a_l_ as a  goal.   Note that clauses  may have variables  as
    subclauses,  which is identical to ccaallll//11, except when  the argument
    is bound to the cut.  See !//00.


ccaallll((+_G_o_a_l_,_ +_E_x_t_r_a_A_r_g_1_,_ ._._._))
    Append  E_x_t_r_a_A_r_g_1_,_ E_x_t_r_a_A_r_g_2_,_  ._._._   to  the argument  list of  G_o_a_l_
    and  call the result.   For  example, call(plus(1), 2, X) will  call
    pplluuss//33, binding X_ to 3.

    The call/[2..]   construct is handled by the compiler, which implies
    that  redefinition as  a predicate has  no effect.   The  predicates
    ccaallll//[[22--66]]  are defined as true  predicates, so they can be  handled
    by interpreted code.


aappppllyy((+_T_e_r_m_,_ +_L_i_s_t_))
    Append  the members of  L_i_s_t_ to the arguments  of T_e_r_m_ and call  the
    resulting  term.   For  example:   apply(plus(1), [2, X]) will  call
    plus(1, 2, X).   aappppllyy//22 is  incorporated in the virtual machine  of
    SWI-Prolog.   This implies that the overhead can be compared  to the
    overhead  of ccaallll//11.  New code should use call/[2..]   if the length
    of L_i_s_t_ is  fixed, which is more widely supported and faster because
    there is no need to build and examine the argument list.


nnoott((+_G_o_a_l_))
    Succeeds  when G_o_a_l_ cannot  be proven.   Retained for  compatibility
    only.  New code should use \+//11.


oonnccee((+_G_o_a_l_))
    Defined as:

    once(Goal) :-
            Goal, !.

    oonnccee//11  can  in  many  cases  be replaced  with  ->//22.     The  only
    difference  is how the  cut behaves  (see !/0).   The following  two
    clauses are identical:

    1) a :- once((b, c)), d.
    2) a :- b, c -> d.


iiggnnoorree((+_G_o_a_l_))
    Calls  G_o_a_l_  as oonnccee//11,  but succeeds,  regardless  of whether  G_o_a_l_
    succeeded or not.  Defined as:

    ignore(Goal) :-
            Goal, !.
    ignore(_).


ccaallll__wwiitthh__ddeepptthh__lliimmiitt((+_G_o_a_l_,_ +_L_i_m_i_t_,_ -_R_e_s_u_l_t_))
    If  G_o_a_l_ can be proven  without recursion deeper than L_i_m_i_t_  levels,
    ccaallll__wwiitthh__ddeepptthh__lliimmiitt//33 succeeds,  binding  R_e_s_u_l_t_  to  the  deepest
    recursion  level  used  during the  proof.    Otherwise,  R_e_s_u_l_t_  is
    unified  with depth_limit_exceeded  if the limit was exceeded  during
    the  proof,  or the  entire predicate  fails if  G_o_a_l_ fails  without
    exceeding L_i_m_i_t_.

    The  depth-limit is guarded by the internal machinery.   This differ
    from  the  depth  computed  based  on a  theoretical  model.     For
    example,  ttrruuee//00  is  translated  into an  inlined  virtual  machine
    instruction.   Also, rreeppeeaatt//00 is not implemented as below, but  as a
    non-deterministic foreign predicate.

    repeat.
    repeat :-
            repeat.

    As  a  result,  ccaallll__wwiitthh__ddeepptthh__lliimmiitt//33may still  loop  inifitly  on
    programs  that should  theoretically finish  in finite time.    This
    problem  can be cured by  using Prolog equivalents to such  built-in
    predicates.

    This   predicate  may  be   used  for  theorem-provers  to   realise
    techniques  like i_t_e_r_r_a_t_i_v_e_  d_e_e_p_e_n_i_n_g_.   It  was implemented  after
    discussion with Steve Moyle smoyle@ermine.ox.ac.uk.


33..88 IISSOO ccoommpplliiaanntt EExxcceeppttiioonn hhaannddlliinngg

SWI-Prolog defines the predicates ccaattcchh//33 and tthhrrooww//11  for ISO compliant
raising  and catching  of exceptions.    In  the current  implementation
(2.9.0), only part of  the built-in predicates generate exceptions.   In
general, exceptions are implemented for I/O and arithmetic.


ccaattcchh((:_G_o_a_l_,_ +_C_a_t_c_h_e_r_,_ :_R_e_c_o_v_e_r_))
    Behaves  as ccaallll//11 if  no exception is  raised when executing  G_o_a_l_.
    If  a exception  is raised  using tthhrrooww//11 while  G_o_a_l_ executes,  and
    the  G_o_a_l_ is the innermost goal  for which C_a_t_c_h_e_r_ unifies with  the
    argument  of tthhrrooww//11,  all choicepoints generated  by G_o_a_l_ are  cut,
    and R_e_c_o_v_e_r_ is called as in ccaallll//11.

    The  overhead of calling a  goal through ccaattcchh//33 is very  comparable
    to ccaallll//11.  Recovery from an exception has a similar overhead.


tthhrrooww((+_E_x_c_e_p_t_i_o_n_))
    Raise an exception.   The system will look for the innermost ccaattcchh//33
    ancestor  for which  E_x_c_e_p_t_i_o_n_ unifies with  the C_a_t_h_e_r_ argument  of
    the ccaattcchh//33 call.  See ccaattcchh//33 for details.

    If  there is no  ccaattcchh//33 willing to catch  the error in the  current
    Prolog  context,  the  toplevel  (pprroolloogg//00) catches  the  error  and
    prints  a  warning  message.    If  an  exception was  raised  in  a
    callback  from C  (see chapter 5),  PPLL__nneexxtt__ssoolluuttiioonn(())will fail  and
    the exception context can be retrieved using PPLL__eexxcceeppttiioonn(()).


33..88..11 DDeebbuuggggiinngg aanndd eexxcceeppttiioonnss

Before the introduction of exceptions in SWI-Prolog a  runtime error was
handled by printing an error message, after which  the predicate failed.
If the feature  (see ffeeaattuurree//22) debug_on_error was in effect  (default),
the tracer was  switched on.  The  combination of the error message  and
trace information is generally sufficient to locate the error.

With exception handling,  things are different.   A programmer may  wish
to trap an  exception using ccaattcchh//33 to avoid  it reaching the user.   If
the  exception is  not handled  by user-code,  the interactive  toplevel
will trap it to prevent termination.

If  we  do  not  take  special  precautions,   the  context  information
associated with  an unexpected exception (i.e.  a programming error)  is
lost.  Therefore,  if an exception is raised, which is not  caught using
ccaattcchh//33 and the toplevel is running, the error will  be printed, and the
system will enter trace mode.

If the system  is in an non-interactive  callback from foreign code  and
there is no ccaattcchh//33  active in the current context, it  cannot determine
whether or  not the  exception will  be caught by  the external  routine
calling  Prolog.    It  will then  base  its  behaviour on  the  feature
debug_on_error:

  o f_e_a_t_u_r_e_(_d_e_b_u_g___o_n___e_r_r_o_r_,_ f_a_l_s_e_)_
    The  exception does  not trap the  debugger and  is returned to  the
    foreign  routine  calling Prolog,  where it  can  be accessed  using
    PPLL__eexxcceeppttiioonn(()).  This is the default.

  o f_e_a_t_u_r_e_(_d_e_b_u_g___o_n___e_r_r_o_r_,_ t_r_u_e_)_
    If the exception is  not caught by Prolog in the current context, it
    will trap the tracer to help analysing the context of the error.

While looking for the  context in which an exception takes place,  it is
adviced to switch on debug mode using the predicate ddeebbuugg//00.


33..88..22 TThhee eexxcceeppttiioonn tteerrmm

Builtin predicates generates exceptions using a term error(e_r_r_o_r_).   The
first argument is the `formal' description of the  error, specifying the
class and  generic defined context  information.   When applicable,  the
ISO  error-term definition  is used.    The second  part describes  some
additional  context to  help the  programmer while  debugging.   In  its
most generic  form this is  a term of  the form context(c_o_n_t_e_x_t_),  where
N_a_m_e_/A_r_i_t_y_ describes the  built-in predicate that raised the error,  and
M_e_s_s_a_g_e_ provides an  additional description of the  error.  Any part  of
this structure may be a variable if no information was present.


33..88..33 PPrriinnttiinngg aa mmeessssaaggee ffrroomm aann eexxcceeppttiioonn

The predicate pprriinntt__mmeessssaaggee//22 may be used to print an exception  term in
a human readable format:


pprriinntt__mmeessssaaggee((T_))
    his  predicate  is modelled  after the  Quintus  predicate with  the
    same  name, though  its current  implementation is incomplete.    It
    is  used only  for printing messages  from exceptions from  built-in
    predicates.    K_i_n_d_ is  one of  informational, warning,  consterror,
    help  or silent.    Currently only  error is defined.    T_e_r_m_ is  an
    eerrrroorr((2_)) term described  in section 3.8.2.  A human-readable message
    is printed to the stream user_error.

    The  pprriinntt__mmeessssaaggee//22  predicate  and  its  rules  are  in  the  file
    <p_l_h_o_m_e_>/boot/messages.pl,   which  may   be   inspected  for   more
    information on the error messages and related error terms.


33..99 AAddvvaanncceedd ccoonnttrrooll--ssttrruuccttuurreess::  bblloocckkss

The predicates of this section form a tightly related  set for realising
premature successful or  failing exits from a  b_l_o_c_k_.  These  predicates
are  first of  all  useful for  error-recovery.    They  were  primarily
implemented for compatibility reasons.


bblloocckk((+_L_a_b_e_l_,_ +_G_o_a_l_,_ -_E_x_i_t_V_a_l_u_e_))
    Execute  G_o_a_l_ in a b_l_o_c_k_.   L_a_b_e_l_ is the name  of the block.   L_a_b_e_l_
    is  normally an  atom, but  the system imposes  no type  constraints
    and  may even be a variable.   E_x_i_t_V_a_l_u_e_ is normally unified  to the
    second argument of an eexxiitt//22 call invoked by G_o_a_l_.


eexxiitt((+_L_a_b_e_l_,_ +_V_a_l_u_e_))
    Calling  eexxiitt//22 makes the innermost b_l_o_c_k_ which L_a_b_e_l_  unifies exit.
    The  block's E_x_i_t_V_a_l_u_e_ is unified with  V_a_l_u_e_.  If this  unification
    fails the block fails.


ffaaiill((+_L_a_b_e_l_))
    Calling  ffaaiill//11 makes the innermost  b_l_o_c_k_ which L_a_b_e_l_ unifies  fail
    immediately.  Implemented as

    fail(Label) :- !(Label), fail.


!((+_L_a_b_e_l_))
    Cut  all  choice-points created  since the  entry  of the  innermost
    b_l_o_c_k_ which L_a_b_e_l_ unifies.

The example  below illustrate these constructs  to immediately report  a
syntax-error from a  `deep-down' procedure to the outside world  without
passing it as an argument `all-over-the-place'.

parse(RuleSet, InputList, Rest) :-
        block(syntaxerror, phrase(RuleSet, InputList, Rest), Error),
        (   var(Error)
        ->  true
        ;   format('Syntax-error: ~w~n', Error),
            fail
        ).

integer(N) -->
        digit(D1), !, digits(Ds),
        { name(N, [D1|Ds]) }.

digits([D|R]) --> digit(D), digits(R).
digits(_) --> letter(_), !, { exit(syntaxerror, 'Illegal number') }.
digits([]) --> [].

digit(D, [D|R], R)  :- between(0'0, 0'9, D).
letter(D, [D|R], R) :- between(0'a, 0'z, D).


33..1100 GGrraammmmaarr rruullee iinntteerrffaaccee ((pphhrraassee))

The predicates below may be called to activate a grammar-rule set:


pphhrraassee((+_R_u_l_e_S_e_t_,_ +_I_n_p_u_t_L_i_s_t_))
    Equivalent to phrase(RuleSet, InputList, []).


pphhrraassee((+_R_u_l_e_S_e_t_,_ +_I_n_p_u_t_L_i_s_t_,_ -_R_e_s_t_))
    Activate  the rule-set with given name.  `InputList' is the  list of
    tokens to parse,  `Rest' is unified with the remaining tokens if the
    sentence is parsed correctly.


33..1111 DDaattaabbaassee

SWI-Prolog offers  three different database mechanisms.   The first  one
is  the common  assert/retract  mechanism  for manipulating  the  clause
database.    As facts  and clauses  asserted using  aasssseerrtt//11  or one  of
its  derivatives become  part of  the program  these predicates  compile
the term  given to them.    rreettrraacctt//11 and rreettrraaccttaallll//11  have to unify  a
term and  therefore have to  decompile the program.   For these  reasons
the assert/retract  mechanism is  expensive.   On the  other hand,  once
compiled, queries to the database are faster than  querying the recorded
database discussed below.  See also ddyynnaammiicc//11.

The second way of  storing arbitrary terms in the database is  using the
``recorded database''.   In  this database terms  are associated with  a
k_e_y_.  A key can be an atom, integer or term.   In the last case only the
functor and  arity determine the  key.   Each key has  a chain of  terms
associated with it.   New terms  can be added either  at the head or  at
the tail  of this  chain.   This mechanism  is considerably faster  than
the assert/retract mechanism as terms are not compiled,  but just copied
into the heap.

The third mechanism is a special purpose one.   It associates an integer
or atom  with a  key,  which is  an atom,  integer or  term.   Each  key
can only  have one  atom or integer  associated with  it.   It again  is
considerably faster  than the mechanisms described  above, but can  only
be used to store simple status information like counters, etc.


aabboolliisshh((:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_))
    Removes  all clauses of a  predicate with functor F_u_n_c_t_o_r_ and  arity
    A_r_i_t_y_  from  the  database.    Unlike  version  1.2,  all  predicate
    attributes  (dynamic, multifile, index,  etc.)   are reset to  their
    defaults.   Abolishing an imported predicate only removes the import
    link;  the predicate will keep its old definition in  its definition
    module.    For `cleanup'  of the  dynamic database,  one should  use
    rreettrraaccttaallll//11 rather than aabboolliisshh//22.


aabboolliisshh((+_N_a_m_e_,_ +_A_r_i_t_y_))
    Same  as abolish(Name/Arity).   The predicate aabboolliisshh//22 conforms  to
    the Edinburgh standard, while aabboolliisshh//11 is ISO compliant.


rreeddeeffiinnee__ssyysstteemm__pprreeddiiccaattee((+_H_e_a_d_))
    This  directive  may be  used  both in  module  user and  in  normal
    modules to redefine  any system predicate.  If the system definition
    is  redefined in  module user,  the  new definition  is the  default
    definition  for  all sub-modules.    Otherwise  the redefinition  is
    local  to the module.   The system definition remains in the  module
    system.

    Redefining   system   predicate   facilitates  the   definition   of
    compatibility packages.  Use in other context is discouraged.


rreettrraacctt((+_T_e_r_m_))
    When  T_e_r_m_  is an  atom  or a  term  it is  unified with  the  first
    unifying  fact or clause  in the database.   The  fact or clause  is
    removed from the database.


rreettrraaccttaallll((+_H_e_a_d_))
    All  facts or  clauses in the  database for  which the h_e_a_d_  unifies
    with H_e_a_d_ are removed.


aasssseerrtt((+_T_e_r_m_))
    Assert  a fact or clause in the  database.  T_e_r_m_ is asserted  as the
    last fact or clause of the corresponding predicate.


aasssseerrttaa((+_T_e_r_m_))
    Equivalent  to aasssseerrtt//11,  but T_e_r_m_  is asserted as  first clause  or
    fact of the predicate.


aasssseerrttzz((+_T_e_r_m_))
    Equivalent to aasssseerrtt//11.


aasssseerrtt((+_T_e_r_m_,_ -_R_e_f_e_r_e_n_c_e_))
    Equivalent  to  aasssseerrtt//11, but  R_e_f_e_r_e_n_c_e_ is  unified  with a  unique
    reference  to the asserted clause.  This key can later be  used with
    ccllaauussee//33 or eerraassee//11.


aasssseerrttaa((+_T_e_r_m_,_ -_R_e_f_e_r_e_n_c_e_))
    Equivalent  to aasssseerrtt//22,  but T_e_r_m_  is asserted as  first clause  or
    fact of the predicate.


aasssseerrttzz((+_T_e_r_m_,_ -_R_e_f_e_r_e_n_c_e_))
    Equivalent to aasssseerrtt//22.


rreeccoorrddaa((+_K_e_y_,_ +_T_e_r_m_,_ -_R_e_f_e_r_e_n_c_e_))
    Assert  T_e_r_m_  in the  recorded  database  under key  K_e_y_.    K_e_y_  is
    an  integer,  atom or  term.   R_e_f_e_r_e_n_c_e_  is unified  with a  unique
    reference to the record (see eerraassee//11).


rreeccoorrddaa((+_K_e_y_,_ +_T_e_r_m_))
    Equivalent to recorda(Key, Value,  _).


rreeccoorrddzz((+_K_e_y_,_ +_T_e_r_m_,_ -_R_e_f_e_r_e_n_c_e_))
    Equivalent to rreeccoorrddaa//33, but  puts the T_e_r_m_ at the tail of the terms
    recorded under K_e_y_.


rreeccoorrddzz((+_K_e_y_,_ +_T_e_r_m_))
    Equivalent to recordz(Key, Value,  _).


rreeccoorrddeedd((+_K_e_y_,_ -_V_a_l_u_e_,_ -_R_e_f_e_r_e_n_c_e_))
    Unify  V_a_l_u_e_  with the  first  term recorded  under K_e_y_  which  does
    unify.    R_e_f_e_r_e_n_c_e_  is  unified with  the  memory location  of  the
    record.


rreeccoorrddeedd((+_K_e_y_,_ -_V_a_l_u_e_))
    Equivalent to recorded(Key, Value,  _).


eerraassee((+_R_e_f_e_r_e_n_c_e_))
    Erase  a  record or  clause from  the  database.   R_e_f_e_r_e_n_c_e_  is  an
    integer  returned by  rreeccoorrddaa//33 or  rreeccoorrddeedd//33, ccllaauussee//33,  aasssseerrtt//22,
    aasssseerrttaa//22  or aasssseerrttzz//22.    Other integers might  conflict with  the
    internal  consistency of the system.  Erase can only be  called once
    on  a record or clause.  A second call also might  conflict with the
    internal consistency of the system.


ffllaagg((+_K_e_y_,_ -_O_l_d_,_ +_N_e_w_))
    K_e_y_  is an  atom, integer or  term.   Unify O_l_d_  with the old  value
    associated  with K_e_y_.  If the key is used for the first  time O_l_d_ is
    unified  with the integer  0.   Then store the  value of N_e_w_,  which
    should  be an integer, float,  atom or arithmetic expression,  under
    K_e_y_.   ffllaagg//33 is a very  fast mechanism for storing simple  facts in
    the database.  Example:

    :- module_transparent succeeds_n_times/2.

    succeeds_n_times(Goal, Times) :-
            flag(succeeds_n_times, Old, 0),
            Goal,
            flag(succeeds_n_times, N, N+1),
            fail ; flag(succeeds_n_times, Times, Old).


33..1111..11 IInnddeexxiinngg ddaattaabbaasseess

By  default,   SWI-Prolog,  as   most  other  implementations,   indexes
predicates  on their  first argument.    SWI-Prolog  allows indexing  on
other and multiple arguments using the declaration iinnddeexx//11.

For advanced database indexing, it defines hhaasshh__tteerrmm//22:


hhaasshh__tteerrmm((+_T_e_r_m_,_ -_H_a_s_h_K_e_y_))
    If  T_e_r_m_ is a ground term (see ggrroouunndd//11), H_a_s_h_K_e_y_ is unified  with a
    positive integer value that  may be used as a hash-key to the value.
    If  T_e_r_m_ is not ground, the predicate succeeds  immediately, leaving
    H_a_s_h_K_e_y_ an unbound variable.

    This  predicate  may be  used to  build hash-tables  as  well as  to
    exploit argument-indexing to find complex terms more quickly.

    The  hash-key does not rely on temporary information  like addresses
    of  atoms and may be assumed constant over different  invocations of
    SWI-Prolog.


33..1122 DDeeccllaarriinngg PPrrooppeerrttiieess ooff PPrreeddiiccaatteess

This  section  describes  directives  which  manipulate   attributes  of
predicate  definitions.     The  functors  ddyynnaammiicc//11,   mmuullttiiffiillee//11  and
ddiissccoonnttiigguuoouuss//11  are  operators  of  priority  1150  (see  oopp//33),  which
implies  the  list of  predicates  they  involve  can just  be  a  comma
separated list:

:- dynamic
        foo/0,
        baz/2.

On SWI-Prolog all  these directives are just  predicates.  This  implies
they can also  be called by a program.   Do not rely on this  feature if
you want to maintain portability to other Prolog implementations.


ddyynnaammiicc +_F_u_n_c_t_o_r_/_+_A_r_i_t_y_,_ ._._._
    Informs  the interpreter  that  the definition  of the  predicate(s)
    may  change  during  execution (using  aasssseerrtt//11  and/or  rreettrraacctt//11).
    Currently  ddyynnaammiicc//11  only stops  the interpreter  from  complaining
    about  undefined  predicates  (see  uunnkknnoowwnn//22).     Future  releases
    might  prohibit  aasssseerrtt//11  and rreettrraacctt//11  for  not-dynamic  declared
    procedures.


mmuullttiiffiillee +_F_u_n_c_t_o_r_/_+_A_r_i_t_y_,_ ._._._
    Informs  the system that the  specified predicate(s) may be  defined
    over  more than one  file.  This  stops ccoonnssuulltt//11 from redefining  a
    predicate when a new definition is found.


ddiissccoonnttiigguuoouuss +_F_u_n_c_t_o_r_/_+_A_r_i_t_y_,_ ._._._
    Informs  the system that the  clauses of the specified  predicate(s)
    might not be together in the source file.  See also ssttyyllee__cchheecckk//11.


iinnddeexx((+_H_e_a_d_))
    Index  the clauses  of the predicate  with the  same name and  arity
    as  H_e_a_d_  on the  specified arguments.    H_e_a_d_ is  a  term of  which
    all  arguments  are  either  `1' (denoting  `index  this  argument')
    or  `0'  (denoting `do  not index  this argument').    Indexing  has
    no  implications  for the  semantics of  a  predicate, only  on  its
    performance.    If  indexing is  enabled on  a  predicate a  special
    purpose  algorithm  is used  to select  candidate  clauses based  on
    the  actual arguments of  the goal.   This algorithm checks  whether
    indexed  arguments might  unify in  the clause  head.   Only  atoms,
    integers  and  functors   (e.g.  name  and  arity  of  a  term)  are
    considered.    Indexing  is  very useful  for predicates  with  many
    clauses representing facts.

    Due to the  representation technique used at most 4 arguments can be
    indexed.  All  indexed arguments should be in the first 32 arguments
    of  the predicate.    If  more than  4 arguments  are specified  for
    indexing only the first  4 will be accepted.  Arguments above 32 are
    ignored for indexing.

    By  default  all predicates  with <a_r_i_t_y_> 1  are indexed  on their
    first  argument.  It is possible to redefine indexing  on predicates
    that  already have clauses attached to  them.  This will initiate  a
    scan through the  predicates clause list to update the index summary
    information stored with each clause.

    If---for  example---one wants to  represents sub-types using a  fact
    list  `sub_type(Sub, Super)' that should be  used both to  determine
    sub- and super types one should declare sub_type/2 as follows:

    :- index(sub_type(1, 1)).

    sub_type(horse, animal).
    ...
    ...


33..1133 EExxaammiinniinngg tthhee PPrrooggrraamm


ccuurrrreenntt__aattoomm((-_A_t_o_m_))
    Successively unifies A_t_o_m_ with  all atoms known to the system.  Note
    that  ccuurrrreenntt__aattoomm//11always  succeeds if A_t_o_m_  is instantiated to  an
    atom.


ccuurrrreenntt__ffuunnccttoorr((?_N_a_m_e_,_ ?_A_r_i_t_y_))
    Successively unifies N_a_m_e_  with the name and A_r_i_t_y_ with the arity of
    functors known to the system.


ccuurrrreenntt__ffllaagg((-_F_l_a_g_K_e_y_))
    Successively  unifies  F_l_a_g_K_e_y_ with  all keys  used  for flags  (see
    ffllaagg//33).


ccuurrrreenntt__kkeeyy((-_K_e_y_))
    Successively  unifies  K_e_y_  with  all keys  used  for  records  (see
    rreeccoorrddaa//33, etc.).


ccuurrrreenntt__pprreeddiiccaattee((?_N_a_m_e_,_ ?_H_e_a_d_))
    Successively  unifies N_a_m_e_  with  the name  of predicates  currently
    defined and H_e_a_d_ with  the most general term built from N_a_m_e_ and the
    arity of the  predicate.  This predicate succeeds for all predicates
    defined  in the specified module, imported  to it, or in one  of the
    modules from which the predicate will be imported if it is called.


pprreeddiiccaattee__pprrooppeerrttyy((?_H_e_a_d_,_ ?_P_r_o_p_e_r_t_y_))
    Succeeds  if H_e_a_d_ refers to a predicate that has  property P_r_o_p_e_r_t_y_.
    Can  be used  to test whether  a predicate  has a certain  property,
    obtain  all properties known  for H_e_a_d_,  find all predicates  having
    p_r_o_p_e_r_t_y_  or  even obtaining  all  information available  about  the
    current program.  P_r_o_p_e_r_t_y_ is one of:

    iinntteerrpprreetteedd
         Is true if the predicate is defined in Prolog.   We return true
         on this because, although the code is actually  compiled, it is
         completely transparent, just like interpreted code.

    bbuuiilltt__iinn
         Is true  if the predicate  is locked  as a built-in  predicate.
         This implies it  cannot be redefined  in its definition  module
         and it can normally not be seen in the tracer.

    ffoorreeiiggnn
         Is true if the predicate is defined in the C language.

    ddyynnaammiicc
         Is  true  if  the  predicate  is  declared  dynamic  using  the
         ddyynnaammiicc//11 declaration.

    mmuullttiiffiillee
         Is  true if  the  predicate  is declared  multifile  using  the
         mmuullttiiffiillee//11 declaration.

    uunnddeeffiinneedd
         Is  true if  a procedure  definition  block for  the  predicate
         exists, but there are no  clauses in it and it is  not declared
         dynamic.   This is  true if  the predicate occurs  in the  body
         of a  loaded predicate,  an attempt  to call it  has been  made
         via one  of the  meta-call predicates  or the  predicate had  a
         definition in  the past.   See  the library  package c_h_e_c_k_  for
         example usage.

    ttrraannssppaarreenntt
         Is true  if the  predicate  is declared  transparent using  the
         mmoodduullee__ttrraannssppaarreenntt//11declaration.

    eexxppoorrtteedd
         Is true if the predicate  is in the public list of  the context
         module.

    iimmppoorrtteedd__ffrroomm((M_o_d_u_l_e_))
         Is true if  the predicate is  imported into the context  module
         from module M_o_d_u_l_e_.

    iinnddeexxeedd((H_e_a_d_))
         Predicate is indexed (see iinnddeexx//11) according to H_e_a_d_.   H_e_a_d_ is
         a term  whose name and  arity are  identical to the  predicate.
         The arguments are unified  with `1' for indexed arguments,  `0'
         otherwise.

    ffiillee((F_i_l_e_N_a_m_e_))
         Unify F_i_l_e_N_a_m_e_  with the name  of the  sourcefile in which  the
         predicate is defined.  See also ssoouurrccee__ffiillee//22.

    lliinnee__ccoouunntt((L_i_n_e_N_u_m_b_e_r_))
         Unify L_i_n_e_N_u_m_b_e_r_ with  the line number  of the first clause  of
         the predicate.   Fails if the predicate is not  associated with
         a file.  See also ssoouurrccee__ffiillee//22.

    nnuummbbeerr__ooff__ccllaauusseess((C_l_a_u_s_e_C_o_u_n_t_))
         Unify C_l_a_u_s_e_C_o_u_n_t_ to the number of clauses  associated with the
         predicate.  Fails for foreign predicates.


ddwwiimm__pprreeddiiccaattee((+_T_e_r_m_,_ -_D_w_i_m_))
    `Do What I Mean'  (`dwim') support predicate.  T_e_r_m_ is a term, which
    name  and arity  are used  as a predicate  specification.   D_w_i_m_  is
    instantiated  with the  most general  term built from  N_a_m_e_ and  the
    arity  of a defined predicate  that matches the predicate  specified
    by  T_e_r_m_ in the  `Do What I Mean'  sense.  See  ddwwiimm__mmaattcchh//22for  `Do
    What  I Mean' string matching.   Internal system predicates are  not
    generated,  unless  style_check(+dollar) is  active.    Backtracking
    provides all alternative matches.


ccllaauussee((?_H_e_a_d_,_ ?_B_o_d_y_))
    Succeeds  when  H_e_a_d_ can  be unified  with a  clause  head and  B_o_d_y_
    with  the  corresponding clause  body.    Gives alternative  clauses
    on  backtracking.     For  facts  B_o_d_y_  is  unified  with  the  atom
    t_r_u_e_.   Normally ccllaauussee//22 is  used to find clause definitions for  a
    predicate,  but it can  also be used to  find clause heads for  some
    body template.


ccllaauussee((?_H_e_a_d_,_ ?_B_o_d_y_,_ ?_R_e_f_e_r_e_n_c_e_))
    Equivalent  to  ccllaauussee//22,   but  unifies  R_e_f_e_r_e_n_c_e_  with  a  unique
    reference to the  clause (see also aasssseerrtt//22, eerraassee//11).  If R_e_f_e_r_e_n_c_e_
    is  instantiated to a reference the  clause's head and body will  be
    unified with  H_e_a_d_ and B_o_d_y_.


nntthh__ccllaauussee((?_P_r_e_d_,_ ?_I_n_d_e_x_,_ ?_R_e_f_e_r_e_n_c_e_))
    Provides  access to  the clauses  of a predicate  using their  index
    number.    Counting  starts at  1.   If  R_e_f_e_r_e_n_c_e_  is specified  it
    unifies  P_r_e_d_ with the  most general term  with the same  name/arity
    as  the predicate  and I_n_d_e_x_  with the index-number  of the  clause.
    Otherwise  the name  and arity  of P_r_e_d_  are used  to determine  the
    predicate.    If I_n_d_e_x_ is  provided R_e_f_e_r_e_n_c_e_  will be unified  with
    the  clause  reference.   If  I_n_d_e_x_  is unbound,  backtracking  will
    yield  both the  indices and the  references of  all clauses of  the
    predicate.  The following example finds the 2nd clause of mmeemmbbeerr//22:

    ?- nth_clause(member(_,_), 2, Ref), clause(Head, Body, Ref).

    Ref = 160088
    Head = system : member(G575, [G578|G579])
    Body = member(G575, G579)


ccllaauussee__pprrooppeerrttyy((+_C_l_a_u_s_e_R_e_f_,_ -_P_r_o_p_e_r_t_y_))
    Queries  properties  of   a  clause.     C_l_a_u_s_e_R_e_f_  is  a  reference
    to   a   clause   as   produced   by   ccllaauussee//33,   nntthh__ccllaauussee//33   or
    pprroolloogg__ffrraammee__aattttrriibbuuttee//33.  P_r_o_p_e_r_t_y_ is one of the following:

    ffiillee((F_i_l_e_N_a_m_e_))
         Unify F_i_l_e_N_a_m_e_  with the name  of the  sourcefile in which  the
         clause is defined.  Fails if the clause is not  associated to a
         file.

    lliinnee__ccoouunntt((L_i_n_e_N_u_m_b_e_r_))
         Unify L_i_n_e_N_u_m_b_e_r_ with the line number of the clause.   Fails if
         the clause is not associated to a file.

    ffaacctt
         True if the clause has no body.

    eerraasseedd
         True if  the  clause has  been erased,  but  not yet  reclaimed
         because it is referenced.


33..1144 IInnppuutt aanndd OOuuttppuutt

SWI-Prolog provides two  different packages for input  and output.   One
confirms  to  the  Edinburgh  standard.    This  package  has  a  notion
of  `current-input' and  `current-output'.    The  reading  and  writing
predicates implicitly refer  to these streams.   In the second  package,
streams are  opened explicitly and  the resulting handle  is used as  an
argument to the reading  and writing predicate to specify the  source or
destination.   Both packages are fully  integrated; the user may  switch
freely between them.


33..1144..11 IInnppuutt aanndd OOuuttppuutt UUssiinngg IImmpplliicciitt SSoouurrccee aanndd DDeessttiinnaattiioonn

The  package  for  implicit input  and  output  destination  is  upwards
compatible to DEC-10 and  C-Prolog.  The reading and  writing predicates
refer to resp.   the current input- and output stream.   Initially these
streams are  connected to the  terminal.  The  current output stream  is
changed using tteellll//11 or  aappppeenndd//11.  The current input stream  is changed
using sseeee//11.  The streams current value can  be obtained using tteelllliinngg//11
for output- and sseeeeiinngg//11  for input streams.  The table below  shows the
valid stream specifications.  The reserved names user_input, user_output
and user_error are for neat integration with the explicit streams.

           ___________________________________________________
           | user        |This reserved  name  refers to  the|
           |             |terminal                           |
           | user_input  |Input from the terminal            |

           | user_output |Output to the terminal             |
           | user_error  |Unix error stream (output only)    |
           | <A_t_o_m_>      |Name of a Unix file                |
           |_pipe(<A_t_o_m_>_|Name_of_a_Unix_command_____________|_

Source and  destination are  either a file,  one of  the reserved  words
above, or a term  `pipe(C_o_m_m_a_n_d_)'.  In the predicate  descriptions below
we will call the source/destination argument `S_r_c_D_e_s_t_'.   Below are some
examples of source/destination specifications.

       ?- see(data).        % Start reading from file `data'.
       ?- tell(stderr).     % Start writing on the error stream.

       ?- tell(pipe(lpr)).  % Start writing to the printer.

Another example  of using  the ppiippee//11 construct  is shown  below.   Note
that  the  ppiippee//11  construct  is  not  part  of  Prolog's  standard  I/O
repertoire.

getwd(Wd) :-
        seeing(Old), see(pipe(pwd)),
        collect_wd(String),
        seen, see(Old),
        atom_chars(Wd, String).

collect_wd([C|R]) :-
        get0(C), C \== -1, !,
        collect_wd(R).
collect_wd([]).


sseeee((+_S_r_c_D_e_s_t_))
    Make  S_r_c_D_e_s_t_ the  current input  stream.   If  S_r_c_D_e_s_t_ was  already
    opened  for  reading  with sseeee//11  and  has  not been  closed  since,
    reading  will be resumed.  Otherwise S_r_c_D_e_s_t_ will be opened  and the
    file pointer is positioned at the start of the file.


tteellll((+_S_r_c_D_e_s_t_))
    Make  S_r_c_D_e_s_t_ the  current output stream.    If S_r_c_D_e_s_t_ was  already
    opened  for writing with tteellll//11 or aappppeenndd//11 and has not  been closed
    since,  writing will  be resumed.    Otherwise the  file is  created
    or---when existing---truncated.  See also aappppeenndd//11.


aappppeenndd((+_F_i_l_e_))
    Similar  to tteellll//11,  but positions the  file pointer  at the end  of
    F_i_l_e_  rather than truncating an existing  file.  The pipe  construct
    is not accepted by this predicate.


sseeeeiinngg((?_S_r_c_D_e_s_t_))
    Unify the name of the current input stream with S_r_c_D_e_s_t_.


tteelllliinngg((?_S_r_c_D_e_s_t_))
    Unify the name of the current output stream with S_r_c_D_e_s_t_.


sseeeenn
    Close the current input stream.  The new input stream becomes u_s_e_r_.


ttoolldd
    Close  the current  output stream.   The  new output stream  becomes
    u_s_e_r_.


33..1144..22 EExxpplliicciitt IInnppuutt aanndd OOuuttppuutt SSttrreeaammss

The predicates  below are  part of the  Quintus compatible  stream-based
I/O package.   In this package streams are explicitly created  using the
predicate ooppeenn//33.   The resulting stream identifier is then passed  as a
parameter to  the reading and writing  predicates to specify the  source
or destination of the data.


ooppeenn((+_S_r_c_D_e_s_t_,_ +_M_o_d_e_,_ -_S_t_r_e_a_m_,_ +_O_p_t_i_o_n_s_))
    ISO  compliant predicate  to open  a stream.   S_r_c_D_e_s_  is either  an
    atom,  specifying  a  Unix file,  or  a term  `pipe(Command)',  just
    like  sseeee//11 and  tteellll//11.   M_o_d_e_  is one  of read,  write, append  or
    update.   Mode  append opens the file  for writing, positioning  the
    file-pointer  at the end.   Mode update opens the file for  writing,
    positioning  the file-pointer at the  beginning of the file  without
    truncating  the file.  See also ssttrreeaamm__ppoossiittiioonn//33.   S_t_r_e_a_m_ is either
    a variable, in which  case it is bound to an integer identifying the
    stream,  or an  atom, in  which case  this atom will  be the  stream
    identifier.  The O_p_t_i_o_n_s_ list can contain the following options:

    ttyyppee((T_y_p_e_))
         Using type text (default), Prolog will write a  text-file in an
         operating-system compatible way.   Using type binary the  bytes
         will be read  or written without any  translation.  Note  there
         is no difference between the two on Unix systems.

    aalliiaass((A_t_o_m_))
         Gives  the  stream  a name.     The  following  two  calls  are
         identical, but only the latter is allowed in ISO Prolog.

         ?- open(foo, read, in, []).
         ?- open(foo, read, S, [alias(in)]).

    eeooff__aaccttiioonn((A_c_t_i_o_n_))
         Defines  what  happens  if the  end  of  the  input  stream  is
         reached.   Action eof_code makes ggeett00//11  and friends return  -1
         and rreeaadd//11 and friends return the atom end_of_file.  Repetitive
         reading keeps yielding the  same result.  Action error  is like
         eof_code, but repetitive  reading will  raise an error.    With
         action reset,  Prolog will  examine the file  again and  return
         more data if the file has grown.

    The  option reposition is not supported in SWI-Prolog.   All streams
    connected to a file may be repositioned.


ooppeenn((+_S_r_c_D_e_s_t_,_ +_M_o_d_e_,_ ?_S_t_r_e_a_m_))
    Equivalent to ooppeenn//44 with an empty option-list.


ooppeenn__nnuullll__ssttrreeaamm((?_S_t_r_e_a_m_))
    Open  a stream that produces no output.  All counting  functions are
    enabled  on such a stream.   An attempt  to read from a  null-stream
    will immediately signal end-of-file.  Similar to Unix /dev/null.


cclloossee((+_S_t_r_e_a_m_))

    Close the specified stream.   If S_t_r_e_a_m_ is not open an error message
    is  displayed.  If the closed stream is the current input  or output
    stream the terminal is made the current input or output.


ccuurrrreenntt__ssttrreeaamm((?_F_i_l_e_,_ ?_M_o_d_e_,_ ?_S_t_r_e_a_m_))
    Is  true if  a stream with  file specification F_i_l_e_,  mode M_o_d_e_  and
    stream  identifier S_t_r_e_a_m_ is  open.   The reserved streams user  and
    user_error are  not generated by  this predicate.   If a stream  has
    been  opened  with mode  append this  predicate  will generate  mode
    write.


ssttrreeaamm__ppoossiittiioonn((+_S_t_r_e_a_m_,_ -_O_l_d_,_ +_N_e_w_))
    Unify  the position parameters  of S_t_r_e_a_m_ with  O_l_d_ and set them  to
    N_e_w_.  A position is represented by the following term:

    '$stream_position'(CharNo, LineNo, LinePos).

    It is only  possible to change the position parameters if the stream
    is  connected to  a disk  file.   If  the position  is changed,  the
    C_h_a_r_N_o_  field determines the new position  in the file.  The  L_i_n_e_N_o_
    and L_i_n_e_P_o_s_ are copied in the stream administration.


33..1144..33 SSwwiittcchhiinngg BBeettwweeeenn IImmpplliicciitt aanndd EExxpplliicciitt II//OO

The predicates  below can be  used for  switching between the  implicit-
and the explicit stream based I/O predicates.


sseett__iinnppuutt((+_S_t_r_e_a_m_))
    Set  the current input  stream to become S_t_r_e_a_m_.   Thus,  open(file,
    read, Stream), set_input(Stream) is equivalent to see(file).


sseett__oouuttppuutt((+_S_t_r_e_a_m_))
    Set the current output stream to become S_t_r_e_a_m_.


ccuurrrreenntt__iinnppuutt((-_S_t_r_e_a_m_))
    Get  the current input stream.   Useful to get access to  the status
    predicates associated with streams.


ccuurrrreenntt__oouuttppuutt((-_S_t_r_e_a_m_))
    Get the current output stream.


33..1155 SSttaattuuss ooff IInnppuutt aanndd OOuuttppuutt SSttrreeaammss


wwaaiitt__ffoorr__iinnppuutt((+_L_i_s_t_O_f_S_t_r_e_a_m_s_,_ -_R_e_a_d_y_L_i_s_t_,_ +_T_i_m_e_O_u_t_))
    Wait  for input on  one of the  streams in L_i_s_t_O_f_S_t_r_e_a_m_s_ and  return
    a  list  of  streams  on  which input  is  available  in  R_e_a_d_y_L_i_s_t_.
    wwaaiitt__ffoorr__iinnppuutt//33 waits for  at most T_i_m_e_O_u_t_  seconds.   T_i_m_e_o_u_t_  may
    be  specified as a floating point  number to specify fractions of  a
    second.   If  T_i_m_e_o_u_t_ equals 0, wwaaiitt__ffoorr__iinnppuutt//33waits  indefinitely.
    This  predicate can be used  to implement timeout while reading  and
    to  handle  input from  multiple  sources.   The  following  example
    will  wait for input from the  user and an explicitly opened  second
    terminal.  On return, I_n_p_u_t_s_ may hold user or P_4_ or both.

    ?- open('/dev/ttyp4', read, P4),
       wait_for_input([user, P4], Inputs, 0).


cchhaarraacctteerr__ccoouunntt((+_S_t_r_e_a_m_,_ -_C_o_u_n_t_))
    Unify  C_o_u_n_t_ with the  current character index.   For input  streams
    this  is the number  of characters read since  the open, for  output
    streams  this is the number of characters written.   Counting starts
    at 0.


lliinnee__ccoouunntt((+_S_t_r_e_a_m_,_ -_C_o_u_n_t_))
    Unify  C_o_u_n_t_ with the  number of  lines read or  written.   Counting
    starts at 1.


lliinnee__ppoossiittiioonn((+_S_t_r_e_a_m_,_ -_C_o_u_n_t_))
    Unify  C_o_u_n_t_ with the position on the current line.  Note  that this
    assumes  the position is 0 after the  open.  Tabs are assumed  to be
    defined on each  8-th character and backspaces are assumed to reduce
    the count by one, provided it is positive.


ffiilleeeerrrroorrss((-_O_l_d_,_ +_N_e_w_))
    Define error behaviour  on errors when opening a file for reading or
    writing.   Valid values are the  atoms on (default) and off.   First
    O_l_d_  is unified with the current value.   Then the new value  is set
    to N_e_w_.


33..1166 PPrriimmiittiivvee CChhaarraacctteerr IInnppuutt aanndd OOuuttppuutt


nnll
    Write  a newline character  to the current output  stream.  On  Unix
    systems nnll//00 is equivalent to put(10).


nnll((+_S_t_r_e_a_m_))
    Write a newline to S_t_r_e_a_m_.


ppuutt((+_C_h_a_r_))
    Write  C_h_a_r_  to  the  current  output  stream,  C_h_a_r_  is  either  an
    integer-expression  evaluating to an ASCII  value (0 C_h_a_r_ 255) or
    an atom of one character.


ppuutt((+_S_t_r_e_a_m_,_ +_C_h_a_r_))
    Write C_h_a_r_ to S_t_r_e_a_m_.


ttaabb((+_A_m_o_u_n_t_))
    Writes  A_m_o_u_n_t_  spaces  on  the  current  output  stream.     A_m_o_u_n_t_
    should  be an expression that  evaluates to a positive integer  (see
    section 3.22).


ttaabb((+_S_t_r_e_a_m_,_ +_A_m_o_u_n_t_))
    Writes A_m_o_u_n_t_ spaces to S_t_r_e_a_m_.


fflluusshh
    Flush  pending  output  on  current  output  stream.     fflluusshh//00  is
    automatically  generated by  rreeaadd//11 and derivatives  if the  current
    input stream is user and the cursor is not at the left margin.


fflluusshh__oouuttppuutt((+_S_t_r_e_a_m_))
    Flush  output on the specified stream.  The stream must be  open for
    writing.


ttttyyfflluusshh
    Flush pending output on stream u_s_e_r_.  See also fflluusshh//00.


ggeett00((-_C_h_a_r_))
    Read  the current  input stream  and unify the  next character  with
    C_h_a_r_.  C_h_a_r_ is unified with -1 on end of file.


ggeett00((+_S_t_r_e_a_m_,_ -_C_h_a_r_))
    Read the next character from S_t_r_e_a_m_.


ggeett((-_C_h_a_r_))
    Read  the  current   input  stream  and  unify  the  next  non-blank
    character with C_h_a_r_.  C_h_a_r_ is unified with -1 on end of file.


ggeett((+_S_t_r_e_a_m_,_ -_C_h_a_r_))
    Read the next non-blank character from S_t_r_e_a_m_.


ppeeeekk__bbyyttee((-_C_h_a_r_))
    Reads  the next input character like ggeett00//11, but does not  remove it
    from the input stream.  This predicate is ISO compliant.


ppeeeekk__bbyyttee((+_S_t_r_e_a_m_,_ -_C_h_a_r_))
    Reads  the next input character like ggeett00//22, but does not  remove it
    from the stream.  This predicate is ISO compliant.


sskkiipp((+_C_h_a_r_))
    Read the input until  C_h_a_r_ or the end of the file is encountered.  A
    subsequent call to ggeett00//11 will read the first character after C_h_a_r_.


sskkiipp((+_S_t_r_e_a_m_,_ +_C_h_a_r_))
    Skip input (as sskkiipp//11) on S_t_r_e_a_m_.


ggeett__ssiinnggllee__cchhaarr((-_C_h_a_r_))
    Get  a single character from input stream `user' (regardless  of the
    current  input stream).  Unlike ggeett00//11 this predicate does  not wait
    for  a return.  The character is not echoed to the  user's terminal.
    This  predicate  is meant  for keyboard  menu selection  etc..    If
    SWI-Prolog was started  with the -tty option this predicate reads an
    entire  line of input and  returns the first non-blank character  on
    this line, or the  ASCII code of the newline (10) if the entire line
    consisted of blank characters.


aatt__eenndd__ooff__ssttrreeaamm
    Succeeds  after the last character  of the current input stream  has
    been  read.    Also succeeds  if  there is  no valid  current  input
    stream.


aatt__eenndd__ooff__ssttrreeaamm((+_S_t_r_e_a_m_))
    Succeeds  after the last character of  the named stream is read,  or
    S_t_r_e_a_m_ is not a valid input stream.


33..1177 TTeerrmm RReeaaddiinngg aanndd WWrriittiinngg

This section  describes the basic term  reading and writing  predicates.
The  predicates  tteerrmm__ttoo__aattoomm//22 and  aattoomm__ttoo__tteerrmm//33 provide   means  for
translating atoms  and strings to  terms.   The predicates  ffoorrmmaatt//[[11,,22]]
and wwrriitteeff//22 provide formatted output.

There are  two ways  to manipulate  the output  format.   The  predicate
pprriinntt//[[11,,22]] may be programmed  using ppoorrttrraayy//11.  The format  of floating
point  numbers may  be  manipulated using  the feature  (see  ffeeaattuurree//22)
float_format.

Reading is  sensitive to the  feature character_escapes, which  controls
the interpretation of the \ character in quoted atoms and strings.


wwrriittee__tteerrmm((+_T_e_r_m_,_ +_O_p_t_i_o_n_s_))
    The  predicate  wwrriittee__tteerrmm//22 is  the  generic  form  of  all  Prolog
    term-write predicates.  Valid options are:

    qquuootteedd((true o_r_ false))
         If true, atoms and  functors that needs quotes will  be quoted.
         The default is false.

    iiggnnoorree__ooppss((true o_r_ false))
         If true, the generic term-representation (<f_u_n_c_t_o_r_>(<a_r_g_s_> ...))
         will be  used for  all terms,  Otherwise (default),  operators,
         list-notation and  {}/1  will be  written using  their  special
         syntax.

    nnuummbbeerrvvaarrss((true o_r_ false))
         If true, terms  of the format $VAR(N), where  <N_> is a positive
         integer, will be  written as a variable  name.  The default  is
         false.

    ppoorrttrraayy((true o_r_ false))
         If true, the  hook ppoorrttrraayy//11 is  called before printing a  term
         that is not  a variable.   If ppoorrttrraayy//11  succeeds, the term  is
         considered printed.  See  also pprriinntt//11.  The default  is false.
         This option is an extension to the ISO write_term options.


wwrriittee__tteerrmm((+_S_t_r_e_a_m_,_ +_T_e_r_m_,_ +_O_p_t_i_o_n_s_))
    As  wwrriittee__tteerrmm//22,  but  output  is sent  to  S_t_r_e_a_m_ rather  than  the
    current output.


wwrriittee__ccaannoonniiccaall((+_T_e_r_m_))
    Write  T_e_r_m_ on  the current output  stream using standard  parenthe-
    sised prefix notation  (i.e. ignoring operator declarations).  Atoms
    that need quotes are  quoted.  Terms written with this predicate can
    always  be read back,  regardless of current operator  declarations.
    Equivalent to wwrriittee__tteerrmm//22 using the options ignore_ops and quoted.


wwrriittee__ccaannoonniiccaall((+_S_t_r_e_a_m_,_ +_T_e_r_m_))
    Write T_e_r_m_ in canonical form on S_t_r_e_a_m_.


wwrriittee((+_T_e_r_m_))
    Write  T_e_r_m_  to the  current output,  using  brackets and  operators
    where  appropriate.   See ffeeaattuurree//22  for controlling floating  point
    output format.


wwrriittee((+_S_t_r_e_a_m_,_ +_T_e_r_m_))
    Write T_e_r_m_ to S_t_r_e_a_m_.


wwrriitteeqq((+_T_e_r_m_))
    Write  T_e_r_m_  to the  current output,  using  brackets and  operators
    where  appropriate.    Atoms that  need quotes  are quoted.    Terms
    written  with this predicate can  be read back with rreeaadd//11  provided
    the currently active operator declarations are identical.


wwrriitteeqq((+_S_t_r_e_a_m_,_ +_T_e_r_m_))
    Write T_e_r_m_ to S_t_r_e_a_m_, inserting quotes.


pprriinntt((+_T_e_r_m_))
    Prints  T_e_r_m_ on the  current output stream  similar to wwrriittee//11,  but
    for each (sub)term  of T_e_r_m_ first the dynamic predicate ppoorrttrraayy//11 is
    called.   If this predicate succeeds p_r_i_n_t_ assumes the (sub)term has
    been written.  This allows for user defined term writing.


pprriinntt((+_S_t_r_e_a_m_,_ +_T_e_r_m_))
    Print T_e_r_m_ to S_t_r_e_a_m_.


ppoorrttrraayy((+_T_e_r_m_))
    A dynamic predicate, which  can be defined by the user to change the
    behaviour  of pprriinntt//11 on (sub)terms.   For each subterm  encountered
    that is not  a variable pprriinntt//11 first calls ppoorrttrraayy//11 using the term
    as  argument.    For lists  only the  list as  a whole  is given  to
    ppoorrttrraayy//11.   If portray succeeds  pprriinntt//11 assumes the term has  been
    written.


rreeaadd((-_T_e_r_m_))
    Read  the next Prolog term from  the current input stream and  unify
    it  with T_e_r_m_.  On a syntax error rreeaadd//11 displays an  error message,
    attempts  to  skip  the erroneous  term  and  fails.    On  reaching
    end-of-file T_e_r_m_ is unified with the atom end_of_file.


rreeaadd((+_S_t_r_e_a_m_,_ -_T_e_r_m_))
    Read T_e_r_m_ from S_t_r_e_a_m_.


rreeaadd__ccllaauussee((-_T_e_r_m_))
    Equivalent  to  rreeaadd//11,  but  warns  the  user  for  variables  only
    occurring  once in a term  (singleton variables) which do not  start
    with  an underscore  if style_check(singleton) is active  (default).
    Used  to read Prolog source files (see ccoonnssuulltt//11).  New  code should
    use rreeaadd__tteerrmm//22 with the option singletons(warning).


rreeaadd__ccllaauussee((+_S_t_r_e_a_m_,_ -_T_e_r_m_))
    Read a clause from S_t_r_e_a_m_.  See rreeaadd__ccllaauussee//11.


rreeaadd__vvaarriiaabblleess((-_T_e_r_m_,_ -_B_i_n_d_i_n_g_s_))
    Similar  to  rreeaadd//11,   but  B_i_n_d_i_n_g_s_  is  unified  with  a  list  of
    `N_a_m_e_ = V_a_r_' tuples, thus  providing access to  the actual variable
    names.      New  code  should   use  rreeaadd__tteerrmm//22 using  the   option
    variables(X).


rreeaadd__vvaarriiaabblleess((+_S_t_r_e_a_m_,_ -_T_e_r_m_,_ -_B_i_n_d_i_n_g_s_))
    Read,    returning  term   and   bindings   from  S_t_r_e_a_m_.        See
    rreeaadd__vvaarriiaabblleess//22.


rreeaadd__tteerrmm((-_T_e_r_m_,_ +_O_p_t_i_o_n_s_))
    Read  a term from the current  input stream and unify the term  with
    T_e_r_m_.    The  reading is  controlled  by options  from the  list  of
    O_p_t_i_o_n_s_.   If this list is  empty, the behaviour is the same  as for
    rreeaadd//11.   The options are upward compatible to Quintus Prolog.   The
    argument order is according to the ISO standard.  Options:

    ssyynnttaaxx__eerrrroorrss((a_t_o_m_ o_r_ v_a_r_i_a_b_l_e_))
         Define the  behaviour for  when  a syntax  error occurs.    The
         possible values are:

         ffaaiill
             Default behaviour.  The error  is reported as a warning and
             the predicate fails.

         qquuiieett
             Quietly fails if a syntax error has occurred.

         VVaarriiaabbllee
             If  no error  occurs, the  variable is  unified with  none,
             otherwise V_a_r_i_a_b_l_e_ is unified with a term of the form

             '$stream_position'(CharNo, LineNo, LinePos):Message

             This behaviour is a SWI-Prolog extension.

    vvaarriiaabbllee__nnaammeess((V_a_r_s_))
         Unify V_a_r_s_ with a list  of `N_a_m_e_ = V_a_r_', where N_a_m_e_ is  an atom
         describing the variable name and V_a_r_ is a  variable that shares
         with the corresponding variable in T_e_r_m_.

    ssiinngglleettoonnss((V_a_r_s_))
         As variable_names,  but only  reports  the variables  occurring
         only  once in  the  T_e_r_m_ read.     Variables starting  with  an
         underscore (`_') are not included in this list.

    tteerrmm__ppoossiittiioonn((P_o_s_))
         Unifies P_o_s_ with the starting  position of the term read.   P_o_s_
         if of the same format as use by ssttrreeaamm__ppoossiittiioonn//33.

    ssuubbtteerrmm__ppoossiittiioonnss((T_e_r_m_P_o_s_))
         Describes the  detailed layout of  the term.   The formats  for
         the various types of terms  if given below.  All  positions are
         character positions.    If  the input  is related  to a  normal
         stream,  these  positions are  relative  to the  start  of  the
         input, when  reading from  the terminal, they  are relative  to
         the start of the term.

         FFrroomm--TToo
             Used for primitive types (atoms, numbers, variables).

         ssttrriinngg__ppoossiittiioonn((F_r_o_m_,_ T_o_))
             Used  to indicate  the  position of  a string  enclosed  in
             double quotes (").

         bbrraaccee__tteerrmm__ppoossiittiioonn((F_r_o_m_,_ T_o_,_ A_r_g_))
             Term  of  the form  {...},  as used  in  DCG  rules.    A_r_g_
             describes the argument.

         lliisstt__ppoossiittiioonn((F_r_o_m_,_ T_o_,_ E_l_m_s_,_ T_a_i_l_))
             A list.  E_l_m_s_ describes the  positions of the elements.  If
             the list specifies the tail as |<T_a_i_l_T_e_r_m_>, T_a_i_l_ is unified
             with  the term-position  of the  tail,  otherwise with  the
             atom none.

         tteerrmm__ppoossiittiioonn((F_r_o_m_,_ T_o_,_ F_F_r_o_m_,_ F_T_o_,_ S_u_b_P_o_s_))
             Used  for a compound  term not matching  one of the  above.
             F_F_r_o_m_  and  F_T_o_  describe  the  position  of  the  functor.
             S_u_b_P_o_s_  is a  list,  each element  of  which describes  the
             term-position of the corresponding subterm.


rreeaadd__tteerrmm((+_S_t_r_e_a_m_,_ -_T_e_r_m_,_ +_O_p_t_i_o_n_s_))
    Read term with options from S_t_r_e_a_m_.  See rreeaadd__tteerrmm//22.


rreeaadd__hhiissttoorryy((+_S_h_o_w_,_ +_H_e_l_p_,_ +_S_p_e_c_i_a_l_,_ +_P_r_o_m_p_t_,_ -_T_e_r_m_,_ -_B_i_n_d_i_n_g_s_))
    Similar  to rreeaadd__vvaarriiaabblleess//22,  but allows for history  substitutions.
    rreeaadd__hhiissttoorryy//66 is used by the top level to read  the user's actions.
    S_h_o_w_  is the command the user should type to show the  saved events.
    H_e_l_p_  is  the  command  to  get an  overview  of  the  capabilities.
    S_p_e_c_i_a_l_  is a list  of commands that are  not saved in the  history.
    P_r_o_m_p_t_  is  the  first  prompt  given.    Continuation  prompts  for
    more  lines are  determined by  pprroommpptt//22.   A  %w in  the prompt  is
    substituted  by the  event number.   See  section 2.4 for  available
    substitutions.

    SWI-Prolog calls rreeaadd__hhiissttoorryy//66 as follows:

    read_history(h, '!h', [trace], '%w ?- ', Goal, Bindings)


hhiissttoorryy__ddeepptthh((-_I_n_t_))
    Dynamic  predicate, normally not defined.  The user can  define this
    predicate  to set the history depth.   It should unify the  argument
    with  a  positive integer.    When not  defined 15  is  used as  the
    default.


pprroommpptt((-_O_l_d_,_ +_N_e_w_))
    Set  prompt associated  with rreeaadd//11  and its  derivatives.   O_l_d_  is
    first  unified with the current prompt.  On success the  prompt will
    be  set to N_e_w_ if  this is an atom.   Otherwise an error message  is
    displayed.   A prompt  is printed if one  of the read predicates  is
    called  and the cursor is  at the left margin.   It is also  printed
    whenever  a newline is given and  the term has not been  terminated.
    Prompts are only printed when the current input stream is u_s_e_r_.


pprroommpptt11((+_P_r_o_m_p_t_))
    Sets  the prompt for the next line  to be read.   Continuation lines
    will be read using the prompt defined by pprroommpptt//22.


33..1188 AAnnaallyyssiinngg aanndd CCoonnssttrruuccttiinngg TTeerrmmss


ffuunnccttoorr((?_T_e_r_m_,_ ?_F_u_n_c_t_o_r_,_ ?_A_r_i_t_y_))
    Succeeds  if T_e_r_m_ is  a term with  functor F_u_n_c_t_o_r_ and arity  A_r_i_t_y_.
    If  T_e_r_m_ is a variable  it is unified with  a new term holding  only
    variables.    ffuunnccttoorr//33 silently  fails on  instantiation faults  If
    T_e_r_m_  is an atom or  number, F_u_n_c_t_o_r_ will  be unified with T_e_r_m_  and
    arity will be unified with the integer 0 (zero).


aarrgg((?_A_r_g_,_ ?_T_e_r_m_,_ ?_V_a_l_u_e_))
    T_e_r_m_  should be instantiated to a term, A_r_g_ to an integer  between 1
    and  the arity of T_e_r_m_.   V_a_l_u_e_ is unified with the  A_r_g_-th argument
    of  T_e_r_m_.    A_r_g_  may  also be  unbound.    In  this V_a_l_u_e_  will  be
    unified  with the successive arguments of  the term.  On  successful
    unification, A_r_g_ is  unified with the argument number.  Backtracking
    yields alternative solutions.


sseettaarrgg((+_A_r_g_,_ +_T_e_r_m_,_ +_V_a_l_u_e_))
    Extra-logical  predicate.     Assigns the  A_r_g_-th  argument  of  the
    compound  term T_e_r_m_ with the given V_a_l_u_e_.  The assignment  is undone
    if  backtracking brings the  state back into  a position before  the
    sseettaarrgg//33 call.

    This  predicate may  be used  for destructive  assignment to  terms,
    using them as and extra-logical storage bin.


?_T_e_r_m_ =.. ?_L_i_s_t_
    L_i_s_t_  is a list which head is the functor of T_e_r_m_ and  the remaining
    arguments are the arguments  of the term.  Each of the arguments may
    be  a variable,  but not  both.   This predicate  is called  `Univ'.
    Examples:

    ?- foo(hello, X) =.. List.

    List = [foo, hello, X]

    ?- Term =.. [baz, foo(1)]

    Term = baz(foo(1))


nnuummbbeerrvvaarrss((+_T_e_r_m_,_ +_F_u_n_c_t_o_r_,_ +_S_t_a_r_t_,_ -_E_n_d_))
    Unify  the free variables of T_e_r_m_  with a term constructed from  the
    atom  F_u_n_c_t_o_r_ with one argument.  The argument is the number  of the
    variable.    Counting starts  at S_t_a_r_t_.    E_n_d_ is  unified with  the
    number that should be given to the next variable.  Example:

    ?- numbervars(foo(A, B, A), this_is_a_variable, 0, End).

    A = this_is_a_variable(0)
    B = this_is_a_variable(1)
    End = 2

    In Edinburgh Prolog the  second argument is missing.  It is fixed to
    be $VAR.


ffrreeee__vvaarriiaabblleess((+_T_e_r_m_,_ -_L_i_s_t_))
    Unify  L_i_s_t_ with  a list of  variables, each  sharing with a  unique
    variable of T_e_r_m_.  For example:

    ?- free_variables(a(X, b(Y, X), Z), L).

    L = [G367, G366, G371]
    X = G367
    Y = G366
    Z = G371


ccooppyy__tteerrmm((+_I_n_,_ -_O_u_t_))
    Make a copy of  term I_n_ and unify the result with O_u_t_.  Ground parts
    of  I_n_ are  shared by  O_u_t_.   Provided I_n_  and O_u_t_  have no  sharing
    variables  before  this call  they will  have  no sharing  variables
    afterwards.  ccooppyy__tteerrmm//22 is semantically equivalent to:

    copy_term(In, Out) :-
            recorda(copy_key, In, Ref),
            recorded(copy_key, Out, Ref),
            erase(Ref).


33..1199 AAnnaallyyssiinngg aanndd CCoonnssttrruuccttiinngg AAttoommss

These predicates  convert between  Prolog constants and  lists of  ASCII
values.   The predicates  aattoomm__cchhaarrss//22, nnuummbbeerr__cchhaarrss//22 and nnaammee//22  behave
the same  when converting  from a constant  to a  list of ASCII  values.
When  converting the  other way  around,  aattoomm__cchhaarrss//22 will generate  an
atom, number_chars will generate a  number or fail and nnaammee//22 will return
a number if possible and an atom otherwise.


aattoomm__cchhaarrss((?_A_t_o_m_,_ ?_S_t_r_i_n_g_))
    Convert  between an atom  and a list  of ASCII values.   If A_t_o_m_  is
    instantiated, if will  be translated into a list of ASCII values and
    the  result is unified with S_t_r_i_n_g_.   If A_t_o_m_ is unbound  and S_t_r_i_n_g_
    is  a list of  ASCII values, it  will A_t_o_m_ will  be unified with  an
    atom constructed from this list.


aattoomm__cchhaarr((?_A_t_o_m_,_ ?_A_S_C_I_I_))
    Convert between character and ASCII value for a single character.


nnuummbbeerr__cchhaarrss((?_N_u_m_b_e_r_,_ ?_S_t_r_i_n_g_))
    Similar  to  aattoomm__cchhaarrss//22,  but  converts between  a number  and  its
    representation  as a list of ASCII  values.  Fails silently if  A_t_o_m_
    is unbound and S_t_r_i_n_g_ does not describe a number.


nnaammee((?_A_t_o_m_O_r_I_n_t_,_ ?_S_t_r_i_n_g_))
    S_t_r_i_n_g_  is a  list of ASCII  values describing  A_t_o_m_.   Each of  the
    arguments may be a  variable, but not both.  When S_t_r_i_n_g_ is bound to
    an  ASCII value list  describing an integer  and A_t_o_m_ is a  variable
    A_t_o_m_  will be  unified with  the integer value  described by  S_t_r_i_n_g_
    (e.g.  `name(N, "300"), 400 is N + 100' succeeds).


iinntt__ttoo__aattoomm((+_I_n_t_,_ +_B_a_s_e_,_ -_A_t_o_m_))
    Convert  I_n_t_ to an  ascii representation using  base B_a_s_e_ and  unify
    the  result with A_t_o_m_.   If B_a_s_e_ 6=10 the  base will be prepended  to
    A_t_o_m_.    B_a_s_e_= 0 will try  to interpret  I_n_t_ as an  ASCII value and
    return  0'<c_>.   Otherwise  2 B_a_s_e_ 36.    Some examples are  given
    below.

                   int_to_atom(45, 2, A)  -!   A= 20101101
                   int_to_atom(97, 0, A)  -!   A= 00a
                   int_to_atom(56, 10, A) -!   A= 56


iinntt__ttoo__aattoomm((+_I_n_t_,_ -_A_t_o_m_))
    Equivalent to int_to_atom(Int, 10, Atom).


tteerrmm__ttoo__aattoomm((?_T_e_r_m_,_ ?_A_t_o_m_))
    Succeeds  if A_t_o_m_ describes  a term  that unifies with  T_e_r_m_.   When
    A_t_o_m_  is instantiated A_t_o_m_ is converted and then unified  with T_e_r_m_.
    Otherwise T_e_r_m_ is ``written'' on A_t_o_m_ using wwrriittee//11.


aattoomm__ttoo__tteerrmm((+_A_t_o_m_,_ -_T_e_r_m_,_ -_B_i_n_d_i_n_g_s_))
    Use  A_t_o_m_ as input to  rreeaadd__vvaarriiaabblleess//22and  return the read term  in
    T_e_r_m_  and the variable bindings in B_i_n_d_i_n_g_s_.  B_i_n_d_i_n_g_s_ is a  list of
    N_a_m_e_ = V_a_r_ couples,  thus providing  access to the  actual variable
    names.  See also rreeaadd__vvaarriiaabblleess//22.


ccoonnccaatt((?_A_t_o_m_1_,_ ?_A_t_o_m_2_,_ ?_A_t_o_m_3_))
    A_t_o_m_3_  forms the concatenation of A_t_o_m_1_ and A_t_o_m_2_.  At least  two of
    the  arguments must be instantiated  to atoms, integers or  floating
    point numbers.


ccoonnccaatt__aattoomm((+_L_i_s_t_,_ -_A_t_o_m_))
    L_i_s_t_  is  a  list of  atoms,  integers  or floating  point  numbers.
    Succeeds  if A_t_o_m_ can be  unified with the concatenated elements  of
    L_i_s_t_.  If  L_i_s_t_ has exactly 2 elements it is equivalent to ccoonnccaatt//33,
    allowing for variables in the list.


ccoonnccaatt__aattoomm((+_L_i_s_t_,_ +_S_e_p_a_r_a_t_o_r_,_ -_A_t_o_m_))
    Creates  an  atom  just like  ccoonnccaatt__aattoomm//22,  but  inserts  S_e_p_a_r_a_t_o_r_
    between each pair of atoms.  For example:

    ?- concat_atom([gnu, gnat], ', ', A).

    A = 'gnu, gnat'


aattoomm__lleennggtthh((+_A_t_o_m_,_ -_L_e_n_g_t_h_))
    Succeeds  if  A_t_o_m_ is  an atom  of  L_e_n_g_t_h_ characters  long.    This
    predicate also works  for integers and floats, expressing the number
    of characters output when given to wwrriittee//11.


aattoomm__pprreeffiixx((+_A_t_o_m_,_ +_P_r_e_f_i_x_))
    Succeeds  if  A_t_o_m_ starts  with the  characters from  P_r_e_f_i_x_.    Its
    behaviour  is equivalent  to ?- concat(Prefix, _, Atom), but  avoids
    the construction of an atom for the `remainder'.


33..2200 RReepprreesseennttiinngg TTeexxtt iinn SSttrriinnggss

SWI-Prolog  supports the  data type  s_t_r_i_n_g_.   Strings  are  a time  and
space efficient  mechanism to handle  text in Prolog.   Atoms are  under
some circumstances  not suitable because garbage  collection on them  is
next  to impossible  (Although  it is  possible:   BIM_prolog  does  it).
Representing text as a  list of ASCII values is, from the  logical point
of view, the cleanest solution.  It however has two  drawbacks:  1) they
cannot be  distinguished from a  list of (small)  integers; and 2)  they
consume (in SWI-Prolog) 12 bytes for each character stored.

Within strings  each character only  requires 1 byte  storage.   Strings
live  on  the global  stack  and  their  storage is  thus  reclaimed  on
backtracking.  Garbage collection can easily deal with strings.

The ISO standard proposes " ..." is transformed into a  string object by
rreeaadd//11 and derivatives.   This poses  problems as in the old  convention
" ..." is transformed into a list of ascii characters.   For this reason
the style check option `string' is available (see ssttyyllee__cchheecckk//11).

The  set  of  predicates  associated  with  strings  is  incomplete  and
tentative.  Names and definitions might change in  the future to confirm
to the emerging standard.


ssttrriinngg__ttoo__aattoomm((?_S_t_r_i_n_g_,_ ?_A_t_o_m_))
    Logical  conversion between  a string  and an atom.    At least  one
    of  the two arguments  must be instantiated.   A_t_o_m_  can also be  an
    integer or floating point number.


ssttrriinngg__ttoo__lliisstt((?_S_t_r_i_n_g_,_ ?_L_i_s_t_))
    Logical conversion between  a string and a list of ASCII characters.
    At least one of the two arguments must be instantiated.


ssttrriinngg__lleennggtthh((+_S_t_r_i_n_g_,_ -_L_e_n_g_t_h_))
    Unify  L_e_n_g_t_h_  with  the number  of  characters  in S_t_r_i_n_g_.     This
    predicate  is  functionally  equivalent  to  aattoomm__lleennggtthh//22 and  also
    accepts atoms, integers and floats as its first argument.


ssttrriinngg__ccoonnccaatt((?_S_t_r_i_n_g_1_,_ ?_S_t_r_i_n_g_2_,_ ?_S_t_r_i_n_g_3_))
    Similar  to ccoonnccaatt//33, but the unbound argument will be  unified with
    a  string  object rather  than  an atom.    Also,  if  both  S_t_r_i_n_g_1_
    and  S_t_r_i_n_g_2_ are  unbound and S_t_r_i_n_g_3_  is bound to  text, it  breaks
    S_t_r_i_n_g_3_,  unifying the start with  S_t_r_i_n_g_1_ and the end with  S_t_r_i_n_g_2_
    as  append does  with lists.   Note  that this  is not  particularly
    fast  on long  strings as  for each redo  the system  has to  create
    two  entirely new strings, while the list equivalent only  creates a
    single new list-cell and moves some pointers around.


ssuubbssttrriinngg((+_S_t_r_i_n_g_,_ +_S_t_a_r_t_,_ +_L_e_n_g_t_h_,_ -_S_u_b_))
    Create  a substring  of  S_t_r_i_n_g_ that  starts at  character S_t_a_r_t_  (1
    base) and has L_e_n_g_t_h_ characters.  Unify this substring with S_u_b_.


33..2211 OOppeerraattoorrss


oopp((+_P_r_e_c_e_d_e_n_c_e_,_ +_T_y_p_e_,_ +_N_a_m_e_))
    Declare  N_a_m_e_  to  be  an  operator of  type  T_y_p_e_  with  precedence
    P_r_e_c_e_d_e_n_c_e_.    N_a_m_e_  can also  be a  list of  names,  in which  case
    all  elements of the  list are declared  to be identical  operators.
    P_r_e_c_e_d_e_n_c_e_  is an integer between 0 and 1200.  Precedence  0 removes
    the  declaration.   T_y_p_e_ is one  of:   xf, yf, xfx,  xfy, yfx,  yfy,
    fy  or fx.   The `f'  indicates the position  of the functor,  while
    x  and y  indicate the position  of the  arguments.   `y' should  be
    interpreted  as ``on this position  a term with precedence lower  or
    equal to the precedence  of the functor should occur''.  For `x' the
    precedence  of the argument must be strictly lower.   The precedence
    of  a term is  0, unless  its principal functor  is an operator,  in
    which  case the precedence  is the precedence of  this operator.   A
    term enclosed in brackets (...) has precedence 0.

    The  predefined operators are  shown in  table 3.1.   Note that  all
    operators can be redefined by the user.
     ______________________________________________________________
     | 1200 |xfx  |-->, :-                                        |
     | 1200 | fx  |:-, ?-                                         |
     | 1150 | fx  |dynamic, multifile, module_transparent, discon-|
     |      |     |tiguous, volatile, initialization              |
     | 1100 |xfy  |;, |                                           |

     | 1050 |xfy  |->                                             |
     | 1000 |xfy  |,                                              |
     |  954 |xfy  |\                                              |
     |  900 | fy  |\+, not                                        |
     |  900 | fx  |~                                              |
     |  700 |xfx  |<, =, =.., =@=,  =:=, =<, ==, =\=,  >, >=, @<, |
     |      |     |@=<, @>, @>=, \=, \==, is                      |
     |  600 |xfy  |:                                              |

     |  500 | yfx |+, -, /\, \/, xor                              |
     |  500 | fx  |+, -, ?, \                                     |
     |  400 | yfx |*, /, //, <<, >>, mod, rem                     |
     |  200 |xfx  |**                                             |
     |__200_|xfy__|^______________________________________________|_

                      Table 3.1:  System operators


ccuurrrreenntt__oopp((?_P_r_e_c_e_d_e_n_c_e_,_ ?_T_y_p_e_,_ ?_N_a_m_e_))
    Succeeds when N_a_m_e_  is currently defined as an operator of type T_y_p_e_
    with precedence P_r_e_c_e_d_e_n_c_e_.  See also oopp//33.


33..2222 AArriitthhmmeettiicc

Arithmetic can be  divided into some special purpose integer  predicates
and  a series  of  general predicates  for  floating point  and  integer
arithmetic as  appropriate.  The  integer predicates are as  ``logical''
as possible.  Their usage is recommended  whenever applicable, resulting
in faster and more ``logical'' programs.

The  general arithmetic  predicates  are  optionally compiled  now  (see
pplleeaassee//33 and the -O  command line option).  Compiled  arithmetic reduces
global  stack requirements  and  improves  performance.    Unfortunately
compiled arithmetic cannot be traced, which is why it is optional.

The  general  arithmetic   predicates  all  handle  e_x_p_r_e_s_s_i_o_n_s_.      An
expression is either a simple number or a f_u_n_c_t_i_o_n_.   The arguments of a
function are expressions.  The functions are described in section 3.23.


bbeettwweeeenn((+_L_o_w_,_ +_H_i_g_h_,_ ?_V_a_l_u_e_))
    L_o_w_  and H_i_g_h_  are integers, H_i_g_h_  L_o_w_.   If V_a_l_u_e_  is an integer,
    L_o_w_  V_a_l_u_e_ H_i_g_h_.   When V_a_l_u_e_  is a  variable it  is successively
    bound to all integers between L_o_w_ and H_i_g_h_.


ssuucccc((?_I_n_t_1_,_ ?_I_n_t_2_))
    Succeeds  if I_n_t_2_= I_n_t_1_+ 1.  At least one of  the arguments must be
    instantiated to an integer.


pplluuss((?_I_n_t_1_,_ ?_I_n_t_2_,_ ?_I_n_t_3_))
    Succeeds if  I_n_t_3_= I_n_t_1_+I_n_t_2_.   At least two of the three arguments
    must be instantiated to integers.


+_E_x_p_r_1_ > +_E_x_p_r_2_
    Succeeds  when expression  E_x_p_r_1_ evaluates to  a larger number  than
    E_x_p_r_2_.


+_E_x_p_r_1_ < +_E_x_p_r_2_
    Succeeds  when expression E_x_p_r_1_ evaluates  to a smaller number  than
    E_x_p_r_2_.


+_E_x_p_r_1_ =< +_E_x_p_r_2_
    Succeeds  when  expression E_x_p_r_1_  evaluates to  a  smaller or  equal
    number to E_x_p_r_2_.


+_E_x_p_r_1_ >= +_E_x_p_r_2_
    Succeeds  when  expression  E_x_p_r_1_ evaluates  to  a larger  or  equal
    number to E_x_p_r_2_.


+_E_x_p_r_1_ =\= +_E_x_p_r_2_
    Succeeds  when expression E_x_p_r_1_ evaluates  to a number non-equal  to
    E_x_p_r_2_.


+_E_x_p_r_1_ =:= +_E_x_p_r_2_
    Succeeds  when  expression  E_x_p_r_1_ evaluates  to  a number  equal  to
    E_x_p_r_2_.


-_N_u_m_b_e_r_ iiss +_E_x_p_r_
    Succeeds  when  N_u_m_b_e_r_   has  successfully  been  unified  with  the
    number  E_x_p_r_  evaluates to.    If  E_x_p_r_ evaluates  to a  float  that
    can  be represented  using  an integer  (i.e. the  value is  integer
    and  within the  range  that can  be described  by Prolog's  integer
    representation),  E_x_p_r_ is unified with the integer value.

    Note  that normally, iiss//22  will be used  with unbound left  operand.
    If equality is to be tested, =:=/2 should be used.  For example:

         ?- 1.0 is sin(pi/2).         Fails!.   sin(pi/2) evaluates
                                      to   1.0,   but   iiss//22   will
                                      represent this as the integer
                                      1,  after  which  unify  will
                                      fail.

         ?- 1.0 is float(sin(pi/2)).  Succeeds,   as   the  ffllooaatt//11
                                      function forces the result to
                                      be float.
         ?- 1.0 =:= sin(pi/2).        Succeeds as expected.


33..2233 AArriitthhmmeettiicc FFuunnccttiioonnss

Arithmetic functions  are terms  which are evaluated  by the  arithmetic
predicates described  above.   SWI-Prolog tries  to hide the  difference
between  integer  arithmetic  and floating  point  arithmetic  from  the
Prolog  user.   Arithmetic  is done  as integer  arithmetic  as long  as
possible  and converted  to floating  point arithmetic  whenever one  of
the arguments  or the combination of  them requires it.   If a  function
returns  a floating  point  value which  is  whole it  is  automatically
transformed into  an integer.   There  are three  types of arguments  to
functions:

        E_x_p_r_     Arbitrary   expression,   returning  either   a
                 floating point value or an integer.
        I_n_t_E_x_p_r_  Arbitrary expression that should  evaluate into
                 an integer.
        I_n_t_      An integer.

In  case integer  addition, subtraction  and  multiplication would  lead
to  an integer  overflow  the operands  are automatically  converted  to
floating point  numbers.   The floating  point functions (ssiinn//11,  eexxpp//11,
etc.)     form  a  direct  interface  to  the  corresponding  C  library
functions used  to compile SWI-Prolog.   Please refer  to the C  library
documentation for details on precision, error handling, etc.


- +_E_x_p_r_
    R_e_s_u_l_t_ =-E_x_p_r_


+_E_x_p_r_1_ + +_E_x_p_r_2_
    R_e_s_u_l_t_ =E_x_p_r_1_ +E_x_p_r_2_


+_E_x_p_r_1_ - +_E_x_p_r_2_
    R_e_s_u_l_t_ =E_x_p_r_1_ -E_x_p_r_2_


+_E_x_p_r_1_ * +_E_x_p_r_2_
    R_e_s_u_l_t_ =E_x_p_r_1_*_Expr2


+_E_x_p_r_1_ / +_E_x_p_r_2_
    R_e_s_u_l_t_ =E_x_p_r_1_=E_x_p_r_2_


+_I_n_t_E_x_p_r_1_ mmoodd +_I_n_t_E_x_p_r_2_
    R_e_s_u_l_t_ =E_x_p_r_1_modE_x_p_r_2_ (remainder of division).


+_I_n_t_E_x_p_r_1_ rreemm +_I_n_t_E_x_p_r_2_
    R_e_s_u_l_t_ =E_x_p_r_1_remE_x_p_r_2_ (remainder of division).


+_I_n_t_E_x_p_r_1_ // +_I_n_t_E_x_p_r_2_
    R_e_s_u_l_t_ =E_x_p_r_1_ E_x_p_r_2_ (integer division).


aabbss((+_E_x_p_r_))
    Evaluate E_x_p_r_ and return the absolute value of it.


ssiiggnn((+_E_x_p_r_))
    Evaluate to -1 if E_x_p_r_ <0, 1 if E_x_p_r_ >0 and 0 if E_x_p_r_ =0.


mmaaxx((+_E_x_p_r_1_,_ +_E_x_p_r_2_))
    Evaluates to the largest of both E_x_p_r_1_ and E_x_p_r_2_.


mmiinn((+_E_x_p_r_1_,_ +_E_x_p_r_2_))
    Evaluates to the smallest of both E_x_p_r_1_ and E_x_p_r_2_.


.((+_I_n_t_,_ [_]_))
    A  list of  one  element evaluates  to the  element.   This  implies
    "a"  evaluates to  the ASCII value  of the  letter `a' (97).    This
    option  is available for  compatibility only.   It will not work  if
    `style_check(+string)'  is active as  "a" will  then be  transformed
    into  a string object.    The recommended way  to specify the  ASCII
    value of the letter `a' is 0'a.


rraannddoomm((+_I_n_t_))
    Evaluates  to a  random integer i_  for which  0 i< I_n_t_.   The seed
    of  this random  generator is  determined by the  system clock  when
    SWI-Prolog was started.


rroouunndd((+_E_x_p_r_))
    Evaluates E_x_p_r_ and rounds the result to the nearest integer.


iinntteeggeerr((+_E_x_p_r_))
    Same as rroouunndd//11 (backward compatibility).


ffllooaatt((+_E_x_p_r_))
    Translate  the result to a floating point number.   Normally, Prolog
    will  use integers  whenever possible.    When used  around the  2nd
    argument  of iiss//22, the result will  be returned as a floating  point
    number.  In other contexts, the operation has no effect.


ffllooaatt__ffrraaccttiioonnaall__ppaarrtt((+_E_x_p_r_))
    Fractional  part of a  floating-point number.   Negative if E_x_p_r_  is
    negative, 0 if E_x_p_r_ is integer.


ffllooaatt__iinntteeggeerr__ppaarrtt((+_E_x_p_r_))
    Integer  part  of  floating-point  number.    Negative  if  E_x_p_r_  is
    negative, E_x_p_r_ if E_x_p_r_ is integer.


ttrruunnccaattee((+_E_x_p_r_))
    Truncate E_x_p_r_ to an integer.  Same as ffllooaatt__iinntteeggeerr__ppaarrtt//11.


fflloooorr((+_E_x_p_r_))
    Evaluates  E_x_p_r_ and returns the largest integer smaller or  equal to
    the result of the evaluation.


cceeiilliinngg((+_E_x_p_r_))
    Evaluates  E_x_p_r_ and returns the smallest integer larger or  equal to
    the result of the evaluation.


cceeiill((+_E_x_p_r_))
    Same as cceeiilliinngg//11 (backward compatibility).


+_I_n_t_E_x_p_r_ >> +_I_n_t_E_x_p_r_
    Bitwise shift I_n_t_E_x_p_r_1_ by I_n_t_E_x_p_r_2_ bits to the right.


+_I_n_t_E_x_p_r_ << +_I_n_t_E_x_p_r_
    Bitwise shift I_n_t_E_x_p_r_1_ by I_n_t_E_x_p_r_2_ bits to the left.


+_I_n_t_E_x_p_r_ \/ +_I_n_t_E_x_p_r_
    Bitwise `or' I_n_t_E_x_p_r_1_ and I_n_t_E_x_p_r_2_.


+_I_n_t_E_x_p_r_ /\ +_I_n_t_E_x_p_r_
    Bitwise `and' I_n_t_E_x_p_r_1_ and I_n_t_E_x_p_r_2_.


+_I_n_t_E_x_p_r_ xxoorr +_I_n_t_E_x_p_r_
    Bitwise `exclusive or' I_n_t_E_x_p_r_1_ and I_n_t_E_x_p_r_2_.


\ +_I_n_t_E_x_p_r_
    Bitwise negation.


ssqqrrtt((+_E_x_p_r_))
    R_e_s_u_l_t_ =square root of E_x_p_r_


ssiinn((+_E_x_p_r_))
    R_e_s_u_l_t_ =sine of E_x_p_r_.  E_x_p_r_ is the angle in radians.


ccooss((+_E_x_p_r_))
    R_e_s_u_l_t_ =cosine of E_x_p_r_.  E_x_p_r_ is the angle in radians.


ttaann((+_E_x_p_r_))
    R_e_s_u_l_t_ =tangus of E_x_p_r_.  E_x_p_r_ is the angle in radians.


aassiinn((+_E_x_p_r_))
    R_e_s_u_l_t_ =inverse sine of E_x_p_r_.  R_e_s_u_l_t_ is the angle in radians.


aaccooss((+_E_x_p_r_))
    R_e_s_u_l_t_ =inverse cosine of E_x_p_r_.  R_e_s_u_l_t_ is the angle in radians.


aattaann((+_E_x_p_r_))
    R_e_s_u_l_t_ =inverse tangus of E_x_p_r_.  R_e_s_u_l_t_ is the angle in radians.


aattaann((+_Y_E_x_p_r_,_ +_X_E_x_p_r_))
    R_e_s_u_l_t_ = inverse tangus of Y_E_x_p_r_ / X_E_x_p_r_.   R_e_s_u_l_t_ is  the angle in
    radians.    The return  value is  in the  range [-pi:::pi].   Used  to
    convert between rectangular and polar coordinate system.


lloogg((+_E_x_p_r_))
    R_e_s_u_l_t_ =natural logarithm of E_x_p_r_


lloogg1100((+_E_x_p_r_))
    R_e_s_u_l_t_ =10 base logarithm of E_x_p_r_


eexxpp((+_E_x_p_r_))
    R_e_s_u_l_t_ =e to the power E_x_p_r_


+_E_x_p_r_1_ ** +_E_x_p_r_2_
    R_e_s_u_l_t_ =E_x_p_r_1_ to the power E_x_p_r_2_


+_E_x_p_r_1_ ^ +_E_x_p_r_2_
    Same as **/2.  (backward compatibility).


ppii
    Evaluates to the mathematical constant pi (3.141593).


ee
    Evaluates to the mathematical constant e (2.718282).


ccppuuttiimmee
    Evaluates  to a floating  point number expressing  the cpu time  (in
    seconds)  used by Prolog  up till  now.   See also ssttaattiissttiiccss//22  and
    ttiimmee//11.


33..2244 AAddddiinngg AArriitthhmmeettiicc FFuunnccttiioonnss

Prolog predicates  can be given  the role of arithmetic  function.   The
last  argument is  used  to  return the  result,  the  arguments  before
the last  are the  inputs.   Arithmetic  functions are  added using  the
predicate aarriitthhmmeettiicc__ffuunnccttiioonn//11, which takes  the head as its  argument.
Arithmetic  functions  are module  sensitive,  that  is  they  are  only
visible from the module  in which the function is defined  and declared.
Global  arithmetic  functions  should be  defined  and  registered  from
module user.   Global definitions can  be overruled locally in  modules.
The builtin functions described above can be redefined as well.


aarriitthhmmeettiicc__ffuunnccttiioonn((+_H_e_a_d_))
    Register  a Prolog  predicate as an  arithmetic function (see  iiss//22,
    >//22 , etc.).   The Prolog  predicate should  have one more  argument
    than  specified by H_e_a_d_, which it either a term N_a_m_e_/_A_r_i_t_y_,  an atom
    or  a complex term.   This last argument  is an unbound variable  at
    call  time and  should  be instantiated  to an  integer or  floating
    point  number.    The other  arguments  are the  parameters.    This
    predicate  is  module  sensitive  and will  declare  the  arithmetic
    function  only for the context  module, unless declared from  module
    user.  Example:

    1 ?- [user].
    :- arithmetic_function(mean/2).

    mean(A, B, C) :-
            C is (A+B)/2.
    user compiled, 0.07 sec, 440 bytes.

    Yes
    2 ?- A is mean(4, 5).

    A = 4.500000


ccuurrrreenntt__aarriitthhmmeettiicc__ffuunnccttiioonn((?_H_e_a_d_))
    Successively unifies all  arithmetic functions that are visible from
    the context module with H_e_a_d_.


33..2255 LLiisstt MMaanniippuullaattiioonn


iiss__lliisstt((+_T_e_r_m_))
    Succeeds  if T_e_r_m_ is  bound to the  empty list ([])  or a term  with
    functor `.' and arity 2.


pprrooppeerr__lliisstt((+_T_e_r_m_))
    Equivalent  to iiss__lliisstt//11, but  also requires the tail of the  list to
    be a list (recursively).  Examples:

    is_list([x|A])          % true
    proper_list([x|A])      % false


aappppeenndd((?_L_i_s_t_1_,_ ?_L_i_s_t_2_,_ ?_L_i_s_t_3_))
    Succeeds  when L_i_s_t_3_  unifies with  the concatenation  of L_i_s_t_1_  and
    L_i_s_t_2_.   The  predicate can be  used with any instantiation  pattern
    (even three variables).


mmeemmbbeerr((?_E_l_e_m_,_ ?_L_i_s_t_))
    Succeeds  when E_l_e_m_ can be unified with one of the members  of L_i_s_t_.
    The predicate can be used with any instantiation pattern.


mmeemmbbeerrcchhkk((?_E_l_e_m_,_ +_L_i_s_t_))
    Equivalent to mmeemmbbeerr//22, but leaves no choice point.


ddeelleettee((+_L_i_s_t_1_,_ ?_E_l_e_m_,_ ?_L_i_s_t_2_))
    Delete all members  of L_i_s_t_1_ that simultaneously unify with E_l_e_m_ and
    unify the result with L_i_s_t_2_.


sseelleecctt((?_L_i_s_t_1_,_ ?_E_l_e_m_,_ ?_L_i_s_t_2_))
    Select  an  element of  L_i_s_t_1_ that  unifies  with E_l_e_m_.    L_i_s_t_2_  is
    unified  with  the  list remaining  from  L_i_s_t_1_ after  deleting  the
    selected  element.   Normally  used with  the instantiation  pattern
    +_L_i_s_t_1_,_ -_E_l_e_m_,_ -_L_i_s_t_2_,  but can also be used to insert an element in
    a list using -_L_i_s_t_1_,_ +_E_l_e_m_,_ +_L_i_s_t_2_.


nntthh00((?_I_n_d_e_x_,_ ?_L_i_s_t_,_ ?_E_l_e_m_))
    Succeeds  when  the  I_n_d_e_x_-th element  of  L_i_s_t_ unifies  with  E_l_e_m_.
    Counting starts at 0.


nntthh11((?_I_n_d_e_x_,_ ?_L_i_s_t_,_ ?_E_l_e_m_))
    Succeeds  when  the  I_n_d_e_x_-th element  of  L_i_s_t_ unifies  with  E_l_e_m_.
    Counting starts at 1.


llaasstt((?_E_l_e_m_,_ ?_L_i_s_t_))
    Succeeds if E_l_e_m_ unifies with the last element of L_i_s_t_.


rreevveerrssee((+_L_i_s_t_1_,_ -_L_i_s_t_2_))
    Reverse  the order  of the elements  in L_i_s_t_1_  and unify the  result
    with the elements of L_i_s_t_2_.


ffllaatttteenn((+_L_i_s_t_1_,_ -_L_i_s_t_2_))
    Transform  L_i_s_t_1_, possibly holding lists  as elements into a  `flat'
    list by replacing  each list with its elements (recursively).  Unify
    the resulting flat list with L_i_s_t_2_.  Example:

    ?- flatten([a, [b, [c, d], e]], X).

    X = [a, b, c, d, e]


lleennggtthh((?_L_i_s_t_,_ ?_I_n_t_))
    Succeeds  if I_n_t_  represents the  number of elements  of list  L_i_s_t_.
    Can be used to create a list holding only variables.


mmeerrggee((+_L_i_s_t_1_,_ +_L_i_s_t_2_,_ -_L_i_s_t_3_))
    L_i_s_t_1_  and L_i_s_t_2_ are  lists, sorted to  the standard order of  terms
    (see  section 3.5).    L_i_s_t_3_ will be  unified with  an ordered  list
    holding  both the elements of L_i_s_t_1_  and L_i_s_t_2_.  Duplicates are  nnoott
    removed.


33..2266 SSeett MMaanniippuullaattiioonn


iiss__sseett((+_S_e_t_))
    Succeeds  if  S_e_t_  is  a  proper  list  (see pprrooppeerr__lliisstt//11)  without
    duplicates.


lliisstt__ttoo__sseett((+_L_i_s_t_,_ -_S_e_t_))
    Succeeds  if S_e_t_ holds the same elements as L_i_s_t_ in the  same order,
    but has no duplicates.  See also ssoorrtt//22.


iinntteerrsseeccttiioonn((+_S_e_t_1_,_ +_S_e_t_2_,_ -_S_e_t_3_))
    Succeeds  if S_e_t_3_ unifies  with the intersection  of S_e_t_1_ and  S_e_t_2_.
    S_e_t_1_  and S_e_t_2_  are  lists without  duplicates.   They  need not  be
    ordered.


ssuubbttrraacctt((+_S_e_t_,_ +_D_e_l_e_t_e_,_ -_R_e_s_u_l_t_))
    Delete  all  elements  of set  `Delete'  from  `Set' and  unify  the
    resulting set with `Result'.


uunniioonn((+_S_e_t_1_,_ +_S_e_t_2_,_ -_S_e_t_3_))
    Succeeds if S_e_t_3_ unifies  with the union of S_e_t_1_ and S_e_t_2_.  S_e_t_1_ and
    S_e_t_2_ are lists without duplicates.  They need not be ordered.


ssuubbsseett((+_S_u_b_s_e_t_,_ +_S_e_t_))
    Succeeds if all elements of S_u_b_s_e_t_ are elements of S_e_t_ as well.


mmeerrggee__sseett((+_S_e_t_1_,_ +_S_e_t_2_,_ -_S_e_t_3_))
    S_e_t_1_  and S_e_t_2_ are lists without duplicates, sorted to  the standard
    order  of terms.    S_e_t_3_  is unified  with an  ordered list  without
    duplicates holding the union of the elements of S_e_t_1_ and S_e_t_2_.


33..2277 SSoorrttiinngg LLiissttss


ssoorrtt((+_L_i_s_t_,_ -_S_o_r_t_e_d_))
    Succeeds  if S_o_r_t_e_d_ can be unified with a list holding  the elements
    of  L_i_s_t_, sorted to the standard  order of terms (see section  3.5).
    Duplicates  are removed.  Implemented by translating the  input list
    into  a temporary  array,  calling the  C-library function  qqssoorrtt((3))
    using  PPLL__ccoommppaarree(()) for  comparing  the elements,  after  which  the
    result is translated into the result list.


mmssoorrtt((+_L_i_s_t_,_ -_S_o_r_t_e_d_))
    Equivalent to ssoorrtt//22, but does not remove duplicates.


kkeeyyssoorrtt((+_L_i_s_t_,_ -_S_o_r_t_e_d_))
    L_i_s_t_  is  a list  of  Key-Value pairs  (e.g.  terms of  the  functor
    `-'  with  arity  2).    kkeeyyssoorrtt//22  sorts  L_i_s_t_  like  mmssoorrtt//22,  but
    only  compares  the  keys.    Can  be  used  to sort  terms  not  on
    standard  order, but  on any criterion  that can  be expressed on  a
    multi-dimensional scale.   Sorting on more than one criterion can be
    done  using terms as keys,  putting the first criterion as  argument
    1,  the second as argument 2,  etc.  The order of  multiple elements
    that have the same K_e_y_ is not changed.


pprreeddssoorrtt((+_P_r_e_d_,_ +_L_i_s_t_,_ -_S_o_r_t_e_d_))
    Sorts  similar to mmssoorrtt//22, but determines the order of two  terms by
    applying  P_r_e_d_ to pairs  of elements from L_i_s_t_  (see aappppllyy//22).   The
    predicate  should succeed if the first element should be  before the
    second.


33..2288 FFiinnddiinngg aallll SSoolluuttiioonnss ttoo aa GGooaall


ffiinnddaallll((+_V_a_r_,_ +_G_o_a_l_,_ -_B_a_g_))
    Creates  a  list  of the  instantiations  V_a_r_ gets  successively  on
    backtracking  over G_o_a_l_ and unifies the  result with B_a_g_.   Succeeds
    with  an  empty  list  if G_o_a_l_  has  no  solutions.    ffiinnddaallll//33  is
    equivalent  to  bbaaggooff//33  with  all free  variables  bound  with  the
    existence  operator (^), except that bbaaggooff//33 fails when goal  has no
    solutions.


bbaaggooff((+_V_a_r_,_ +_G_o_a_l_,_ -_B_a_g_))
    Unify  B_a_g_ with the alternatives of V_a_r_, if G_o_a_l_ has  free variables
    besides  the one  sharing  with V_a_r_  bagof will  backtrack over  the
    alternatives  of  these  free  variables,   unifying  B_a_g_  with  the
    corresponding  alternatives of V_a_r_.   The construct +Var^Goal  tells
    bagof  not to  bind  V_a_r_ in  G_o_a_l_.   bbaaggooff//33  fails if  G_o_a_l_ has  no
    solutions.

    The  example below  illustrates bbaaggooff//33  and the  ^ operator.    The
    variable bindings are printed together on one line to save paper.

    2 ?- listing(foo).

    foo(a, b, c).
    foo(a, b, d).
    foo(b, c, e).
    foo(b, c, f).
    foo(c, c, g).

    Yes
    3 ?- bagof(C, foo(A, B, C), Cs).

    A = a, B = b, C = G308, Cs = [c, d] ;
    A = b, B = c, C = G308, Cs = [e, f] ;
    A = c, B = c, C = G308, Cs = [g] ;

    No
    4 ?- bagof(C, A^foo(A, B, C), Cs).

    A = G324, B = b, C = G326, Cs = [c, d] ;
    A = G324, B = c, C = G326, Cs = [e, f, g] ;

    No
    5 ?-


sseettooff((+_V_a_r_,_ +_G_o_a_l_,_ -_S_e_t_))
    Equivalent  to bbaaggooff//33, but sorts the  result using ssoorrtt//22 to get  a
    sorted list of alternatives without duplicates.


33..2299 IInnvvookkiinngg PPrreeddiiccaatteess oonn aallll MMeemmbbeerrss ooff aa LLiisstt

All the predicates  in this section call  a predicate on all members  of
a list  or until the predicate  called fails.   The predicate is  called
via aappppllyy//22, which implies  common arguments can be put in front  of the
arguments obtained from the list(s).  For example:

?- maplist(plus(1), [0, 1, 2], X).

X = [1, 2, 3]

we will phrase this as ``P_r_e_d_i_c_a_t_e_ is applied on ...''


cchheecckklliisstt((+_P_r_e_d_,_ +_L_i_s_t_))
    P_r_e_d_  is applied successively on each element of L_i_s_t_ until  the end
    of  the list  or P_r_e_d_ fails.    In the latter  case the  cchheecckklliisstt//22
    fails.


mmaapplliisstt((+_P_r_e_d_,_ ?_L_i_s_t_1_,_ ?_L_i_s_t_2_))
    Apply  P_r_e_d_  on all  successive  pairs of  elements from  L_i_s_t_1_  and
    L_i_s_t_2_.    Fails if  P_r_e_d_ can  not be  applied to a  pair.   See  the
    example above.


ssuubblliisstt((+_P_r_e_d_,_ +_L_i_s_t_1_,_ ?_L_i_s_t_2_))
    Unify  L_i_s_t_2_ with  a list  of all elements  of L_i_s_t_1_  to which  P_r_e_d_
    applies.


33..3300 FFoorraallll


ffoorraallll((+_C_o_n_d_,_ +_A_c_t_i_o_n_))
    For  all alternative bindings  of C_o_n_d_  A_c_t_i_o_n_ can be  proven.   The
    example  verifies that all arithmetic  statements in the list L_  are
    correct.  It does not say which is wrong if one proves wrong.

    ?- forall(member(Result = Formula, [2 = 1 + 1, 4 = 2 * 2]),
                     Result =:= Formula).


33..3311 FFoorrmmaatttteedd WWrriittee

The  current  version   of  SWI-Prolog  provides  two  formatted   write
predicates.    The  first  is wwrriitteeff//[[11,,22]],  which  is  compatible  with
Edinburgh C-Prolog.   The  second is  ffoorrmmaatt//[[11,,22]], which is  compatible
with Quintus  Prolog.   We hope  the Prolog  community will once  define
a  standard formatted  write predicate.    If you  want performance  use
ffoorrmmaatt//[[11,,22]] as this predicate is defined in  C. Otherwise compatibility
reasons might tell you which predicate to use.


33..3311..11 WWrriitteeff


wwrriittee__llnn((+_T_e_r_m_))
    Equivalent to write(Term), nl.


wwrriitteeff((+_A_t_o_m_))
    Equivalent to writef(Atom, []).


wwrriitteeff((+_F_o_r_m_a_t_,_ +_A_r_g_u_m_e_n_t_s_))
    Formatted  write.      F_o_r_m_a_t_  is  an  atom  whose  characters  will
    be   printed.     F_o_r_m_a_t_  may  contain  certain   special  character
    sequences   which  specify   certain  formatting  and   substitution
    actions.    A_r_g_u_m_e_n_t_s_ then  provides all  the terms  required to  be
    output.

    Escape sequences to generate a single special character:

             __________________________________________________
             | \n   |Output  a  nemline  character  (see  also |
             |      |nnll//[[00,,11]])                                 |
             | \l   |Output a line separator (same as \n)      |

             | \r   |Output   a   carriage-return    character |
             |      |(ASCII 13)                                |
             | \t   |Output the ASCII character TAB (9)        |
             | \\   |The character \ is output                 |
             | \%   |The character % is output                 |
             | \nnn |where <n_n_n_>  is an  integer  (1-3 digits) |
             |      |the character  with ASCII  code  <n_n_n_> is |

             |______|output_(NB_:_<n_n_n_>_is_read_as_ddeecciimmaall)____|

    Note  that \l,  \\bnfmeta{nnn}  and \\  are interpreted  differently
    when character-escapes are in effect.  See section 2.12.1.1.

    Escape  sequences to include  arguments from A_r_g_u_m_e_n_t_s_.   Each  time
    a  %  escape sequence  is found  in F_o_r_m_a_t_  the  next argument  from
    A_r_g_u_m_e_n_t_s_ is formatted according to the specification.

              _________________________________________________%t

              | %w  pprriinntt//11 the next item (mnemonic:  term)   |    |

              | %q  |wwrriittee//11the next item                     |

              | %d  |wwrriitteeqq//11the next item                    |

              | %p  |ddiissppllaayy//11the next item                   |

              |     |pprriinntt//11the next item (identical to %t)   |
              | %n  |Put  the next item  as a  character (i.e.|
              |     |it is an ASCII value)                    |
              | %r  |Write the  next item  N times where  N is|
              |     |the second item (an integer)             |

              | %s  |Write the  next item  as a String  (so it|
              |     |must be a list of characters)            |
              | %f  |Perform a ttttyyfflluusshh//00 (no items used)     |
              | %Nc |Write  the   next  item  Centered  in  N |
              |     |columns.                                 |
              | %Nl |Write the next  item Left justified in N |
              |     |columns.                                 |

              | %Nr |Write the next item Right justified in N |
              |     |columns.   N is a decimal number with  at|
              |     |least  one digit.   The  item must  be an|
              |_____|atom,_integer,_float_or_string.__________|_


sswwrriitteeff((-_S_t_r_i_n_g_,_ +_F_o_r_m_a_t_,_ +_A_r_g_u_m_e_n_t_s_))
    Equivalent to wwrriitteeff//22,  but ``writes'' the result on S_t_r_i_n_g_ instead
    of the current output stream.  Example:

    ?- swritef(S, '%15L%w', ['Hello', 'World']).

    S = "Hello          World"


sswwrriitteeff((-_S_t_r_i_n_g_,_ +_F_o_r_m_a_t_))
    Equivalent to swritef(String, Format, []).


33..3311..22 FFoorrmmaatt


ffoorrmmaatt((+_F_o_r_m_a_t_))
    Defined as `format(Format) :- format(Format, []).'


ffoorrmmaatt((+_F_o_r_m_a_t_,_ +_A_r_g_u_m_e_n_t_s_))
    F_o_r_m_a_t_   is  an   atom,   list  of   ASCII  values,   or  a   Prolog
    string.   A_r_g_u_m_e_n_t_s_  provides the arguments  required by the  format
    specification.   If  only one argument is  required and this is  not
    a  list of  ASCII values the  argument need  not be put  in a  list.
    Otherwise the arguments are put in a list.

    Special sequences start  with the tilde (~), followed by an optional
    numeric  argument, followed by a character describing the  action to
    be  undertaken.  A numeric argument is either a sequence  of digits,
    representing  a  positive decimal  number, a  sequence `<c_h_a_r_a_c_t_e_r_>,
    representing  the ASCII value of the character (only useful  for ~t)
    or  a asterisk (*), in when  the numeric argument is taken  from the
    next  argument of  the argument  list,  which should  be a  positive
    integer.  Actions are:

      ~  Output the tilde itself.

      a  Output the  next  argument, which  should  be an  atom.    This
         option is equivalent to ww.  Compatibility reasons only.

      c  Output the  next argument  as an ASCII  value.   This  argument
         should be an  integer in the range  [0, ..., 255] (including  0
         and 255).

      d  Output  next argument  as  a decimal  number.    It  should  be
         an integer.    If  a numeric  argument is  specified  a dot  is
         inserted a_r_g_u_m_e_n_t_  positions from the  right (useful for  doing
         fixed point arithmetic with integers, such as  handling amounts
         of money).

      D  Same as dd, but  makes large values easier to read  by inserting
         a comma every three digits left to the dot or right.

      e  Output next argument as a floating point  number in exponential
         notation.    The  numeric  argument  specifies  the  precision.
         Default is  6 digits.   Exact representation  depends on the  C
         library function printf().   This function is invoked  with the
         format %.<p_r_e_c_i_s_i_o_n_>e.

      E  Equivalent  to ee,  but  outputs a  capital  E to  indicate  the
         exponent.

      f  Floating point  in non-exponential  notation.    See C  library
         function printf().

      g  Floating point in ee or ff notation, whichever is shorter.

      G  Floating point in EE or ff notation, whichever is shorter.

      i  Ignore  next argument  of  the  argument  list.    Produces  no
         output.

      k  Give the next argument to ddiissppllaayyqq//11 (canonical write).

      n  Output a newline character.

      N  Only output  a newline  if the  last character  output on  this
         stream was not a newline.  Not properly implemented yet.

      p  Give the next argument to pprriinntt//11.

      q  Give the next argument to wwrriitteeqq//11.

      r  Print integer  in radix the  numeric argument  notation.   Thus
         ~16r prints its argument  hexadecimal.  The argument  should be
         in the range [2; :::;36].   Lower case letters are used for  digits
         above 9.

      R  Same as rr, but uses upper case letters for digits above 9.

      s  Output a string of ASCII characters from the next argument.

      t  All remaining space between 2 tabs tops  is distributed equally
         over ~t  statements  between the  tabs  tops.   This  space  is
         padded with  spaces by  default.   If an  argument is  supplied
         this is taken to be  the ASCII value of the character  used for
         padding.   This  can be  used to  do left  or right  alignment,
         centering, distributing, etc.   See also  ~| and ~+ to set  tab
         stops.  A tabs top is assumed at the start of each line.

      |  Set a  tabs top on  the current position.    If an argument  is
         supplied set  a  tabs top  on the  position  of that  argument.
         This  will  cause  all  ~t's  to  be  distributed  between  the
         previous and this tabs top.

      +  Set a tabs top relative  to the current position.   Further the
         same as ~|.

      w  Give the next argument to wwrriittee//11.

    Example:

    simple_statistics :-
        <obtain statistics>         % left to the user
        format('~tStatistics~t~72|~n~n'),
        format('Runtime: ~`.t ~2f~34|  Inferences: ~`.t ~D~72|~n',
                                                [RunT, Inf]),
        ....

    Will output

                                 Statistics

    Runtime: .................. 3.45  Inferences: .......... 60,345


ffoorrmmaatt((+_S_t_r_e_a_m_,_ +_F_o_r_m_a_t_,_ +_A_r_g_u_m_e_n_t_s_))
    As ffoorrmmaatt//22, but write the output on the given S_t_r_e_a_m_.


ssffoorrmmaatt((-_S_t_r_i_n_g_,_ +_F_o_r_m_a_t_,_ +_A_r_g_u_m_e_n_t_s_))
    Equivalent to ffoorrmmaatt//22,  but ``writes'' the result on S_t_r_i_n_g_ instead
    of the current output stream.  Example:

    ?- sformat(S, '~w~t~15|~w', ['Hello', 'World']).

    S = "Hello          World"


ssffoorrmmaatt((-_S_t_r_i_n_g_,_ +_F_o_r_m_a_t_))
    Equivalent to `sformat(String, Format, []).'


33..3311..33 PPrrooggrraammmmiinngg FFoorrmmaatt


ffoorrmmaatt__pprreeddiiccaattee((+_C_h_a_r_,_ +_H_e_a_d_))
    If  a sequence ~c (tilde, followed by some character) is  found, the
    format  derivatives will first check whether the user has  defined a
    predicate  to handle the format.   If  not, the built in  formatting
    rules  described above are  used.   C_h_a_r_ is  either an ascii  value,
    or  a one character atom,  specifying the letter to be  (re)defined.
    H_e_a_d_  is a  term, whose  name and  arity are used  to determine  the
    predicate  to call  for  the redefined  formatting character.    The
    first  argument to  the  predicate is  the numeric  argument of  the
    format  command, or the  atom default if  no argument is  specified.
    The  remaining arguments  are filled from  the argument  list.   The
    example  below redefines ~n to produce A_r_g_ times return  followed by
    linefeed (so a (Grr.)  DOS machine is happy with the output).

    :- format_predicate(n, dos_newline(_Arg)).

    dos_newline(Arg) :-
            between(1, Ar, _), put(13), put(10), fail ; true.


33..3322 TTeerrmmiinnaall CCoonnttrrooll

The  following  predicates  form  a  simple  access   mechanism  to  the
Unix  termcap library  to provide  terminal independent  I/O for  screen
terminals.   The  library package  library(tty) builds on  top of  these
predicates.


ttttyy__ggeett__ccaappaabbiilliittyy((+_N_a_m_e_,_ +_T_y_p_e_,_ -_R_e_s_u_l_t_))
    Get  the  capability named  N_a_m_e_  from the  termcap  library.    See
    termcap(5)  for the capability  names.   T_y_p_e_ specifies the type  of
    the  expected result, and is one of string, number or bool.   String
    results  are returned as  an atom, number  result as an integer  and
    bool  results as the atom on or off.   If an option cannot  be found
    this predicate fails  silently.  The results are only computed once.
    Successive queries on the same capability are fast.


ttttyy__ggoottoo((+_X_,_ +_Y_))
    Goto  position  (X_, Y_) on  the screen.    Note  that the  predicates
    lliinnee__ccoouunntt//22  and  lliinnee__ppoossiittiioonn//22 will  not  have  a  well  defined
    behaviour while using this predicate.


ttttyy__ppuutt((+_A_t_o_m_,_ +_L_i_n_e_s_))
    Put  an  atom  via the  termcap  library  function tputs().     This
    function  decodes padding  information  in the  strings returned  by
    ttttyy__ggeett__ccaappaabbiilliittyy//33 and should  be used  to  output these  strings.
    L_i_n_e_s_ is the number  of lines affected by the operation, or 1 if not
    applicable (as in almost all cases).


sseett__ttttyy((-_O_l_d_S_t_r_e_a_m_,_ +_N_e_w_S_t_r_e_a_m_))
    Set  the  output  stream,  used  by  ttttyy__ppuutt//22 and  ttttyy__ggoottoo//22 to  a
    specific stream.  Default is user_output.


33..3333 OOppeerraattiinngg SSyysstteemm IInntteerraaccttiioonn


sshheellll((+_C_o_m_m_a_n_d_,_ -_S_t_a_t_u_s_))
    Execute  C_o_m_m_a_n_d_ on the operating system.   C_o_m_m_a_n_d_ is given to  the
    Bourne  shell (/bin/sh).  S_t_a_t_u_s_ is unified with the exit  status of
    the command.

    On  W_i_n_3_2_  systems,  sshheellll//[[11,,22]]  executes  the  command  using  the
    CreateProcess() API and waits  for the command to terminate.  If the
    command  ends with a & sign, the command is handed to  the WinExec()
    API,  which does not wait for the  new task to terminate.   See also
    wwiinn__eexxeecc//22.


sshheellll((+_C_o_m_m_a_n_d_))
    Equivalent to `shell(Command, 0)'.


sshheellll
    Start  an  interactive  Unix  shell.     Default  is  /bin/sh,   the
    environment  variable SHELL overrides this  default.  Not  available
    for Win32 platforms.


wwiinn__eexxeecc((+_C_o_m_m_a_n_d_,_ +_S_h_o_w_))
    Win32  systems only.    Spawns a  Windows task  without waiting  for
    its  completion.  S_h_o_w_ is  either iconic or normal and dictates  the
    initial  status of the window.   The iconic option is notably  handy
    to start (DDE) servers.


ggeetteennvv((+_N_a_m_e_,_ -_V_a_l_u_e_))
    Get Unix environment variable  (see csh(1) and sh(1)).  Fails if the
    variable does not exist.


sseetteennvv((+_N_a_m_e_,_ +_V_a_l_u_e_))
    Set   Unix  environment  variable.     N_a_m_e_  and  V_a_l_u_e_   should  be
    instantiated  to atoms or integers.   The environment variable  will
    be passed to sshheellll//[[00--22]] and can be requested using ggeetteennvv//22.


uunnsseetteennvv((+_N_a_m_e_))
    Remove Unix environment variable from the environment.


ggeett__ttiimmee((-_T_i_m_e_))
    Return  the number of seconds that elapsed since the epoch  of Unix,
    1  January 1970, 0  hours.  T_i_m_e_  is a floating  point number.   Its
    granularity is system dependent.  On sun, this is 1/60 of a second.


ccoonnvveerrtt__ttiimmee((+_T_i_m_e_,_ -_Y_e_a_r_,_ -_M_o_n_t_h_,_ -_D_a_y_,_ -_H_o_u_r_,_ -_M_i_n_u_t_e_,_ -_S_e_c_o_n_d_,_ -_M_i_l_l_i_S_e_c_o_n_d_s_))

    Convert   a  time   stamp,  provided   by  ggeett__ttiimmee//11,  ttiimmee__ffiillee//22,
    etc.   Y_e_a_r_ is  unified with the year,  M_o_n_t_h_ with the month  number
    (January  is 1), D_a_y_  with the day of  the month (starting with  1),
    H_o_u_r_  with  the hour  of the  day (0--23),  M_i_n_u_t_e_  with the  minute
    (0--59).   S_e_c_o_n_d_ with the  second (0--59) and M_i_l_l_i_S_e_c_o_n_d_ with  the
    milliseconds  (0--999).  Note that the latter might not  be accurate
    or  might always be 0, depending  on the timing capabilities of  the
    system.


33..3344 FFiillee SSyysstteemm IInntteerraaccttiioonn


aacccceessss__ffiillee((+_F_i_l_e_,_ +_M_o_d_e_))
    Succeeds  if F_i_l_e_ exists and can be accessed by this  prolog process
    under  mode M_o_d_e_.   M_o_d_e_ is  one of the  atoms read, write,  append,
    exist,  none or execute.  F_i_l_e_ may also be the name  of a directory.
    Fails  silently otherwise.   access_file(File, none)simply  succeeds
    without testing anything.

    If  `Mode' is write or append,  this predicate also succeeds if  the
    file  does not exist and the user has write-access to  the directory
    of the specified location.


eexxiissttss__ffiillee((+_F_i_l_e_))
    Succeeds  when F_i_l_e_ exists.  This  does not imply the user  has read
    and/or write permission for the file.


ffiillee__ddiirreeccttoorryy__nnaammee((+_F_i_l_e_,_ -_D_i_r_e_c_t_o_r_y_))
    Extracts  the directory-part of F_i_l_e_.  The resulting  D_i_r_e_c_t_o_r_y_ name
    ends  with the directory separator character /.  If F_i_l_e_ is  an atom
    that does not  contain any directory separator characters, the empty
    atom '' is returned.  See also ffiillee__bbaassee__nnaammee//22.


ffiillee__bbaassee__nnaammee((+_F_i_l_e_,_ -_B_a_s_e_N_a_m_e_))
    Extracts the filename part  from a path specification.  If F_i_l_e_ does
    not contain any directory separators, F_i_l_e_ is returned.


ssaammee__ffiillee((+_F_i_l_e_1_,_ +_F_i_l_e_2_))
    Succeeds  if both filenames refer to  the same physical file.   That
    is,  if F_i_l_e_1_  and F_i_l_e_2_  are the  same string or  both names  exist
    and  point to the  same file (due to  hard or symbolic links  and/or
    relative vs.  absolute paths).


eexxiissttss__ddiirreeccttoorryy((+_D_i_r_e_c_t_o_r_y_))
    Succeeds  if D_i_r_e_c_t_o_r_y_ exists.    This does not  imply the user  has
    read, search and or write permission for the directory.


ddeelleettee__ffiillee((+_F_i_l_e_))
    Unlink F_i_l_e_ from the Unix file system.


rreennaammee__ffiillee((+_F_i_l_e_1_,_ +_F_i_l_e_2_))
    Rename  F_i_l_e_1_ into F_i_l_e_2_.   Currently  files cannot be moved  across
    devices.


ssiizzee__ffiillee((+_F_i_l_e_,_ -_S_i_z_e_))
    Unify S_i_z_e_ with the size of F_i_l_e_ in characters.


ttiimmee__ffiillee((+_F_i_l_e_,_ -_T_i_m_e_))
    Unify  the last  modification time of  F_i_l_e_ with  T_i_m_e_.   T_i_m_e_ is  a
    floating  point number expressing the  seconds elapsed since Jan  1,
    1970.


aabbssoolluuttee__ffiillee__nnaammee((+_F_i_l_e_,_ -_A_b_s_o_l_u_t_e_))
    Expand  Unix file specification  into an absolute  path.  User  home
    directory  expansion (~ and ~<u_s_e_r_>) and variable expansion  is done.
    The  absolute  path  is canonised:    references  to .  and  ..  are
    deleted.   SWI-Prolog  uses absolute file  names to register  source
    files  independent  of the  current  working directory.    See  also
    aabbssoolluuttee__ffiillee__nnaammee//33.


aabbssoolluuttee__ffiillee__nnaammee((+_S_p_e_c_,_ +_O_p_t_i_o_n_s_,_ -_A_b_s_o_l_u_t_e_))
    Converts  the  given  file  specification  into  an  absolute  path.
    O_p_t_i_o_n_ is a list of options to guide the conformation process:

    eexxtteennssiioonnss((L_i_s_t_O_f_E_x_t_e_n_s_i_o_n_s_))
         List of  file-extensions to  try.   Default is  ''.   For  each
         extension, aabbssoolluuttee__ffiillee__nnaammee//33will first add the extension and
         then verify the  conditions imposed by the  other options.   If
         the condition fails, the  next extension of the list  is tried.
         Extensions may be specified both as ..ext or plain ext.

    aacccceessss((M_o_d_e_))
         Imposes the condition  access_file(F_i_l_e_, M_o_d_e_).   M_o_d_e_ is on  of
         read, write, append, exist or none.  See also aacccceessss__ffiillee//22.

    ffiillee__ttyyppee((T_y_p_e_))
         Defines  extensions.    Current  mapping:   txt  implies  [''],
         prolog  implies ['.pl', ''],  executable  implies  ['.so', ''],
         qlf implies ['.qlf', ''] and directory implies [''].

    ffiillee__eerrrroorrss((f_a_i_l_/_t_r_u_e_))
         Report if  the  path cannot  be resolved  or be  silent.    The
         default is to stay silent.

    ssoolluuttiioonnss((f_i_r_s_t_/_a_l_l_))
         If  first (default),  the  predicates leaves  no  choice-point.
         Otherwise a  choice-point  will be  left and  backtracking  may
         yield more solutions.


iiss__aabbssoolluuttee__ffiillee__nnaammee((+_F_i_l_e_))
    True  if F_i_l_e_ specifies  and absolute path-name.   On Unix  systems,
    this   implies  the  path  starts  with  a  `/'.      For  Microsoft
    based   systems  this  implies  the   path  starts  with  <l_e_t_t_e_r_>:.
    This   predicate   is  intended   to  provide   platform-independent
    checking  for  absolute paths.    See  also aabbssoolluuttee__ffiillee__nnaammee//22 and
    pprroolloogg__ttoo__ooss__ffiilleennaammee//22.


ffiillee__nnaammee__eexxtteennssiioonn((?_B_a_s_e_,_ ?_E_x_t_e_n_s_i_o_n_,_ ?_N_a_m_e_))
    This  predicate is used to add, remove or test  filename extensions.
    The  main reason  for  its introduction  is to  deal with  different
    filename  properties  in a  portable manner.    If  the file  system
    is   case-insensitive,  testing  for  an  extension  will   be  done
    case-insensitive too.   E_x_t_e_n_s_i_o_n_ may be specified with or without a
    leading  dot (.).  If an E_x_t_e_n_s_i_o_n_ is generated, it will  not have a
    leading dot.


eexxppaanndd__ffiillee__nnaammee((+_W_i_l_d_C_a_r_d_,_ -_L_i_s_t_))
    Unify  L_i_s_t_ with  a  sorted list  of files  or directories  matching
    W_i_l_d_C_a_r_d_.   The  normal Unix wildcard  constructs `?', `*',  `[...]'
    and  `{...}'  are  recognised.    The interpretation  of  `{...}'  is
    interpreted  slightly different  from  the C  shell (csh(1)).    The
    comma  separated  argument  can  be  arbitrary  patterns,  including
    `{...}'  patterns.   The empty  pattern is legal  as well:   `{.pl,}'
    matches either `.pl' or the empty string.


pprroolloogg__ttoo__ooss__ffiilleennaammee((?_P_r_o_l_o_g_P_a_t_h_,_ ?_O_s_P_a_t_h_))
    Converts  between the internal  Prolog pathname conventions and  the
    operating-system  pathname conventions.    The internal  conventions
    are  Unix and this predicates is  equivalent to =/2 (unify) on  Unix
    systems.   On  DOS systems it  will change the  directory-separator,
    limit  the filename length map dots,  except for the last one,  onto
    underscores.


rreeaadd__lliinnkk((+_F_i_l_e_,_ -_L_i_n_k_,_ -_T_a_r_g_e_t_))
    If F_i_l_e_ points to  a symbolic link, unify L_i_n_k_ with the value of the
    link and T_a_r_g_e_t_ to  the file the link is pointing to.  T_a_r_g_e_t_ points
    to  a file, directory or non-existing entry in the file  system, but
    never  to a link.   Fails if F_i_l_e_  is not a link.   Fails always  on
    systems that do not support symbolic links.


ttmmpp__ffiillee((+_B_a_s_e_,_ -_T_m_p_N_a_m_e_))
    Create  a name for a temporary file.  B_a_s_e_ is an  identifier for the
    category  of file.  The T_m_p_N_a_m_e_ is guaranteed to be unique.   If the
    system  halts, it  will automatically  remove all created  temporary
    files.


cchhddiirr((+_P_a_t_h_))
    Change working directory to P_a_t_h_.


33..3355 UUsseerr TToopplleevveell MMaanniippuullaattiioonn


bbrreeaakk
    Recursively  start a new  Prolog top level.   This Prolog top  level
    has its own  stacks, but shares the heap with all break environments
    and  the top level.  Debugging  is switched off on entering  a break
    and  restored on leaving one.   The break environment is  terminated
    by  typing the  system's end-of-file character  (control-D). If  the
    -t toplevel  command  line  option is  given  this goal  is  started
    instead of entering the default interactive top level (pprroolloogg//00).


aabboorrtt
    Abort  the Prolog  execution and  start a  new top  level.   If  the
    -t toplevel  command  line options  is given  this  goal is  started
    instead  of  entering the  default  interactive top  level.    Break
    environments  are aborted as  well.  All  open files except for  the
    terminal  related files are  closed.   The input- and output  stream
    again refers to u_s_e_r_.


hhaalltt
    Terminate  Prolog  execution.   Open  files are  closed  and if  the
    command  line option  -tty is  not active the  terminal status  (see
    Unix  stty(1)) is restored.  Hooks may be registered both  in Prolog
    and  in foreign code.  Prolog  hooks are registered using aatt__hhaalltt//11.
    hhaalltt//00 is equivalent to halt(0).


hhaalltt((+_S_t_a_t_u_s_))
    Terminate  Prolog  execution  with  given  status.    Status  is  an
    integer.  See also hhaalltt//00.


pprroolloogg
    This  goal starts the  default interactive top  level.  pprroolloogg//00  is
    terminated (succeeds) by typing control-D.

The following  two hooks allow  for expanding  queries and handling  the
result  of a  query.   These  hooks are  used by  the toplevel  variable
expansion mechanism described in section 2.5.


eexxppaanndd__qquueerryy((+_Q_u_e_r_y_,_ -_E_x_p_a_n_d_e_d_,_ +_B_i_n_d_i_n_g_s_,_ -_E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s_))
    Hook  in module  user, normally  not defined.    Q_u_e_r_y_ and  B_i_n_d_i_n_g_s_
    represents  the  query read  from  the user  and  the names  of  the
    free  variables as  obtained using rreeaadd__tteerrmm//33.   If this  predicate
    succeeds, it should  bind E_x_p_a_n_d_e_d_ and E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s_ to the query
    and  bindings  to be  executed  by the  toplevel.    This  predicate
    is  used by the toplevel  (pprroolloogg//00).   See also eexxppaanndd__aannsswweerr//22 and
    tteerrmm__eexxppaannssiioonn//22.


eexxppaanndd__aannsswweerr((+_B_i_n_d_i_n_g_s_,_ -_E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s_))
    Hook  in module user,  normally not defined.   Expand the result  of
    a  successfully executed  toplevel  query.   B_i_n_d_i_n_g_s_  is the  query
    <N_a_m_e_>= <V_a_l_u_e_>binding list  from the query.  E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s_ must
    be unified with the bindings the toplevel should print.


33..3366 CCrreeaattiinngg aa PPrroottooccooll ooff tthhee UUsseerr IInntteerraaccttiioonn

SWI-Prolog offers the  possibility to log the interaction with  the user
on  a file.    All  Prolog interaction,  including warnings  and  tracer
output, are written on the protocol file.


pprroottooccooll((+_F_i_l_e_))
    Start  protocolling on file  F_i_l_e_.  If  there is already a  protocol
    file open then close it first.  If F_i_l_e_ exists it is truncated.


pprroottooccoollaa((+_F_i_l_e_))
    Equivalent  to pprroottooccooll//11,  but  does not  truncate the  F_i_l_e_ if  it
    exists.


nnoopprroottooccooll
    Stop  making a protocol of the user interaction.  Pending  output is
    flushed on the file.


pprroottooccoolllliinngg((-_F_i_l_e_))
    Succeeds  if a protocol was  started with pprroottooccooll//11 or  pprroottooccoollaa//11
    and unifies F_i_l_e_ with the current protocol output file.


33..3377 DDeebbuuggggiinngg aanndd TTrraacciinngg PPrrooggrraammss


ttrraaccee
    Start  the tracer.   ttrraaccee//00  itself cannot be  seen in the  tracer.
    Note  that  the Prolog  toplevel treats  ttrraaccee//00 special;  it  means
    `trace the next goal'.


ttrraacciinngg
    Succeeds  when  the tracer  is  currently switched  on.    ttrraacciinngg//00
    itself can not be seen in the tracer.


nnoottrraaccee
    Stop the tracer.  nnoottrraaccee//00 itself cannot be seen in the tracer.


ttrraaccee((+_P_r_e_d_))
    Equivalent to trace(Pred, +all).


ttrraaccee((+_P_r_e_d_,_ +_P_o_r_t_s_))
    Put  a  trace-point  on  all  predicates  satisfying  the  predicate
    specification  P_r_e_d_.   P_o_r_t_s_  is a  list of  portnames (call,  redo,
    exit,  fail).   The atom all refers  to all ports.   If the port  is
    preceded  by a - sign the trace-point  is cleared for the port.   If
    it is preceded by a + the trace-point is set.

    The  predicate ttrraaccee//22  activates debug  mode (see ddeebbuugg//00).    Each
    time  a port (of the 4-port model) is passed that has  a trace-point
    set  the goal is printed as  with ttrraaccee//00.  Unlike ttrraaccee//00  however,
    the  execution is continued without asking for  further information.
    Examples:

        ?- trace(hello).         Trace all  ports of hello  with any
                                 arity in any module.
        ?- trace(foo/2, +fail).  Trace  failures  of  foo/2  in  any
                                 module.
        ?- trace(bar/1, -all).   Stop tracing bar/1.

    The predicate ddeebbuuggggiinngg//00 shows all currently defined trace-points.


nnoottrraaccee((+_G_o_a_l_))
    Call  G_o_a_l_,  but  suspend  the  debugger while  G_o_a_l_  is  executing.
    The  current  implementation cuts  the  choicepoints of  G_o_a_l_  after
    successful completion.   See oonnccee//11.  Later implementations may have
    the same semantics as ccaallll//11.


ddeebbuugg
    Start debugger (stop at spy points).


nnooddeebbuugg
    Stop debugger (do not trace, nor stop at spy points).


ddeebbuuggggiinngg
    Print debug status and spy points on current output stream.


ssppyy((+_P_r_e_d_))
    Put   a  spy   point  on  all   predicates  meeting  the   predicate
    specification P_r_e_d_.  See section 3.3.


nnoossppyy((+_P_r_e_d_))
    Remove   spy  point  from  all  predicates  meeting   the  predicate
    specification P_r_e_d_.


nnoossppyyaallll
    Remove all spy points from the entire program.


lleeaasshh((?_P_o_r_t_s_))
    Set/query leashing (ports  which allow for user interaction).  P_o_r_t_s_
    is  one of +_N_a_m_e_, -_N_a_m_e_,  ?_N_a_m_e_ or a list  of these.  +_N_a_m_e_  enables
    leashing  on that  port,  -_N_a_m_e_ disables  it and  ?_N_a_m_e_ succeeds  or
    fails  according to  the  current setting.    Recognised ports  are:
    call, redo, exit,  fail and unify.  The special shorthand all refers
    to  all ports, full  refers to all ports  except for the unify  port
    (default).  half refers to the call, redo and fail port.


vviissiibbllee((+_P_o_r_t_s_))
    Set the ports shown  by the debugger.  See lleeaasshh//11 for a description
    of the port specification.  Default is full.


uunnkknnoowwnn((-_O_l_d_,_ +_N_e_w_))
    Unify  O_l_d_  with  the current  value  of  the unknown  system  flag.
    On  success  N_e_w_  will be  used  to specify  the  new  value.    N_e_w_
    should  be  instantiated  to either  fail  or trace  and  determines
    the  interpreters action  when an undefined  predicate which is  not
    declared  dynamic  is encountered  (see ddyynnaammiicc//11).    fail  implies
    the  predicate  just  fails silently.     trace implies  the  tracer
    is  started.    Default is  trace.   The  unknown flag  is local  to
    each  module and uunnkknnoowwnn//22  is module  transparent.   Using it as  a
    directive  in a module  file will only  change the unknown flag  for
    that  module.   Using the  :/2 construct  the behaviour on  trapping
    an  undefined predicate can  be changed for any  module.  Note  that
    if  the unknown flag  for a module equals  fail the system will  not
    call  eexxcceeppttiioonn//33 and will nnoott try to resolve the predicate  via the
    dynamic  library system.   The system will  still try to import  the
    predicate from the public module.


ssttyyllee__cchheecckk((+_S_p_e_c_))
    Set  style checking options.   S_p_e_c_  is either  +<o_p_t_i_o_n_>, -<o_p_t_i_o_n_>,
    ?<o_p_t_i_o_n_>  or a  list  of such  options.    +<o_p_t_i_o_n_> sets  a  style
    checking option,  -<o_p_t_i_o_n_>clears it and ?<o_p_t_i_o_n_> succeeds or fails
    according to the  current setting.  ccoonnssuulltt//11 and derivatives resets
    the  style checking options to their value before loading  the file.
    If---for  example---a file  containing long atoms  should be  loaded
    the user can start the file with:

    :- style_check(-atom).

    Currently available options are:

    ____________________________________________________________________
    |_Name__________|Default_|Description_______________________________||singletonon|  ||

    |                         rreeaadd__ccllaauussee//11 (used by  ccoonnssuulltt//11)  warns |               ||
    |                         on variables  only  appearing once  in  a |               ||
    |                         term  (clause)  which  have  a  name  not |               ||

    ||atom          |  on    |starting with an underscore.              ||              ||

    |               |        |rreeaadd//11 and  derivatives will  produce  an |
    |               |        |error message on quoted atoms or  strings |
    |               |        |longer than 5 lines.                      |
    | dollar        |  off   |Accept dollar as a lower case  character, |
    |               |        |thus avoiding the need for quoting  atoms |
    |               |        |with dollar  signs.   System  maintenance |
    |               |        |use only.                                 |
    | discontiguous |  on    |Warn if the clauses  for a predicate  are |

    |               |        |not together in the same source file.     |
    | string        |  off   |Read  and  derivatives  transform   "..." |
    |               |        |into a prolog  string instead  of a  list |
    |_______________|________|of_ASCII_characters.______________________|


33..3388 OObbttaaiinniinngg RRuunnttiimmee SSttaattiissttiiccss


ssttaattiissttiiccss((+_K_e_y_,_ -_V_a_l_u_e_))
    Unify system statistics  determined by K_e_y_ with V_a_l_u_e_.  The possible
    keys are given in the table 3.2.
     _______________________________________________________________
     | cputime     |(User)  cpu time  since Prolog  was started  in|
     |             |seconds                                        |
     | inferences  |Total number  of passes via  the call and  redo|
     |             |ports since Prolog was started.                |
     | heap        |Estimated   total  size   of   the  heap   (see|

     |             |section 2.13.1.1)                              |
     | heapused    |Bytes heap in use by Prolog.                   |
     | heaplimit   |Maximum   size   of   the    heap   (see   sec-|
     |             |tion 2.13.1.1)                                 |
     | local       |Allocated size of the local stack in bytes.    |
     | localused   |Number of bytes in use on the local stack.     |
     | locallimit  |Size to  which the  local stack  is allowed  to|
     |             |grow                                           |

     | global      |Allocated size of the global stack in bytes.   |
     | globalused  |Number of bytes in use on the global stack.    |
     | globallimit |Size to  which the global  stack is allowed  to|
     |             |grow                                           |
     | trail       |Allocated size of the trail stack in bytes.    |
     | trailused   |Number of bytes in use on the trail stack.     |
     | traillimit  |Size to  which the  trail stack  is allowed  to|

     |             |grow                                           |
     | atoms       |Total number of defined atoms.                 |
     | functors    |Total number of defined name/arity pairs.      |
     | predicates  |Total number of predicate definitions.         |
     | modules     |Total number of module definitions.            |
     |_codes_______|Total_amount_of_byte_codes_in_all_clauses._____|_

                   Table 3.2:  Keys for ssttaattiissttiiccss//22


ssttaattiissttiiccss
    Display a table of system statistics on the current output stream.


ttiimmee((+_G_o_a_l_))
    Execute  G_o_a_l_  just like  oonnccee//11 (i.e.  leaving  no choice  points),
    but  print used time, number  of logical inferences and the  average
    number  of  l_i_p_s_  (logical  inferences  per  second).     Note  that
    SWI-Prolog  counts the actual  executed number of inferences  rather
    than  the number of passes through  the call- and redo ports of  the
    theoretical 4-port model.


33..3399 FFiinnddiinngg PPeerrffoorrmmaannccee BBoottttlleenneecckkss

SWI-Prolog  offers  a  statistical  program  profiler  similar  to  Unix
prof(1) for C  and some other languages.   A profiler is used as  an aid
to find performance  pigs in programs.   It provides information on  the
time spent in the various Prolog predicates.

The  profiler  is  based  on the  assumption  that  if  we  monitor  the
functions on  the execution stack  on time  intervals not correlated  to
the program's execution the  number of times we find a procedure  on the
environment stack  is a  measure of  the time spent  in this  procedure.
It  is implemented  by calling  a procedure  each time  slice Prolog  is
active.   This procedure  scans the local stack  and either just  counts
the procedure on top  of this stack (plain profiling) or  all procedures
on  the stack  (cumulative profiling).    To get  accurate results  each
procedure  one is  interested  in should  have  a reasonable  number  of
counts.    Typically  a  minute runtime  will  suffice  to get  a  rough
overview of the most expensive procedures.


pprrooffiillee((+_G_o_a_l_,_ +_S_t_y_l_e_,_ +_N_u_m_b_e_r_))
    Execute  G_o_a_l_  just  like  ttiimmee//11.    Collect  profiling  statistics
    according  to  style  (see  pprrooffiilleerr//22)  and  show  the  top  N_u_m_b_e_r_
    procedures  on  the  current  output  stream  (see  sshhooww__pprrooffiillee//11).
    The  results  are kept  in  the database  until  rreesseett__pprrooffiilleerr//00 or
    pprrooffiillee//33  is called and can be displayed again with sshhooww__pprrooffiillee//11.
    pprrooffiillee//33 is the normal  way to invoke the profiler.  The predicates
    below are low-level predicates that can be used for special cases.


sshhooww__pprrooffiillee((+_N_u_m_b_e_r_))
    Show  the collected  results of the  profiler.   Stops the  profiler
    first  to avoid interference from sshhooww__pprrooffiillee//11.  It shows  the top
    N_u_m_b_e_r_ predicates according the percentage cpu-time used.


pprrooffiilleerr((-_O_l_d_,_ +_N_e_w_))
    Query  or change  the status of  the profiler.   The  status is  one
    of  off,  plain or  cumulative.    plain implies  the  time used  by
    children  of a predicate is not added to the time of  the predicate.
    For  status cumulative  the time  of children is  added (except  for
    recursive  calls).     Cumulative profiling  implies  the  stack  is
    scanned  up  to the  top  on  each time  slice  to find  all  active
    predicates.    This implies the  overhead grows  with the number  of
    active  frames on the stack.  Cumulative profiling  starts debugging
    mode  to disable tail recursion optimisation, which  would otherwise
    remove  the necessary  parent environments.   Switching status  from
    plain  to cumulative  resets the profiler.    Switching to and  from
    status  off does not reset  the collected statistics, thus  allowing
    to suspend profiling for certain parts of the program.


rreesseett__pprrooffiilleerr
    Switches the profiler to off and clears all collected statistics.


pprrooffiillee__ccoouunntt((+_H_e_a_d_,_ -_C_a_l_l_s_,_ -_P_r_o_m_i_l_a_g_e_))
    Obtain profile statistics  of the predicate specified by H_e_a_d_.  H_e_a_d_
    is  an atom  for predicates with  arity 0  or a term  with the  same
    name  and arity as the predicate required (see ccuurrrreenntt__pprreeddiiccaattee//22).
    C_a_l_l_s_  is unified with the number  of `calls' and `redos' while  the
    profiler was active.   P_r_o_m_i_l_a_g_e_ is unified with the relative number
    of  counts the predicate  was active (cumulative)  or on top of  the
    stack (plain).  P_r_o_m_i_l_a_g_e_ is an integer between 0 and 1000.


33..4400 MMeemmoorryy MMaannaaggeemmeenntt

Note:   lliimmiitt__ssttaacckk//22and  ttrriimm__ssttaacckkss//00have no  effect on machines  that
do  not  offer  dynamic  stack expansion.     On  these  machines  these
predicates simply succeed to improve portability.


ggaarrbbaaggee__ccoolllleecctt
    Invoke  the global-  and trail  stack garbage collector.    Normally
    the  garbage   collector  is  invoked  automatically  if  necessary.
    Explicit  invocation  might   be  useful  to  reduce  the  need  for
    garbage  collections in time critical segments  of the code.   After
    the  garbage  collection  ttrriimm__ssttaacckkss//00 is invoked  to  release  the
    collected memory resources.


lliimmiitt__ssttaacckk((+_K_e_y_,_ +_K_b_y_t_e_s_))
    Limit one of the  stack areas to the specified value.  K_e_y_ is one of
    local,  global or trail.   The limit  is an integer, expressing  the
    desired  stack limit in K  bytes.  If  the desired limit is  smaller
    than  the currently  used value,  the limit  is set  to the  nearest
    legal  value above the currently used  value.  If the desired  value
    is  larger than the maximum, the maximum is taken.  Finally,  if the
    desired value is either  0 or the atom unlimited the limit is set to
    its  maximum.   The maximum and initial  limit is determined by  the
    command line options -L, -G and -T.


ttrriimm__ssttaacckkss
    Release  stack memory resources that are not in use at  this moment,
    returning them to the  operating system.  Trim stack is a relatively
    cheap  call.    It can  be used  to release  memory  resources in  a
    backtracking  loop, where the  iterations require typically  seconds
    of execution time  and very different, potentially large, amounts of
    stack space.  Such a loop should be written as follows:

    loop :-
            generator,
                trim_stacks,
                potentially_expensive_operation,
            stop_condition, !.

    The  prolog top level  loop is written  this way, reclaiming  memory
    resources after every user query.


ssttaacckk__ppaarraammeetteerr((+_S_t_a_c_k_,_ +_K_e_y_,_ -_O_l_d_,_ +_N_e_w_))
    Query/set  a parameter  for the  runtime stacks.   S_t_a_c_k_  is one  of
    local,  global, trail or  argument.   The table below describes  the
    K_e_y_/V_a_l_u_e_ pairs.  Old is first unified with the current value.

        ____________________________________________________________
        | limit    |Maximum size of the stack in bytes               |
        |_min_free_|Minimum_free_space_at_entry_of_foreign_predicate_|

    This predicate is  currently only available on versions that use the
    stack-shifter  to enlarge the runtime  stacks when necessary.   It's
    definition is subject to change.


33..4411 WWiinnddoowwss DDDDEE iinntteerrffaaccee

The  predicates in  this  section  deal with  MS-Windows  `Dynamic  Data
Exchange'  or DDE  protocol.    A Windows  DDE  conversation is  a  form
of interprocess  communication based  on sending reserved  window-events
between the communicating processes.

See also section 5.4 for loading Windows DLL's into SWI-Prolog.


33..4411..11 DDDDEE cclliieenntt iinntteerrffaaccee

The DDE client interface  allows Prolog to talk to DDE  server programs.
We  will demonstrate  the use  of the  DDE interface  using the  Windows
PROGMAN (Program Manager) application:

1 ?- open_dde_conversation(progman, progman, C).

C = 0
2 ?- dde_request(0, groups, X)

--> Unifies X with description of groups

3 ?- dde_execute(0, '[CreateGroup("DDE Demo")]').

Yes

4 ?- close_dde_conversation(0).

Yes

For  details   on  interacting  with   progman,   use  the  SDK   online
manual  section on  the  Shell  DDE interface.     See also  the  Prolog
library(progman),  which  may be  used  to  write simple  Windows  setup
scripts in Prolog.


ooppeenn__ddddee__ccoonnvveerrssaattiioonn((+_S_e_r_v_i_c_e_,_ +_T_o_p_i_c_,_ -_H_a_n_d_l_e_))
    Open a conversation  with a server supporting the given service name
    and  topic (atoms).    If successful,  H_a_n_d_l_e_  may be  used to  send
    transactions  to the server.    If no willing  server is found  this
    predicate fails silently.


cclloossee__ddddee__ccoonnvveerrssaattiioonn((+_H_a_n_d_l_e_))
    Close  the  conversation   associated  with  H_a_n_d_l_e_.     All  opened
    conversations  should  be  closed  when they're  no  longer  needed,
    although  the system  will  close any  that remain  open on  process
    termination.


ddddee__rreeqquueesstt((+_H_a_n_d_l_e_,_ +_I_t_e_m_,_ -_V_a_l_u_e_))
    Request  a value from the server.   I_t_e_m_ is an atom  that identifies
    the  requested  data,  and  V_a_l_u_e_ will  be  a string  (CF_TEXT  data
    in  DDE  parlance)  representing  that  data,   if  the  request  is
    successful.    If unsuccessful, V_a_l_u_e_  will be  unified with a  term
    of  form error(<R_e_a_s_o_n_>),  identifying the problem.   This call  uses
    SWI-Prolog  string objects  to return  the value  rather then  atoms
    to  reduce the  load on  the atom-space.    See section  3.20 for  a
    discussion on this data type.


ddddee__eexxeeccuuttee((+_H_a_n_d_l_e_,_ +_C_o_m_m_a_n_d_))
    Request  the  DDE   server  to  execute  the  given  command-string.
    Succeeds  if the  command  could be  executed and  fails with  error
    message otherwise.


ddddee__ppookkee((+_H_a_n_d_l_e_,_ +_I_t_e_m_,_ +_C_o_m_m_a_n_d_))
    Issue  a POKE command to the server on the specified I_t_e_m_.   Command
    is passed as data of type CF_TEXT.


33..4411..22 DDDDEE sseerrvveerr mmooddee

The (autoload)  library(dde) defines  primitives to  realise simple  DDE
server applications in  SWI-Prolog.  These  features are provided as  of
version 2.0.6 and should be regarded prototypes.  The  C-part of the DDE
server can  handle some  more primitives,  so if you  need features  not
provided by this interface, please study library(dde).


ddddee__rreeggiisstteerr__sseerrvviiccee((+_T_e_m_p_l_a_t_e_,_ +_G_o_a_l_))
    Register  a server  to handle  DDE request or  DDE execute  requests
    from  other applications.  To register a service for a  DDE request,
    T_e_m_p_l_a_t_e_ is of the form:

         +Service(+Topic, +Item, +Value)

    S_e_r_v_i_c_e_  is the name  of the DDE  service provided (like progman  in
    the  client example  above).   T_o_p_i_c_ is either  an atom,  indicating
    G_o_a_l_  only handles requests  on this topic  or a variable that  also
    appears  in G_o_a_l_.  I_t_e_m_ and V_a_l_u_e_ are variables that also  appear in
    G_o_a_l_.

    The  example below  registers the Prolog  ffeeaattuurree//22 predicate to  be
    accessible  from other applications.  The request may be  given from
    the same Prolog as well as from another application.

    ?- dde_register_service(prolog(feature, F, V),
                            feature(F, V)).

    ?- open_dde_conversation(prolog, feature, Handle),
       dde_request(Handle, home, Home),
       close_dde_conversation(Handle).

    Home = '/usr/local/lib/pl-2.0.6/'

    Handling  DDE execute requests  is very similar.   In this case  the
    template is of the form:

         +Service(+Topic, +Item)

    Passing  a V_a_l_u_e_ argument is  not needed as execute requests  either
    succeed  or fail.  If G_o_a_l_  fails, a `not processed' is  passed back
    to the caller of the DDE request.


ddddee__uunnrreeggiisstteerr__sseerrvviiccee((+_S_e_r_v_i_c_e_))
    Stop  responding  to  S_e_r_v_i_c_e_.     If  Prolog  is  halted,  it  will
    automatically call this on all open services.


ddddee__ccuurrrreenntt__sseerrvviiccee((-_S_e_r_v_i_c_e_,_ -_T_o_p_i_c_))
    Find currently registered services and the topics served on them.


ddddee__ccuurrrreenntt__ccoonnnneeccttiioonn((-_S_e_r_v_i_c_e_,_ -_T_o_p_i_c_))
    Find currently open conversations.


33..4422 MMiisscceellllaanneeoouuss


ddwwiimm__mmaattcchh((+_A_t_o_m_1_,_ +_A_t_o_m_2_))
    Succeeds  if A_t_o_m_1_ matches A_t_o_m_2_  in `Do What I  Mean' sense.   Both
    A_t_o_m_1_  and A_t_o_m_2_  may also be  integers or  floats.   The two  atoms
    match if:

      o  They are identical

      o  They differ by one character (spy  spu)

      o  One character is inserted/deleted (debug  deug)

      o  Two characters are transposed (trace  tarce)

      o  `Sub-words' are glued  differently (existsfile   existsFile
         exists_file)

      o  Two   adjacent  sub   words  are   transposed   (existsFile
         fileExists)


ddwwiimm__mmaattcchh((+_A_t_o_m_1_,_ +_A_t_o_m_2_,_ -_D_i_f_f_e_r_e_n_c_e_))
    Equivalent  to  ddwwiimm__mmaattcchh//22,  but unifies  D_i_f_f_e_r_e_n_c_e_ with  an  atom
    identifying the the  difference between A_t_o_m_1_ and A_t_o_m_2_.  The return
    values  are (in the same  order as above):   equal, mismatched_char,
    inserted_char, transposed_char, separated and transposed_word.


wwiillddccaarrdd__mmaattcchh((+_P_a_t_t_e_r_n_,_ +_S_t_r_i_n_g_))
    Succeeds  if S_t_r_i_n_g_ matches the  wildcard pattern P_a_t_t_e_r_n_.   P_a_t_t_e_r_n_
    is very similar the  the Unix csh pattern matcher.  The patterns are
    given below:

     ?      Matches one arbitrary character.

     *      Matches any number of arbitrary characters.
     [...]  Matches one of the characters specified between the brackets.  <c_h_a_r_1_>-<c_h_a_r_2_>indicates a range.
     {...}  Matches any of the patterns of the comma separated list between the braces.

    Example:

    ?- wildcard_match('[a-z]*.{pro,pl}[%~]', 'a_hello.pl%').

    Yes.


ggeennssyymm((+_B_a_s_e_,_ -_U_n_i_q_u_e_))
    Generate  a unique  atom from base  B_a_s_e_ and  unify it with  U_n_i_q_u_e_.
    B_a_s_e_  should be an  atom.  The  first call will  return <b_a_s_e_>1,  the
    next  <b_a_s_e_>2, etc.   Note that this is  no warrant that the atom  is
    unique in the system.


sslleeeepp((+_T_i_m_e_))
    Suspend  execution T_i_m_e_ seconds.   T_i_m_e_  is either a floating  point
    number  or an  integer.   Granularity is  dependent on the  system's
    timer  granularity.   A  negative time  causes the  timer to  return
    immediately.   On  most non-realtime operating  systems we can  only
    ensure execution is suspended for aatt lleeaasstt T_i_m_e_ seconds.


CChhaapptteerr 44..  UUSSIINNGG MMOODDUULLEESS


44..11 WWhhyy UUssiinngg MMoodduulleess??

In  traditional Prolog  systems the  predicate  space was  flat.    This
approach   is  not   very  suitable   for  the   development  of   large
applications, certainly not if these applications are  developed by more
than  one programmer.     In many  cases,  the  definition of  a  Prolog
predicate requires  sub-predicates that  are intended  only to  complete
the definition of the main predicate.  With a  flat and global predicate
space these support predicates will be visible from the entire program.

For this reason,  it is desirable that  each source module has it's  own
predicate space.    A module consists  of a  declaration for it's  name,
it's p_u_b_l_i_c_  p_r_e_d_i_c_a_t_e_s_ and the  predicates themselves.   This  approach
allow the programmer  to use short (local) names for  support predicates
without worrying  about name  conflicts with the  support predicates  of
other  modules.    The  module  declaration also  makes  explicit  which
predicates are  meant for public usage  and which for private  purposes.
Finally,  using the  module information,  cross  reference programs  can
indicate possible problems much better.


44..22 NNaammee--bbaasseedd vveerrssuuss PPrreeddiiccaattee--bbaasseedd MMoodduulleess

Two approaches to  realize a module system  are commonly used in  Prolog
and other  languages.  The  first one is  the n_a_m_e_ b_a_s_e_d_ module  system.
In these  systems, each  atom read  is tagged  (normally prefixed)  with
the module  name, with  the exception  of those atoms  that are  defined
p_u_b_l_i_c_.   In the  second approach, each  module actually implements  its
own predicate space.

A  critical  problem with  using  modules  in Prolog  is  introduced  by
the  meta-predicates  that  transform between  Prolog  data  and  Prolog
predicates.  Consider the case where we write:

:- module(extend, [add_extension/3]).

add_extension(Extension, Plain, Extended) :-
        maplist(extend_atom(Extension), Plain, Extended).

extend_atom(Extension, Plain, Extended) :-
        concat(Plain, Extension, Extended).

In this case  we would like maplist to  call extend_atom/3 in the  module
extend.   A name based module  system will do this  correctly.  It  will
tag the atom  extend_atom  with the module and  maplist will use this  to
construct the tagged  term extend_atom/3.   A name based module  however,
will not only tag the  atoms that will eventually be used to refer  to a
predicate, but aallll atoms that are not declared public.   So, with a name
based module system also  data is local to the module.   This introduces
another serious problem:

:- module(action, [action/3]).

action(Object, sleep, Arg) :- ....
action(Object, awake, Arg) :- ....

:- module(process, [awake_process/2]).

awake_process(Process, Arg) :-
        action(Process, awake, Arg).

This code  uses a simple  object-oriented implementation technique  were
atoms are used as  method selectors.  Using a name based  module system,
this code will  not work, unless we  declare the selectors public  atoms
in all  modules that use them.   Predicate  based module systems do  not
require particular precautions for handling this case.

It  appears  we  have to  choose  either  to  have  local  data,  or  to
have  trouble with  meta-predicates.    Probably it  is best  to  choose
for  the  predicate  based approach  as  novice  users  will  not  often
write  generic meta-predicates  that  have to  be used  across  multiple
modules, but are likely  to write programs that pass data  around across
modules.   Experienced Prolog  programmers should be  able to deal  with
the complexities of meta-predicates in a predicate based module system.


44..33 DDeeffiinniinngg aa MMoodduullee

Modules normally are  created by loading a m_o_d_u_l_e_  f_i_l_e_.  A module  file
is a file holding a mmoodduullee//22 directive as its first term.   The mmoodduullee//22
directive declares  the name  and the public  (i.e. externally  visible)
predicates of  the module.   The  rest of  the file is  loaded into  the
module.  Below is an example of a module file, defining rreevveerrssee//22.

:- module(reverse, [reverse/2]).

reverse(List1, List2) :-
        rev(List1, [], List2).

rev([], List, List).
rev([Head|List1], List2, List3) :-
        rev(List1, [Head|List2], List3).


44..44 IImmppoorrttiinngg PPrreeddiiccaatteess iinnttoo aa MMoodduullee

As  explained  before,  in  the  predicate  based  approach  adapted  by
SWI-Prolog, each  module has it's own predicate  space.  In  SWI-Prolog,
a module  initially is  completely empty.   Predicates  can be added  to
a  module by  loading a  module  file as  demonstrated in  the  previous
section, using assert or by i_m_p_o_r_t_i_n_g_ them from another module.

Two mechanisms for  importing predicates explicitly from another  module
exist.   The uussee__mmoodduullee//[[11,,22]] predicates load a  module file and  import
(part of  the) public predicates  of the file.   The iimmppoorrtt//11  predicate
imports any predicate from any module.


uussee__mmoodduullee((+_F_i_l_e_))
    Load  the  file(s) specified  with F_i_l_e_  just  like eennssuurree__llooaaddeedd//11.
    The  files should  all be  module files.    All exported  predicates
    from  the  loaded  files  are  imported  into  the  context  module.
    The  difference between  this predicate and  eennssuurree__llooaaddeedd//11 becomes
    apparent  if the file  is already  loaded into another  module.   In
    this  case eennssuurree__llooaaddeedd//11 does nothing; use_module will import  all
    public predicates of the module into the current context module.


uussee__mmoodduullee((+_F_i_l_e_,_ +_I_m_p_o_r_t_L_i_s_t_))
    Load  the file  specified  with F_i_l_e_  (only one  file is  accepted).
    F_i_l_e_  should be a module file.   I_m_p_o_r_t_L_i_s_t_ is a list  of name/arity
    pairs  specifying the  predicates that should  be imported from  the
    loaded  module.   If a predicate is  specified that is not  exported
    from  the loaded module  a warning will be  printed.  The  predicate
    will nevertheless be imported to simplify debugging.


iimmppoorrtt((+_H_e_a_d_))
    Import predicate H_e_a_d_  into the current context module.  H_e_a_d_ should
    specify the  source module using the <m_o_d_u_l_e_>:<t_e_r_m_>construct.  Note
    that  predicates are normally imported  using one of the  directives
    uussee__mmoodduullee//[[11,,22]].    iimmppoorrtt//11 is  meant  for handling  imports  into
    dynamically created modules.

It  would  be rather  inconvenient  to  have to  import  each  predicate
referred to by  the module, including the  system predicates.  For  this
reason each  module is  assigned a d_e_f_a_u_l_t_  m_o_d_u_l_e_.   All predicates  in
the default  module are  available without  extra declarations.    Their
definition however can be overruled in the local module.   This schedule
is implemented  by the exception handling  mechanism of SWI-Prolog:   if
an  undefined predicate  exception is  raised for  a  predicate in  some
module, the exception  handler first tries to import the  predicate from
the module's default module.  On success, normal execution is resumed.


44..44..11 RReesseerrvveedd MMoodduulleess

SWI-Prolog contains two  special modules.   The first one is the  module
system.    This module  contains all  built-in  predicates described  in
this  manual.   Module  system has  no default  module  assigned to  it.
The second  special module is the  module user.   This module forms  the
initial  working space  of the  user.    Initially  it is  empty.    The
default module of module  user is system, making all  built-in predicate
definitions available  as defaults.    Built-in predicates  thus can  be
overruled by defining them in module user before they are used.

All other  modules default to module  user.   This implies they can  use
all predicates imported into user without explicitly importing them.


44..55 UUssiinngg tthhee MMoodduullee SSyysstteemm

The  current structure  of  the module  system  has been  designed  with
some specific  organisations for  large programs  in mind.   Many  large
programs  define a  basic  library layer  on  top  of which  the  actual
program itself  is defined.    The module  user, acting  as the  default
module for all  other modules of the  program can be used to  distribute
these definitions over  all program module without introducing the  need
to  import this  common layer  each time  explicitly.   It  can also  be
used to  redefine built-in predicates  if this  is required to  maintain
compatibility  to some  other Prolog  implementation.    Typically,  the
loadfile of a large application looks like this:

:- use_module(compatibility).   % load XYZ prolog compatibility

:- use_module(                  % load generic parts
        [ error                 % errors and warnings
        , goodies               % general goodies (library extensions)
        , debug                 % application specific debugging
        , virtual_machine       % virtual machine of application
        , ...                   % more generic stuff
        ]).

:- ensure_loaded(
        [ ...                   % the application itself
        ]).

The  `use_module' declarations  will  import the  public predicates  from
the  generic  modules  into  the  user  module.     The  `ensure_loaded'
directive  loads the  modules that  constitute  the actual  application.
It is  assumed these  modules import  predicates from  each other  using
uussee__mmoodduullee//[[11,,22]]as far as necessary.

In combination  with the  object-oriented schema described  below it  is
possible  to define  a neat  modular  architecture.   The  generic  code
defines general utilities  and the message passing predicates  (invoke/3
in the  example below).    The application modules  define classes  that
communicate using the message passing predicates.


44..55..11 OObbjjeecctt OOrriieenntteedd PPrrooggrraammmmiinngg

Another typical  way to use  the module system  is for defining  classes
within  an object  oriented  paradigm.    The  class structure  and  the
methods  of  a class  can  be  defined  in a  module  and  the  explicit
module-boundary overruling  describes in  section 4.6.2 can  by used  by
the message passing  code to invoke the behaviour.   An outline of  this
mechanism is given below.

%       Define class point

:- module(point, []).           % class point, no exports

%        name           type,           default access
%                                       value

variable(x,             integer,        0,      both).
variable(y,             integer,        0,      both).

%         method name   predicate name  arguments

behaviour(mirror,       mirror,         []).

mirror(P) :-
        fetch(P, x, X),
        fetch(P, y, Y),
        store(P, y, X),
        store(P, x, Y).

The predicates fetch/3  and store/3 are predicates that change  instance
variables of instances.  The figure below indicates  how message passing
can easily be implemented:

%       invoke(+Instance, +Selector, ?ArgumentList)
%       send a message to an instance

invoke(I, S, Args) :-
        class_of_instance(I, Class),
        Class:behaviour(S, P, ArgCheck), !,
        convert_arguments(ArgCheck, Args, ConvArgs),
        Goal =.. [P|ConvArgs],
        Class:Goal.

The construct  <M_o_d_u_l_e_>:<G_o_a_l_> explicitly  calls G_o_a_l_  in module  M_o_d_u_l_e_.
It is discussed in more detail in section 3.7.


44..66 MMeettaa--PPrreeddiiccaatteess iinn MMoodduulleess

As indicated  in the introduction,  the problem  with a predicate  based
module system lies in the difficulty to find the  correct predicate from
a Prolog  term.   The predicate `solution(Solution)'  can exist in  more
than one  module, but `assert(solution(4))'  in some module is  supposed
to refer to the correct version of solution/1.

Various  approaches are  possible to  solve this  problem.    One is  to
add an extra  argument to all predicates (e.g. `assert(Module,  Term)').
Another is to tag  the term somehow to indicate which module  is desired
(e.g. `assert(Module:Term)').   Both approaches are not very  attractive
as  they make  the user  responsible for  choosing  the correct  module,
inviting  unclear  programming by  asserting  in  other modules.     The
predicate aasssseerrtt//11  is supposed  to assert  in the module  it is  called
from and should do  so without being told explicitly.  For  this reason,
the notion c_o_n_t_e_x_t_ m_o_d_u_l_e_ has been introduced.


44..66..11 DDeeffiinniittiioonn aanndd CCoonntteexxtt MMoodduullee

Each  predicate  of  the program  is  assigned  a  module,  called  it's
d_e_f_i_n_i_t_i_o_n_ m_o_d_u_l_e_.   The definition module of a predicate is  always the
module in which the predicate was originally defined.   Each active goal
in the Prolog system has a c_o_n_t_e_x_t_ m_o_d_u_l_e_ assigned to it.

The  context module  is used  to  find predicates  from a  Prolog  term.
By  default, this  module  is the  definition  module of  the  predicate
running the  goal.   For meta-predicates  however, this  is the  context
module of the  goal that invoked them.   We call this m_o_d_u_l_e___t_r_a_n_s_p_a_r_e_n_t_
in SWI-Prolog.    In the `using  maplist' example  above, the  predicate
mmaapplliisstt//33  is declared  module_transparent.    This  implies the  context
module remains extend, the  context module of add_extension/3.   This way
mmaapplliisstt//33 can decide to call extend_atom in module extend rather than in
it's own definition module.

All built-in predicates that  refer to predicates via a Prolog  term are
declared module_transparent.  Below is the code defining maplist.

:- module(maplist, maplist/3).

:- module_transparent maplist/3.

%       maplist(+Goal, +List1, ?List2)
%       True if Goal can successfully be applied to all succes-
sive pairs
%       of elements of List1 and List2.

maplist(_, [], []).
maplist(Goal, [Elem1|Tail1], [Elem2|Tail2]) :-
        apply(Goal, [Elem1, Elem2]),
        maplist(Goal, Tail1, Tail2).


44..66..22 OOvveerrrruulliinngg MMoodduullee BBoouunnddaarriieess

The  mechanism  above  is sufficient  to  create  an  acceptable  module
system.   There are however cases in which  we would like to be  able to
overrule this  schema and  explicitly call  a predicate  in some  module
or assert  explicitly in some  module.   The first  is useful to  invoke
goals  in  some module  from  the  user's  toplevel or  to  implement  a
object-oriented system (see above).  The latter is  useful to create and
modify d_y_n_a_m_i_c_ m_o_d_u_l_e_s_ (see section 4.7).

For  this purpose,  the reserved  term ://22  has  been introduced.    All
built-in predicates  that transform  a term into  a predicate  reference
will check whether  this term is of  the form `<M_o_d_u_l_e_>:<T_e_r_m_>'.  If  so,
the predicate is  searched for in M_o_d_u_l_e_  instead of the goal's  context
module.   The :  operator may be  nested, in  which case the  inner-most
module is used.

The special  calling construct  <M_o_d_u_l_e_>:<G_o_a_l_>pretends  G_o_a_l_ is  called
from M_o_d_u_l_e_ instead of the context module.  Examples:

?- assert(world:done).  % asserts done/0 into module world
?- world:assert(done).  % the same
?- world:done.          % calls done/0 in module world


44..77 DDyynnaammiicc MMoodduulleess

So  far,   we  discussed  modules  that   were  created  by  loading   a
module-file.     These  modules  have  been   introduced  on  facilitate
the  development  of  large  applications.     The   modules  are  fully
defined at  load-time of the  application and  normally will not  change
during  execution.   Having  the  notion of  a set  of  predicates as  a
self-contained world can be attractive for other purposes as  well.  For
example, assume  an application that  can reason about multiple  worlds.
It is attractive  to store the data of  a particular world in a  module,
so we extract information from a world simply by  invoking goals in this
world.

Dynamic modules  can easily  be created.   Any  built-in predicate  that
tries  to locate  a predicate  in  a specific  module will  create  this
module as a side-effect if it did not yet exist.  Example:

?- assert(world_a, consistent),
   world_a:unknown(_, fail).

These  calls  create  a  module  called  `world_a'  and  make  the  call
`world_a:consistent'  succeed.  Undefined  predicates will not start  the
tracer or autoloader for this module (see uunnkknnoowwnn//22).

Import and  export from dynamically  created world  is arranged via  the
predicates iimmppoorrtt//11 and eexxppoorrtt//11:

?- world_b:export(solve(_,_)).          % exports solve/2 from world_b
?- world_c:import(world_b:solve(_,_)).  % and import it to world_c


44..88 MMoodduullee HHaannddlliinngg PPrreeddiiccaatteess

This section gives the predicate definitions for  the remaining built-in
predicates that handle modules.


::-- mmoodduullee((+_M_o_d_u_l_e_,_ +_P_u_b_l_i_c_L_i_s_t_))
    This directive can only  be used as the first term of a source file.
    It  declares  the file  to be  a m_o_d_u_l_e_  f_i_l_e_,  defining M_o_d_u_l_e_  and
    exporting  the predicates of  P_u_b_l_i_c_L_i_s_t_.   P_u_b_l_i_c_L_i_s_t_ is a list  of
    name/arity pairs.


mmoodduullee__ttrraannssppaarreenntt +_P_r_e_d_s_
    P_r_e_d_s_   is  a  comma  separated  list  of  name/arity   pairs  (like
    ddyynnaammiicc//11).     Each goal  associated  with a  transparent  declared
    predicate will inherit the c_o_n_t_e_x_t_ m_o_d_u_l_e_ from its parent goal.


mmeettaa__pprreeddiiccaattee +_H_e_a_d_s_
    This  predicate  is  defined  in  library(quintus)  and  provides  a
    partial  emulation of the Quintus predicate.  See section  4.9.1 for
    details.


ccuurrrreenntt__mmoodduullee((-_M_o_d_u_l_e_))
    Generates all currently known modules.


ccuurrrreenntt__mmoodduullee((?_M_o_d_u_l_e_,_ ?_F_i_l_e_))
    Is  true if F_i_l_e_ is the file from which M_o_d_u_l_e_ was loaded.   F_i_l_e_ is
    the internal canonical filename.  See also ssoouurrccee__ffiillee//[[11,,22]].


ccoonntteexxtt__mmoodduullee((-_M_o_d_u_l_e_))
    Unify   M_o_d_u_l_e_  with  the  context  module  of  the   current  goal.
    ccoonntteexxtt__mmoodduullee//11 itself is transparent.


eexxppoorrtt((+_H_e_a_d_))
    Add  a predicate to  the public list  of the context  module.   This
    implies  the predicate will be imported into another module  if this
    module  is imported with uussee__mmoodduullee//[[11,,22]].  Note  that predicates are
    normally  exported using the directive mmoodduullee//22.  eexxppoorrtt//11  is meant
    to handle export from dynamically created modules.


eexxppoorrtt__lliisstt((+_M_o_d_u_l_e_,_ ?_E_x_p_o_r_t_s_))
    Unifies  E_x_p_o_r_t_s_ with a list of terms.   Each term has the  name and
    arity  of a public predicate of M_o_d_u_l_e_.   The order of the  terms in
    E_x_p_o_r_t_s_ is not defined.  See also pprreeddiiccaattee__pprrooppeerrttyy//22.


ddeeffaauulltt__mmoodduullee((+_M_o_d_u_l_e_,_ -_D_e_f_a_u_l_t_))
    Succesively unifies D_e_f_a_u_l_t_  with the module names from which a call
    in  M_o_d_u_l_e_ attempts to  use the  definition.   For the module  user,
    this  will generate user  and system.   For  any other module,  this
    will generate the module itself, followed by user and system.


mmoodduullee((+_M_o_d_u_l_e_))
    The  call module(Module) may be  used to switch the default  working
    module  for the interactive  toplevel (see pprroolloogg//00).   This may  be
    used  to when  debugging  a module.    The example  below lists  the
    clauses of file_of_label/2 in the module tex.

    1 ?- module(tex).

    Yes
    tex: 2 ?- listing(file_of_label/2).
    ...


44..99 CCoommppaattiibbiilliittyy ooff tthhee MMoodduullee SSyysstteemm

The  principles behind  the  module system  of  SWI-Prolog differ  in  a
number of aspects from the Quintus Prolog module system.

  o The  SWI-Prolog module  system allows  the user  to redefine  system
    predicates.

  o All  predicates that are  available in the  system and user  modules
    are visible in all other modules as well.

  o Quintus  has the `mmeettaa__pprreeddiiccaattee//11' declaration were SWI-Prolog  has
    the mmoodduullee__ttrraannssppaarreenntt//11 declaration.

The mmeettaa__pprreeddiiccaattee//11 declaration  causes the compiler  to tag  arguments
that pass  module sensitive information  with the  module using the  ://22
operator.  This approach has some disadvantages:

  o Changing   a  meta_predicate   declaration  implies  all   predicates
    ccaalllliinngg  the predicate need to be reloaded.  This can  cause serious
    consistency problems.

  o It  does not help for dynamically defined predicates  calling module
    sensitive predicates.

  o It   slows  down   the  compiler   (at  least   in  the   SWI-Prolog
    architecture).

  o At  least within the  SWI-Prolog architecture the run-time  overhead
    is   larger  than  the   overhead  introduced  by  the   transparent
    mechanism.

Unfortunately  the   transparent  predicate   approach  also  has   some
disadvantages.   If a  predicate A passes  module sensitive information
to a  predicate B, passing  the same information to  a module sensitive
system predicate both  A and B  should be declared transparent.   Using
the Quintus approach only A  needs to be treated special (i.e. declared
with  mmeettaa__pprreeddiiccaattee//11).    A second  problem  arises if  the body  of  a
transparent  predicate uses  module sensitive  predicates  for which  it
wants to refer to its  own module.  Suppose we want to  define ffiinnddaallll//33
using aasssseerrtt//11  and rreettrraacctt//11.    The example  in figure  4.1 gives  the
solution.
:- module(findall, [findall/3]).

:- dynamic

        solution/1.

:- module_transparent
        findall/3,
        store/2.

findall(Var, Goal, Bag) :-

        assert(findall:solution('$mark')),
        store(Var, Goal),
        collect(Bag).

store(Var, Goal) :-
        Goal,                   % refers to context module of
                                % caller of findall/3
        assert(findall:solution(Var)),

        fail.
store(_, _).

collect(Bag) :-
        ...,

                  Figure 4.1:  ffiinnddaallll//33 using modules


44..99..11 EEmmuullaattiinngg mmeettaa__pprreeddiiccaattee//11

The Quintus  mmeettaa__pprreeddiiccaattee//11 directive can  in many  cases be  replaced
by  the   transparent  declaration.      Below  is  the  definition   of
mmeettaa__pprreeddiiccaattee//11as available from library(quintus).

:- op(1150, fx, (meta_predicate)).

meta_predicate((Head, More)) :- !,
        meta_predicate1(Head),
        meta_predicate(More).
meta_predicate(Head) :-
        meta_predicate1(Head).

meta_predicate1(Head) :-
        Head =.. [Name|Arguments],
        member(Arg, Arguments),
        module_expansion_argument(Arg), !,
        functor(Head, Name, Arity),
        module_transparent(Name/Arity).
meta_predicate1(_).             % just a mode declaration

module_expansion_argument(:).
module_expansion_argument(N) :- integer(N).

The discussion above  about the problems with the transparent  mechanism
show the two cases in which this simple transformation does not work.


CChhaapptteerr 55..  FFOORREEIIGGNN LLAANNGGUUAAGGEE IINNTTEERRFFAACCEE

SWI-Prolog  offers  a  powerful  interface  to  C  .   The  main  design
objectives  of  the  foreign  language  interface  are  flexibility  and
performance.   A  foreign predicate is  a C-function  that has the  same
number  of arguments  as the  predicate represented.    C-functions  are
provided to analyse the  passed terms, convert them to basic  C-types as
well as to  instantiate arguments using unification.   Non-deterministic
foreign predicates are supported, providing the foreign  function with a
handle to control backtracking.

C can  call Prolog  predicates, providing  both an  query interface  and
an interface  to extract  multiple solutions  from an  non-deterministic
Prolog predicate.   There is no limit  to the nesting of Prolog  calling
C, calling Prolog,  etc.  It is also  possible to write the `main'  in C
and use Prolog as an embedded logical engine.


55..11 OOvveerrvviieeww ooff tthhee IInntteerrffaaccee

A special include file called SWI-Prolog.h should be  included with each
C-source file  that is  to be  loaded via the  foreign interface.    The
installation  process installs  this file  in the  directory include  in
the SWI-Prolog home directory (?- feature(home, Home).).   This C-header
file defines various data  types, macros and functions that can  be used
to communicate  with SWI-Prolog.   Functions and  macros can be  divided
into the following categories:

  o Analysing Prolog terms

  o Constructing new terms

  o Unifying terms

  o Returning control information to Prolog

  o Registering foreign predicates with Prolog

  o Calling Prolog from C

  o Global actions on Prolog (halt, break, abort, etc.)


55..22 LLiinnkkiinngg FFoorreeiiggnn MMoodduulleess

Foreign modules  may be linked to  Prolog in three  ways.  Using  s_t_a_t_i_c_
l_i_n_k_i_n_g_,  the  extensions,  a  small  description  file  and  the  basic
SWI-Prolog object  file are linked  together to  form a new  executable.
Using d_y_n_a_m_i_c_  l_i_n_k_i_n_g_, the  extensions are linked  to a shared  library
(.so file on  most Unix systems) or  dynamic-link library (.DLL file  on
Microsoft platforms) and loaded into the the running Prolog process..


55..22..11 WWhhaatt lliinnkkiinngg iiss pprroovviiddeedd??

The s_t_a_t_i_c_  l_i_n_k_i_n_g_ schema can  be used on  all versions of  SWI-Prolog.
The  ffeeaattuurree//22 predicate  may be  used to  find out  what other  linking
methods are provided for this version.

  o f_e_a_t_u_r_e_(_o_p_e_n___s_h_a_r_e_d___o_b_j_e_c_t_,_ t_r_u_e_)_
    If  this succeeds  the system  provides the  ooppeenn__sshhaarreedd__oobbjjeecctt//22and
    related predicates that  allow for handling Unix shared object files
    based  on the  Unix library functions  ddllooppeenn((2)) and  friends.   See
    section 5.4.

  o f_e_a_t_u_r_e_(_d_l_l_,_ t_r_u_e_)_
    If  this succeeds the system provides an interface for  loading .DLL
    files by means of ooppeenn__ddllll//22 and friends.  See section 5.4.

If either  the feature  open_shared_object  or dll is  true, the  library
library(shlib) provides  a common  interface for  loading foreign  files
from Prolog.


55..22..22 WWhhaatt kkiinndd ooff llooaaddiinngg sshhoouulldd II bbee uussiinngg??

All  described  approaches  have  their  advantages  and  disadvantages.
Static linking  is portable and allows  for debugging on all  platforms.
It is relatively  cumbersome and the libraries  you need to pass to  the
linker may vary from system to system.

Loading  shared objects  or DLL  files provides  sharing and  protection
and is  generally the best choice.   The  old (and also badly  portable)
ssaavvee//[[11,,22]] and ssaavvee__pprrooggrraamm//[[11,,22]] do not cooperate with  this mechanism,
but the more recent  qqssaavvee__pprrooggrraamm//[[11,,22]]can be used to  created programs
that load the appropriate library at startup.

Note  that  the  definition of  the  foreign  predicates  is  the  same,
regardless of the linking type used.


55..33 DDyynnaammiicc LLiinnkkiinngg ooff sshhaarreedd lliibbrraarriieess

The interface  defined in this  section allows the  user to load  shared
libraries (.so files on most Unix systems).   This interface is portable
to  all machines  providing  the function  ddllooppeenn((2)) or  an  equivalent,
normally  from the  library -ldl.    These functions  provide the  basic
interface layer.   It is advised to use the predicates from  section 5.4
in your application.


ooppeenn__sshhaarreedd__oobbjjeecctt((+_F_i_l_e_,_ -_H_a_n_d_l_e_))
    F_i_l_e_  is the name of a  .so file (see your C programmers  documenta-
    tion  on how to create  a .so file).   This file is attached to  the
    current  process and H_a_n_d_l_e_ is unified  with a handle to the  shared
    object.    Equivalent to open_shared_object(File, [global], Handle).
    See also llooaadd__ffoorreeiiggnn__lliibbrraarryy//[[11,,22]].


ooppeenn__sshhaarreedd__oobbjjeecctt((+_F_i_l_e_,_ +_O_p_t_i_o_n_s_,_ -_H_a_n_d_l_e_))
    As  ooppeenn__sshhaarreedd__oobbjjeecctt//22,  but  allows  for additional  flags  to  be
    passed.   O_p_t_i_o_n_s_ is a list of  atoms.  now implies the  symbols are
    resolved  immediately rather  than lazy (default).   global  implies
    symbols of the  loaded object are visible while loading other shared
    objects (by default they  are local).  Note that these flags may not
    be  supported by your operating system.  Check the  documentation of
    dlopen() or equivalent on your operating system.


cclloossee__sshhaarreedd__oobbjjeecctt((+_H_a_n_d_l_e_))
    Detach the shared object identified by H_a_n_d_l_e_.


ccaallll__sshhaarreedd__oobbjjeecctt__ffuunnccttiioonn((+_H_a_n_d_l_e_,_ +_F_u_n_c_t_i_o_n_))
    Call the named function  in the loaded shared library.  The function
    is  called  without  arguments  and  the  return-value  is  ignored.
    Normally  this function installs  foreign language predicates  using
    calls to PPLL__rreeggiisstteerr__ffoorreeiiggnn(()).


55..44 UUssiinngg tthhee lliibbrraarryy sshhlliibb ffoorr .DLL aanndd .so ffiilleess

This  section discusses  the  functionality  of the  (autoload)  library
shlib.pl,  providing an interface  to shared  libraries.   Currently  it
supports MS-Windows  DLL (.DLL) libraries and  Unix .so (shared  object)
files.


llooaadd__ffoorreeiiggnn__lliibbrraarryy((+_L_i_b_))
    Equivalent to load_foreign_library(Lib, install).


llooaadd__ffoorreeiiggnn__lliibbrraarryy((+_L_i_b_,_ +_E_n_t_r_y_))
    Search  for the  given foreign library  and link  it to the  current
    SWI-Prolog  instance.  The library may be specified with  or without
    the  extension.     First,  aabbssoolluuttee__ffiillee__nnaammee//33is  used  to  locate
    the  file.    If  this succeeds,  the  full path  is passed  to  the
    low-level  function  to open  the library.    Otherwise,  the  plain
    library  name  is passed,  exploiting  the operating-system  defined
    search  mechanism for  the shared  library.   The  ffiillee__sseeaarrcchh__ppaatthh//22
    alias  mechanism  defines the  alias foreign,  which  refers to  the
    directories <p_l_h_o_m_e_>/lib/<a_r_c_h_>and <p_l_h_o_m_e_>/lib, in this order.

    If  the library  can be loaded,  the function  called E_n_t_r_y_ will  be
    called  without arguments.    The return  value of  the function  is
    ignored.

    The  E_n_t_r_y_  function  will  normally  call  PPLL__rreeggiisstteerr__ffoorreeiiggnn(()) to
    declare functions in the library as foreign predicates.


uunnllooaadd__ffoorreeiiggnn__lliibbrraarryy((+_L_i_b_))
    If  the  foreign  library defines  the  function  uninstall(),  this
    function  will be called without  arguments and its return value  is
    ignored.    Next,  aabboolliisshh//22 is  used to  remove  all known  foreign
    predicates  defined in the library.   Finally the library itself  is
    detached from the process.


ccuurrrreenntt__ffoorreeiiggnn__lliibbrraarryy((-_L_i_b_,_ -_P_r_e_d_i_c_a_t_e_s_))
    Query  the currently loaded foreign libraries and  their predicates.
    P_r_e_d_i_c_a_t_e_s_  is  a  list  with  elements  of  the  form  M_o_d_u_l_e_:_H_e_a_d_,
    indicating  the predicates installed with  PPLL__rreeggiisstteerr__ffoorreeiiggnn(())when
    the entry-point of the library was called.

Figure  5.1 connects  a Windows  message-box using  a foreign  function.
This example was tested using Windows NT and Microsoft Visual C++ 2.0.

#include <windows.h>
#include <SWI-Prolog.h>

static foreign_t
pl_say_hello(term_t to)
{ char *a;

  if ( PL_get_atom_chars(to, &a) )
  { MessageBox(NULL, a, "DLL test", MB_OK|MB_TASKMODAL);

    PL_succeed;
  }

  PL_fail;
}

install_t
install()
{ PL_register_foreign("say_hello", 1, pl_say_hello, 0);
}

            Figure 5.1:  MessageBox() example in Windows NT


55..44..11 SSttaattiicc LLiinnkkiinngg

Below  is an  outline of  the files  structure  required for  statically
linking  SWI-Prolog with  foreign  extensions.    .../pl refers  to  the
SWI-Prolog  home  directory (see  ffeeaattuurree//22).     <a_r_c_h_> refers  to  the
architecture identifier that may be obtained using ffeeaattuurree//22.

      .../pl/runtime/<a_r_c_h_>/libpl.a SWI-Library
      .../pl/include/SWI-Prolog.h   Include file
      .../pl/include/SWI-Stream.h   Stream I/O include file
      .../pl/include/SWI-Exports    Export declarations (AIX only)
      .../pl/include/stub.c         Extension stub

The  definition   of  the  foreign  predicates   is  the  same  as   for
dynamic  linking.    Unlike  with  dynamic  linking  however,  there  is
no initialisation  function.   Instead,  the file  .../pl/include/stub.c
may  be copied  to  your project  and  modified  to define  the  foreign
extensions.   Below is  stub.c, modified to  link the lowercase  example
described later in this chapter:

/*  Copyright (c) 1991 Jan Wielemaker. All rights reserved.
    jan@swi.psy.uva.nl

    Purpose: Skeleton for extensions
*/

#include <stdio.h>
#include <SWI-Prolog.h>

extern foreign_t pl_lowercase(term, term);

PL_extension PL_extensions [] =
{
/*{ "name",      arity,  function,      PL_FA_<flags> },*/

  { "lowercase", 2       pl_lowercase,  0 },
  { NULL,        0,      NULL,          0 }     /* terminating line */
};

int
main(int argc, char **argv, char **env)
{ if ( !PL_initialise(argc, argv, env) )
    PL_halt(1);

  PL_install_readline();                /* delete if not required */

  PL_halt(PL_toplevel() ? 0 : 1);
}

Now, a new executable may be created by compiling  this file and linking
it to libpl.a from  the runtime directory and the libraries  required by
both the  extensions and the  SWI-Prolog kernel.   This  may be done  by
hand, or using the plld utility described in secrefplld.


55..44..22 DDyynnaammiicc LLiinnkkiinngg bbaasseedd oonn llooaadd__ffoorreeiiggnn//[[22,,55]]

The  predicates  below  are considered  obsolete.     They  are  briefly
described here  for compatibility  purposes.   New code  should use  the
predicates from the library(shlib).


llooaadd__ffoorreeiiggnn((+_F_i_l_e_,_ +_E_n_t_r_y_))
    Load  a  foreign file  or list  of files  specified by  F_i_l_e_.    The
    files  are searched for similar to ccoonnssuulltt//11.  Except that  the `.o'
    extension is used rather than `.pl'.

    E_n_t_r_y_  defines the  entry point of  the resulting  executable.   The
    entry  point  will  be  called  by Prolog  to  install  the  foreign
    predicates.


llooaadd__ffoorreeiiggnn((+_F_i_l_e_,_ +_E_n_t_r_y_,_ +_O_p_t_i_o_n_s_,_ +_L_i_b_r_a_r_i_e_s_,_ +_S_i_z_e_))
    The  first two arguments  are identical to  those of llooaadd__ffoorreeiiggnn//22.
    O_p_t_i_o_n_s_ is (a list  of) additional option to be given to the loader.
    The  options are inserted  just before the files.   L_i_b_r_a_r_i_e_s_ is  (a
    list  of) libraries to be passed to  the loader.  They  are inserted
    just  after the files.   If S_i_z_e_  is specified Prolog first  assumes
    that  the resulting  executable will fit  in S_i_z_e_  bytes and do  the
    loading in one pass.


ffoorreeiiggnn__ffiillee((?_F_i_l_e_))
    Is  true if  F_i_l_e_ is  the absolute  path name  of a  file loaded  as
    foreign file.


55..55 IInntteerrffaaccee DDaattaa ttyyppeess


55..55..11 TTyyppee term_t::  aa rreeffeerreennccee ttoo aa PPrroolloogg tteerrmm

The principal  data-type is term_t.   Type term_t is what Quintus  calls
QP_term_ref.   This name indicates  better what the type represents:   it
is a h_a_n_d_l_e_ for a  term rather than the term itself.  Terms can  only be
represented and manipulated  using this type, as  this is the only  safe
way to  ensure the  Prolog kernel is  aware of  all terms referenced  by
foreign code  and thus allows the  kernel to perform  garbage-collection
and/or stack-shifts while foreign  code is active, for example  during a
callback from C.

A term  reference is  a C unsigned  long, representing  the offset of  a
variable on the Prolog environment-stack.  A foreign  function is passed
term references for the predicate-arguments, one for each  argument.  If
references for intermediate  results are needed, such references  may be
created using  PPLL__nneeww__tteerrmm__rreeff(())or  PPLL__nneeww__tteerrmm__rreeffss(()).   These  references
normally live till the foreign function returns control  back to Prolog.
Their scope  can be explicitly  limited using PPLL__ooppeenn__ffoorreeiiggnn__ffrraammee(())and
PPLL__cclloossee__ffoorreeiiggnn__ffrraammee(())/PPLL__ddiissccaarrdd__ffoorreeiiggnn__ffrraammee(()).

A term_t  always refers to a valid Prolog term (variable,  atom, integer,
float  or compound  term).    A  term  lives either  until  backtracking
takes  us back  to a  point before  the term  was created,  the  garbage
collector  has collected  the  term or  the  term  was created  after  a
PPLL__ooppeenn__ffoorreeiiggnn__ffrraammee(())and PPLL__ddiissccaarrdd__ffoorreeiiggnn__ffrraammee(())has been called.

The  foreign-interface functions  can either  r_e_a_d_,  u_n_i_f_y_ or  w_r_i_t_e_  to
term-references.   In the  this document we  use the following  notation
for arguments of type term_t:

     term_t +t  Accessed   in  read-mode.       The   `+'
                indicates the argument is `input'.
     term_t -t  Accessed in write-mode.
     term_t ?t  Accessed in unify-mode.

Term references are obtained in any of the following ways.

  o P_a_s_s_e_d_ a_s_ a_r_g_u_m_e_n_t_
    The  C-functions implementing  foreign predicates  are passed  their
    arguments  as term-references.    These  references may  be read  or
    unified.  Writing to these variables causes undefined behaviour.

  o C_r_e_a_t_e_d_ b_y_ PPLL__nneeww__tteerrmm__rreeff(())
    A  term  created  by  PPLL__nneeww__tteerrmm__rreeff(())is  normally  used  to  build
    temporary  terms or be  written by one  of the interface  functions.
    For example,  PPLL__ggeett__aarrgg(())writes a reference  to the term-argument in
    its last argument.

  o C_r_e_a_t_e_d_ b_y_ PPLL__nneeww__tteerrmm__rreeffss((i_n_t_ n_))
    This   function  returns  a   set  of  term   refs  with  the   same
    characteristics as PPLL__nneeww__tteerrmm__rreeff(()).  See PPLL__ooppeenn__qquueerryy(()).

  o C_r_e_a_t_e_d_ b_y_ PPLL__ccooppyy__tteerrmm__rreeff((t_e_r_m___t_ t_))
    Creates a new term-reference  to the same term as the argument.  The
    term may be written to.  See figure 5.3.

Term-references  can safely  be  copied  to other  C-variables  of  type
term_t, but all copies will always refer to the same term.


t_e_r_m___t_ PPLL__nneeww__tteerrmm__rreeff(())
    Return  a fresh reference  to a  term.   The reference is  allocated
    on  the l_o_c_a_l_  stack.   Allocating  a term-reference  may trigger  a
    stack-shift  on machines  that cannot  use sparse-memory  management
    for allocation the  Prolog stacks.  The returned reference describes
    a variable.


t_e_r_m___t_ PPLL__nneeww__tteerrmm__rreeffss((i_n_t_ n_))
    Return  n_  new  term  references.     The  first  term-reference  is
    returned.   The others are t_ +1, t_ +2, etc.   There are two reasons
    for  using this function.   PPLL__ooppeenn__qquueerryy(())expects the arguments  as
    a  set of  consecutive term references  and v_e_r_y_ time-critical  code
    requiring a number of term-references can be written as:

    pl_mypredicate(term_t a0, term_t a1)
    { term_t t0 = PL_new_term_refs(2);
      term_t t1 = t0+1;

      ...
    }


t_e_r_m___t_ PPLL__ccooppyy__tteerrmm__rreeff((t_e_r_m___t_ f_r_o_m_))
    Create a new term  reference and make it point initially to the same
    term  as f_r_o_m_.  This function  is commonly used to copy  a predicate
    argument to a term reference that may be written.


v_o_i_d_ PPLL__rreesseett__tteerrmm__rreeffss((t_e_r_m___t_ a_f_t_e_r_))
    Destroy  all term  references that  have been  created after  a_f_t_e_r_,
    including  a_f_t_e_r_ itself.    Any  reference to  the invalidated  term
    references after this call results in undefined behaviour.

    Note  that  returning  from  the  foreign  context  to  Prolog  will
    reclaim  all references  used in  the foreign  context.   This  call
    is  only necessary  if  references are  created inside  a loop  that
    never  exits  back  to  Prolog.    See  also  PPLL__ooppeenn__ffoorreeiiggnn__ffrraammee(()),
    PPLL__cclloossee__ffoorreeiiggnn__ffrraammee(())and PPLL__ddiissccaarrdd__ffoorreeiiggnn__ffrraammee(()).


55..55..11..11 IInntteerraaccttiioonn wwiitthh tthhee ggaarrbbaaggee ccoolllleeccttoorr aanndd ssttaacckk--sshhiifftteerr

Prolog implements two  mechanisms for avoiding stack overflow:   garbage
collection and stack expansion.   On machines that allow for  it, Prolog
will use virtual  memory management to detect stack overflow  and expand
the  runtime stacks.    On  other machines  Prolog will  reallocate  the
stacks and update all pointers to them.  To do so,  Prolog needs to know
which data is  referenced by C-code.  As  all Prolog data known by  C is
referenced through term references (term_t), Prolog has  all information
necessary to perform  its memory management without special  precautions
from the C-programmer.


55..55..22 OOtthheerr ffoorreeiiggnn iinntteerrffaaccee ttyyppeess

aattoomm__tt An atom in Prologs  internal representation.  Atoms  are pointers
    to  an  opaque structure.    They are  a  unique representation  for
    represented  text, which  implies that  atom A  represents the same
    text as atom B  if-and-only-if A and B are the same pointer.

    Atoms  are  the  central  representation for  textual  constants  in
    Prolog  The  transformation  of C  a  character  string to  an  atom
    implies  a hash-table lookup.  If the same atom is needed  often, it
    is  advised to  store its reference  in a  global variable to  avoid
    repeated lookup.

ffuunnccttoorr__tt A  functor is  the  internal  representation of  a  name/arity
    pair.   They are used to find the name and arity of  a compound term
    as  well as to construct new compound  terms.  Like atoms  they live
    for the whole Prolog session and are unique.

pprreeddiiccaattee__tt Handle  to a  Prolog  predicate.    Predicate  handles  live
    forever (although they can loose their definition).

qqiidd__tt Query         Identifier.                          Used         by
    PPLL__ooppeenn__qquueerryy(())/PPLL__nneexxtt__ssoolluuttiioonn(())/PPLL__cclloossee__qquueerryy(()) to  handle   back-
    tracking from C.

ffiidd__tt Frame         Identifier.                          Used         by
    PPLL__ooppeenn__ffoorreeiiggnn__ffrraammee(())/PPLL__cclloossee__ffoorreeiiggnn__ffrraammee(()).

mmoodduullee__tt A module is  a unique handle to a  Prolog module.  Modules  are
    used only to call predicates in a specific module.

ffoorreeiiggnn__tt Return type for a C-function implementing a Prolog predicate.

ccoonnttrrooll__tt Passed  as additional  argument to  non-deterministic  foreign
    functions.  See PL_retry*() and PL_foreign_context*().

iinnssttaallll__tt Type for the install() and uninstall() functions  of shared or
    dynamic link libraries.  See secrefshlib.


55..66 TThhee FFoorreeiiggnn IInncclluuddee FFiillee


55..66..11 AArrgguummeenntt PPaassssiinngg aanndd CCoonnttrrooll

If  Prolog encounters  a foreign  predicate  at run  time it  will  call
a  function  specified  in  the  predicate  definition  of  the  foreign
predicate.   The arguments 1;:::; <a_r_i_t_y_>pass the  Prolog arguments to the
goal as  Prolog terms.   Foreign  functions should  be declared of  type
foreign_t.   Deterministic foreign  functions have  two alternatives  to
return control back to Prolog:


v_o_i_d_ PPLL__ssuucccceeeedd(())
    Succeed deterministically.  PL_succeed is defined as return TRUE.


v_o_i_d_ PPLL__ffaaiill(())
    Fail  and  start  Prolog  backtracking.     PL_fail  is  defined  as
    return FALSE.


55..66..11..11 NNoonn--ddeetteerrmmiinniissttiicc FFoorreeiiggnn PPrreeddiiccaatteess

By  default   foreign  predicates   are  deterministic.      Using   the
PL_FA_NONDETERMINISTIC   attribute  (see   PPLL__rreeggiisstteerr__ffoorreeiiggnn(()))  it   is
possible  to register  a  predicate  as a  non-deterministic  predicate.
Writing   non-deterministic   foreign  predicates   is   slightly   more
complicated  as  the  foreign function  needs  context  information  for
generating  the next  solution.   Note  that the  same foreign  function
should  be  prepared  to be  simultaneously  active  in  more  than  one
goal.     Suppose  the  natural_number_below_n/2  is  a  non-deterministic
foreign predicate, backtracking over all natural numbers  lower than the
first argument.  Now consider the following predicate:

quotient_below_n(Q, N) :-
        natural_number_below_n(N, N1),
        natural_number_below_n(N, N2),
        Q =:= N1 / N2, !.

In  this predicate  the function  natural_number_below_n/2  simultaneously
generates solutions for both its invocations.

Non-deterministic foreign functions  should be prepared to handle  three
different calls from Prolog:

  o I_n_i_t_i_a_l_ c_a_l_l_ (_PL_FIRST_CALL)_
    Prolog  has just created a frame  for the foreign function and  asks
    it to produce the first answer.

  o R_e_d_o_ c_a_l_l_ (_PL_REDO)_
    The previous invocation  of the foreign function associated with the
    current  goal indicated it was possible  to backtrack.  The  foreign
    function should produce the next solution.

  o T_e_r_m_i_n_a_t_e_ c_a_l_l_ (_PL_CUTTED)_
    The choice point  left by the foreign function has been destroyed by
    a  cut.  The foreign function is given the opportunity to  clean the
    environment.

Both  the  context  information  and  the  type  of   call  is  provided
by  an  argument  of  type  control_t  appended  to  the  argument  list
for  deterministic foreign  functions.    The macro  PPLL__ffoorreeiiggnn__ccoonnttrrooll(())
extracts  the   type  of  call   from  the  control   argument.      The
foreign  function  can  pass  a context  handle  using  the  PL_retry*()
macros  and  extract  the handle  from  the  extra  argument  using  the
PL_foreign_context*() macro.


v_o_i_d_ PPLL__rreettrryy((l_o_n_g_))
    The  foreign function  succeeds while leaving  a choice  point.   On
    backtracking  over this  goal the  foreign function  will be  called
    again,  but the control argument now  indicates it is a `Redo'  call
    and the  macro PPLL__ffoorreeiiggnn__ccoonntteexxtt(())will return  the handle passed via
    PPLL__rreettrryy(()).   This handle is  a 30 bits signed  value (two bits  are
    used for status indication).


v_o_i_d_ PPLL__rreettrryy__aaddddrreessss((v_o_i_d_ *_))
    As  PPLL__rreettrryy(()),  but ensures an  address as  returned by malloc()  is
    correctly recovered by PPLL__ffoorreeiiggnn__ccoonntteexxtt__aaddddrreessss(()).


i_n_t_ PPLL__ffoorreeiiggnn__ccoonnttrrooll((c_o_n_t_r_o_l___t_))
    Extracts  the type of  call from the control  argument.  The  return
    values  are  described above.    Note that  the  function should  be
    prepared  to handle the PL_CUTTED case and should be aware  that the
    other arguments are not valid in this case.


l_o_n_g_ PPLL__ffoorreeiiggnn__ccoonntteexxtt((c_o_n_t_r_o_l___t_))
    Extracts  the context from the context  argument.  In the call  type
    is  PL_FIRST_CALL the context value is 0L. Otherwise it  is the value
    returned  by the last PPLL__rreettrryy(()) associated with this goal (both  if
    the call type is PL_REDO as PL_CUTTED).


v_o_i_d_ *_ PPLL__ffoorreeiiggnn__ccoonntteexxtt__aaddddrreessss((c_o_n_t_r_o_l___t_))
    Extracts an address as passed in by PPLL__rreettrryy__aaddddrreessss(()).

Note:  If a  non-deterministic foreign function returns using PL_succeed
or  PL_fail,   Prolog  assumes  the  foreign  function  has  cleaned  its
environment.  NNoo call with control argument PL_CUTTED will follow.

The code of figure 5.2 shows a skeleton for  a non-deterministic foreign
predicate definition.

typedef struct                  /* define a context structure */
{ ...
} context;

foreign_t
my_function(term_t a0, term_t a1, foreign_t handle)
{ struct context * ctxt;

  switch( PL_foreign_control(handle) )
  { case PL_FIRST_CALL:
        ctxt = malloc(sizeof(struct context));
        ...
        PL_retry_address(ctxt);
    case PL_REDO:

        ctxt = PL_foreign_context_address(handle);
        ...
        PL_retry_address(ctxt);
    case PL_CUTTED:
        free(ctxt);
        PL_succeed;
  }
}

     Figure 5.2:  Skeleton for non-deterministic foreign functions


55..66..22 AAttoommss aanndd ffuunnccttoorrss

The  following  functions  provide for  communication  using  atoms  and
functors.


a_t_o_m___t_ PPLL__nneeww__aattoomm((c_o_n_s_t_ c_h_a_r_ *_))
    Return an atom handle  for the given C-string.  This function always
    succeeds.  The returned handle is valid for the entire session.


c_o_n_s_t_ c_h_a_r_ *_ PPLL__aattoomm__cchhaarrss((a_t_o_m___t_ a_t_o_m_))
    Return  a C-string for the text represented by the given atom.   The
    returned  text will not be changed by Prolog.  It is  not allowed to
    modify  the contents, not even `temporary' as the string  may reside
    in read-only memory.


f_u_n_c_t_o_r___t_ PPLL__nneeww__ffuunnccttoorr((a_t_o_m___t_ n_a_m_e_,_ i_n_t_ a_r_i_t_y_))
    Returns  a f_u_n_c_t_o_r_  i_d_e_n_t_i_f_i_e_r_, a  handle for  the name/arity  pair.
    The returned handle is valid for the entire Prolog session.


a_t_o_m___t_ PPLL__ffuunnccttoorr__nnaammee((f_u_n_c_t_o_r___t_ f_))
    Return an atom representing the name of the given functor.


i_n_t_ PPLL__ffuunnccttoorr__aarriittyy((f_u_n_c_t_o_r___t_ f_))
    Return the arity of the given functor.


55..66..33 AAnnaallyyssiinngg TTeerrmmss vviiaa tthhee FFoorreeiiggnn IInntteerrffaaccee

Each argument  of a foreign function  (except for the control  argument)
is of type term_t, an opaque  handle to a Prolog term.  Three  groups of
functions are  available for  the analysis  of terms.    The first  just
validates the type,  like the Prolog  predicates vvaarr//11, aattoomm//11, etc  and
are  called PL_is_*().    The second  group  attempts to  translate  the
argument into a C primitive type.   These predicates take a term_t and a
pointer to the appropriate C-type and return TRUE or  FALSE depending on
successful or unsuccessful translation.   If the translation fails,  the
pointed-to data is never modified.


55..66..33..11 TTeessttiinngg tthhee ttyyppee ooff aa tteerrmm


i_n_t_ PPLL__tteerrmm__ttyyppee((t_e_r_m___t_))
    Obtain  the type  of a  term,  which should  be a  term returned  by
    one  of the  other interface  predicates or passed  as an  argument.
    The  function  returns the  type  of  the Prolog  term.    The  type
    identifiers  are listed below.   Note that the extraction  functions
    PL_ge_t*() also validate  the type and  thus the two sections  below
    are equivalent.

            if ( PL_is_atom(t) )
            { char *s;

              PL_get_atom_chars(t, &s);
              ...;
            }

    or

            char *s;
            if ( PL_get_atom_chars(t, &s) )
            { ...;
            }

    ___________________________________________________________________
    | PL_VARIABLE            |An unbound variable.   The value  of term|
    |                        |as such  is a  unique identifier  for the|

    |                        |variable.                                |
    | PL_ATOM                |A Prolog atom.                           |
    | PL_STRING              |A Prolog string.                         |
    | PL_INTEGER             |A Prolog integer.                        |
    | PL_FLOAT               |A Prolog floating point number.          |
    | PL_TERM                |A compound term.   Note that a  list is a|
    |________________________|compound_term_.//22._______________________|

The functions PL_is_<t_y_p_e_> are an alternative to PPLL__tteerrmm__ttyyppee(()).  The test
PPLL__iiss__vvaarriiaabbllee((t_e_r_m_))is  equivalent  to PPLL__tteerrmm__ttyyppee((t_e_r_m_))== PL_VARIABLE,
but  the first  is considerably  faster.   On  the other  hand, using  a
switch over  PPLL__tteerrmm__ttyyppee(())is  faster and  more readable  then using  an
if-then-else using  the functions  below.   All  these functions  return
either TRUE or FALSE.


i_n_t_ PPLL__iiss__vvaarriiaabbllee((t_e_r_m___t_))
    Returns non-zero if t_e_r_m_ is a variable.


i_n_t_ PPLL__iiss__aattoomm((t_e_r_m___t_))
    Returns non-zero if t_e_r_m_ is an atom.


i_n_t_ PPLL__iiss__ssttrriinngg((t_e_r_m___t_))
    Returns non-zero if t_e_r_m_ is a string.


i_n_t_ PPLL__iiss__iinntteeggeerr((t_e_r_m___t_))
    Returns non-zero if t_e_r_m_ is an integer.


i_n_t_ PPLL__iiss__ffllooaatt((t_e_r_m___t_))
    Returns non-zero if t_e_r_m_ is a float.


i_n_t_ PPLL__iiss__ccoommppoouunndd((t_e_r_m___t_))
    Returns non-zero if t_e_r_m_ is a compound term.


i_n_t_ PPLL__iiss__ffuunnccttoorr((t_e_r_m___t_,_ f_u_n_c_t_o_r___t_))
    Returns  non-zero if t_e_r_m_  is compound and  its functor is  f_u_n_c_t_o_r_.
    This test  is equivalent to PPLL__ggeett__ffuunnccttoorr(()),  followed by testing the
    functor, but easier to write and faster.


i_n_t_ PPLL__iiss__lliisstt((t_e_r_m___t_))
    Returns non-zero if t_e_r_m_  is a compound term with functor ./2 or the
    atom [].


i_n_t_ PPLL__iiss__aattoommiicc((t_e_r_m___t_))
    Returns non-zero if t_e_r_m_ is atomic (not variable or compound).


i_n_t_ PPLL__iiss__nnuummbbeerr((t_e_r_m___t_))
    Returns non-zero if t_e_r_m_ is an integer or float.


55..66..33..22 RReeaaddiinngg ddaattaa ffrroomm aa tteerrmm

The functions PL_get_*() read information from  a Prolog term.  Most  of
them take two arguments.  The first is the input  term and the second is
a pointer to the output value or a term-reference.


i_n_t_ PPLL__ggeett__aattoomm((t_e_r_m___t_ +_t_,_ a_t_o_m___t_ *_a_))
    If t_ is an atom,  store the unique atom identifier over a_.  See also
    PPLL__aattoomm__cchhaarrss(())and PPLL__nneeww__aattoomm(()).  If there is no need  to access the
    data  (characters) of  an atom,  it is advised  to manipulate  atoms
    using their handle.


i_n_t_ PPLL__ggeett__aattoomm__cchhaarrss((t_e_r_m___t_ +_t_,_ c_h_a_r_ *_*_s_))
    If  t_ is an atom, store a  pointer to a 0-terminated C-string  in s_.
    It is explicitly  nnoott allowed to modify the contents of this string.
    Some  built-in  atoms may  have the  string  allocated in  read-only
    memory, so `temporary manipulation' can cause an error.


i_n_t_ PPLL__ggeett__ssttrriinngg((t_e_r_m___t_ +_t_,_ c_h_a_r_ *_*_s_,_ i_n_t_ *_l_e_n_))
    If  t_  is  a  string  object,  store a  pointer  to  a  0-terminated
    C-string  in s_  and the  length of  the string in  l_e_n_.   Note  that
    this pointer  is invalidated by backtracking, garbage-collection and
    stack-shifts,  so generally the only save operations are to  pass it
    immediately to a C-function that doesn't involve Prolog.


i_n_t_ PPLL__ggeett__cchhaarrss((t_e_r_m___t_ +_t_,_ c_h_a_r_ *_*_s_,_ u_n_s_i_g_n_e_d_ f_l_a_g_s_))
    Convert  the argument term t_ to  a 0-terminated C-string.  f_l_a_g_s_  is
    a  bitwise disjunction  from two  groups of  constants.   The  first
    specifies  which term-types should converted and the second  how the
    argument  is stored.  Below  is a specification of these  constants.
    BUF_RING implies, if  the data is not static (as from an  atom), the
    data  is copied to the next buffer from a ring of four  (4) buffers.
    This is a  convenient way of converting multiple arguments passed to
    a  foreign predicate to C-strings.   If BUF_MALLOC is used,  the data
    must be freed using free() when not needed any longer.
    ___________________________________________________________________
    | CVT_ATOM               |Convert if term is an atom               |
    | CVT_STRING             |Convert if term is a string              |
    | CVT_LIST               |Convert  if term  is a  list of  integers|
    |                        |between 1 and 255                        |

    | CVT_INTEGER            |Convert if term is an integer (using %d) |
    | CVT_FLOAT              |Convert if term is a float (using %f)    |
    | CVT_NUMBER             |Convert if term is a integer or float    |
    | CVT_ATOMIC             |Convert if term is atomic                |
    | CVT_VARIABLE           |Convert variable to print-name           |
    | CVT_ALL                |Convert  if term  is  any  of the  above,|
    |________________________|except_for_variables_____________________|
    | BUF_DISCARDABLE        |Data must copied immediately             |

    | BUF_RING               |Data is stored in a ring of buffers      |
    | BUF_MALLOC             |Data is  copied to a new  buffer returned||
    |________________________________________________|by__mmaalllloocc((3))__________________________________________________________||


i_n_t_ PPLL__ggeett__lliisstt__cchhaarrss((+_t_e_r_m___t_ l_,_ c_h_a_r_ *_*_s_,_ u_n_s_i_g_n_e_d_ f_l_a_g_s_))
    Same  as PPLL__ggeett__cchhaarrss((l_,_ s_,_ C_V_T___L_I_S_T___f_l_a_g_s_)),  provided f_l_a_g_s_  contains
    no of the CVT_* flags.


i_n_t_ PPLL__ggeett__iinntteeggeerr((+_t_e_r_m___t_ t_,_ i_n_t_ *_i_))
    If  t_ is  a Prolog  integer, assign  its value over  i_.   On  32-bit
    machines,  this is  the same as  PPLL__ggeett__lloonngg(()),  but avoids a  warning
    from the compiler.  See also PPLL__ggeett__lloonngg(()).


i_n_t_ PPLL__ggeett__lloonngg((t_e_r_m___t_ +_t_,_ l_o_n_g_ *_i_))
    If  t_ is  a Prolog  integer, assign  its value over  i_.   Note  that
    Prolog integers have limited  value-range.  If t_ is a floating point
    number that can  be represented as a long, this function succeeds as
    well.


i_n_t_ PPLL__ggeett__ppooiinntteerr((t_e_r_m___t_ +_t_,_ v_o_i_d_ *_*_p_t_r_))
    In   the  current  system,   pointers  are  represented  by   Prolog
    integers,   but  need  some  manipulation  to  make  sure   they  do
    not  get  truncated   due  to  the  limited  Prolog  integer  range.
    PPLL__ppuutt__ppooiinntteerr(())/PPLL__ggeett__ppooiinntteerr(())guarantees pointers in the  range of
    malloc() are handled without truncating.


i_n_t_ PPLL__ggeett__ffllooaatt((t_e_r_m___t_ +_t_,_ d_o_u_b_l_e_ *_f_))
    If t_ is a float or integer, its value is assigned over f_.


i_n_t_ PPLL__ggeett__ffuunnccttoorr((t_e_r_m___t_ +_t_,_ f_u_n_c_t_o_r___t_ *_f_))
    If  t_  is  compound  or  an  atom,   the  Prolog  representation  of
    the   name-arity  pair  will  be  assigned   over  f_.     See   also
    PPLL__ggeett__nnaammee__aarriittyy(())and PPLL__iiss__ffuunnccttoorr(()).


i_n_t_ PPLL__ggeett__nnaammee__aarriittyy((t_e_r_m___t_ +_t_,_ a_t_o_m___t_ *_n_a_m_e_,_ i_n_t_ *_a_r_i_t_y_))
    If  t_ is  compound or  an atom,  the functor-name  will be  assigned
    over  n_a_m_e_ and the arity over  a_r_i_t_y_.  See  also PPLL__ggeett__ffuunnccttoorr(())and
    PPLL__iiss__ffuunnccttoorr(()).


i_n_t_ PPLL__ggeett__mmoodduullee((t_e_r_m___t_ +_t_,_ m_o_d_u_l_e___t_ *_m_o_d_u_l_e_))
    If t_ is an  atom, the system will lookup or create the corresponding
    module and assign an opaque pointer to it over m_o_d_u_l_e_,.


i_n_t_ PPLL__ggeett__aarrgg((i_n_t_ i_n_d_e_x_,_ t_e_r_m___t_ +_t_,_ t_e_r_m___t_ -_a_))
    If  t_ is  compound and  index is  between 1  and arity  (including),
    assign a_ with a term-reference to the argument.


55..66..33..33 RReeaaddiinngg aa lliisstt

The functions from this section are intended to read  a Prolog list from
C. Suppose we expect a list of atoms, the following  code will print the
atoms, each on a line:

foreign_t
pl_write_atoms(term_t l)
{ term_t head = PL_new_term_ref();      /* variable for the elements */
  term_t list = PL_copy_term_ref();     /* copy as we need to write */

  while( PL_get_list(list, head, list) )
  { char *s;

    if ( PL_get_atom_chars(head, &s) )
      Sprintf("%s\n", s);
    else
      PL_fail;
  }

  return PL_get_nil(list);              /* test end for [] */
}


i_n_t_ PPLL__ggeett__lliisstt((t_e_r_m___t_ +_l_,_ t_e_r_m___t_ -_h_,_ t_e_r_m___t_ -_t_))
    If  l_ is a list and not [] assign a term-reference to the  head to h_
    and to the tail to t_.


i_n_t_ PPLL__ggeett__hheeaadd((t_e_r_m___t_ +_l_,_ t_e_r_m___t_ -_h_))
    If l_ is a list and not [] assign a term-reference to the head to h_.


i_n_t_ PPLL__ggeett__ttaaiill((t_e_r_m___t_ +_l_,_ t_e_r_m___t_ -_t_))
    If l_ is a list and not [] assign a term-reference to the tail to t_.


i_n_t_ PPLL__ggeett__nniill((t_e_r_m___t_ +_l_))
    Succeeds if  represents the atom [].


55..66..33..44 AAnn eexxaammppllee::  ddeeffiinniinngg ddiissppllaayy//11 iinn CC

Figure 5.3 shows  a definition of ddiissppllaayy//11 to illustrate  the described
functions.
foreign_t
pl_display(term_t t)
{ functor_t functor;

  int arity, len, n;
  char *s;

  switch( PL_term_type(t) )
  { case PL_VARIABLE:
    case PL_ATOM:
    case PL_INTEGER:
    case PL_FLOAT:

      PL_get_chars(t, &s, CVT_ALL);
      Sprintf("%s", s);
      break;
    case PL_STRING:
      PL_get_string_chars(t, &s, &len);
      Sprintf("\"%s\"", s);
      break;

    case PL_TERM:
    { term_t a = PL_new_term_ref();

      PL_get_name_arity(t, &name, &arity);
      Sprintf("%s(", PL_atom_chars(name));
      for(n=1; n<=arity; n++)
      { PL_get_arg(n, t, a);
        if ( n > 1 )

          Sprintf(", ");
        pl_display(a);
      }
      Sprintf(")");
      break;
    default:
      PL_fail;                          /* should not happen */

  }

  PL_succeed;
}

             Figure 5.3:  A Foreign definition of ddiissppllaayy//11


55..66..44 CCoonnssttrruuccttiinngg TTeerrmmss

Terms  can  be  constructed  using  functions from  the  PL_put_*()  and
PL_cons_*()  families.    This  approach  builds the  term  `inside-out',
starting  at  the  leaves  and  subsequently  creating  compound  terms.
Alternatively,   terms  may  be  created   `top-down',  first   creating
a  compound  holding  only  variables  and   subsequently  unifying  the
arguments.   This section  discusses functions  for the first  approach.
This approach is generally used for creating arguments for PPLL__ccaallll(()) and
PL_open_query.


v_o_i_d_ PPLL__ppuutt__vvaarriiaabbllee((t_e_r_m___t_ -_t_))
    Put  a fresh variable in  the term.   The new variable lives on  the
    global  stack.   Note that the initial  variable lives on the  local
    stack  and is  lost after  a write to  the term-references.    After
    using this function, the variable will continue to live.


v_o_i_d_ PPLL__ppuutt__aattoomm((t_e_r_m___t_ -_t_,_ a_t_o_m___t_ a_))
    Put  an  atom  in the  term  reference from  a  handle.    See  also
    PPLL__nneeww__aattoomm(())and PPLL__aattoomm__cchhaarrss(()).


v_o_i_d_ PPLL__ppuutt__aattoomm__cchhaarrss((t_e_r_m___t_ -_t_,_ c_o_n_s_t_ c_h_a_r_ *_c_h_a_r_s_))
    Put an atom  in the term-reference constructed from the 0-terminated
    string.  The  string itself will never be references by Prolog after
    this function.


v_o_i_d_ PPLL__ppuutt__ssttrriinngg__cchhaarrss((t_e_r_m___t_ -_t_,_ c_o_n_s_t_ c_h_a_r_ *_c_h_a_r_s_))
    Put a string in the term-reference.  The data will be copied.


v_o_i_d_ PPLL__ppuutt__lliisstt__cchhaarrss((t_e_r_m___t_ -_t_,_ c_o_n_s_t_ c_h_a_r_ *_c_h_a_r_s_))
    Put a list of ASCII values in the term-reference.


v_o_i_d_ PPLL__ppuutt__iinntteeggeerr((t_e_r_m___t_ -_t_,_ l_o_n_g_ i_))
    Put a Prolog integer in the term reference.


v_o_i_d_ PPLL__ppuutt__ppooiinntteerr((t_e_r_m___t_ -_t_,_ v_o_i_d_ *_p_t_r_))
    Put a Prolog integer  in the term-reference.  Provided ptr is in the
    `malloc()-area', PPLL__ggeett__ppooiinntteerr(())will get the pointer back.


v_o_i_d_ PPLL__ppuutt__ffllooaatt((t_e_r_m___t_ -_t_,_ d_o_u_b_l_e_ f_))
    Put a floating-point value in the term-reference.


v_o_i_d_ PPLL__ppuutt__ffuunnccttoorr((t_e_r_m___t_ -_t_,_ f_u_n_c_t_o_r___t_ f_u_n_c_t_o_r_))
    Create  a new compound  term from f_u_n_c_t_o_r_ and  bind t_ to this  term.
    All arguments of the  term will be variables.  To create a term with
    instantiated  arguments, either instantiate the arguments  using the
    PL_unify_*() functions or use PPLL__ccoonnss__ffuunnccttoorr(()).


v_o_i_d_ PPLL__ppuutt__lliisstt((t_e_r_m___t_ -_l_))
    Same as PPLL__ppuutt__ffuunnccttoorr((l_,_ P_L___n_e_w___f_u_n_c_t_o_r_(_P_L___n_e_w___a_t_o_m_(_"_._"_)), 2)).


v_o_i_d_ PPLL__ppuutt__nniill((t_e_r_m___t_ -_l_))
    Same as PPLL__ppuutt__aattoomm__cchhaarrss(("_[_]_"_)).


v_o_i_d_ PPLL__ppuutt__tteerrmm((t_e_r_m___t_ -_t_1_,_ t_e_r_m___t_ +_t_2_))
    Make t_1_ point to the same term as t_2_.


v_o_i_d_ PPLL__ccoonnss__ffuunnccttoorr((t_e_r_m___t_ -_h_,_ f_u_n_c_t_o_r___t_ f_,_ ._._._))
    Create  a term,  whose arguments are  filled from variable  argument
    list  holding the same number of term_t objects as the arity  of the
    functor.  To create the term animal(gnu, 50), use:

            term_t a1 = PL_new_term_ref();
            term_t a2 = PL_new_term_ref();
            term_t t;

            PL_put_atom_chars(a1, "gnu");
            PL_put_integer(a2, 50);
            PL_cons_functor(t, PL_new_functor(PL_new_atom("animal"), 2),
                            a1, a2);

    After  this sequence, the term-references a_1_ and a_2_ may be  used for
    other purposes.


v_o_i_d_ PPLL__ccoonnss__lliisstt((t_e_r_m___t_ -_l_,_ t_e_r_m___t_ +_h_,_ t_e_r_m___t_ +_t_))
    Create  a list (cons-) cell in l_ from  the head and tail.   The code
    below  creates a list of  atoms from a char **.   The list is  built
    tail-to-head.   The  PL_unify_*()  functions can be  used to build  a
    list head-to-tail.

    void
    put_list(term_t l, int n, char **words)
    { term_t a = PL_new_term_ref();

      PL_put_nil(l);
      while( --n >= 0 )
      { PL_put_atom_chars(a, words[n]);
        PL_put_list(l, a, l);
      }
    }


55..66..55 UUnniiffyyiinngg ddaattaa

The  functions  of  this  sections  u_n_i_f_y_  terms  with  other  terms  or
translated C-data structures.   Except for  PPLL__uunniiffyy(()), the functions  of
this section  are specific  to SWI-Prolog.   They  have been  introduced
to make translation  of old code easier,  but also because they  provide
for a faster mechanism  for returning data to Prolog that  requires less
term-references.  Consider the case where we want  a foreign function to
return the  host name of the  machine Prolog is running  on.  Using  the
PL_get_*() and PL_put_*() functions, the code becomes:

foreign_t
pl_hostname(term_t name)
{ char buf[100];

  if ( gethostname(buf, sizeof(buf)) )
  { term_t tmp = PL_new_term_ref();

    PL_put_atom_chars(tmp, buf);
    return PL_unify(name, buf);
  }

  PL_fail;
}

Using PPLL__uunniiffyy__aattoomm__cchhaarrss(()), this becomes:

foreign_t
pl_hostname(term_t name)
{ char buf[100];

  if ( gethostname(buf, sizeof(buf)) )
    return PL_unify_atom_chars(name, buf);

  PL_fail;
}


i_n_t_ PPLL__uunniiffyy((t_e_r_m___t_ ?_t_1_,_ t_e_r_m___t_ ?_t_2_))
    Unify two Prolog terms and return non-zero on success.


i_n_t_ PPLL__uunniiffyy__aattoomm((t_e_r_m___t_ ?_t_,_ a_t_o_m___t_ a_))
    Unify t_ with the atom a_ and return non-zero on success.


i_n_t_ PPLL__uunniiffyy__aattoomm__cchhaarrss((t_e_r_m___t_ ?_t_,_ c_o_n_s_t_ c_h_a_r_ *_c_h_a_r_s_))
    Unify  t_ with  an atom  created from  c_h_a_r_s_ and  return non-zero  on
    success.


i_n_t_ PPLL__uunniiffyy__lliisstt__cchhaarrss((t_e_r_m___t_ ?_t_,_ c_o_n_s_t_ c_h_a_r_ *_c_h_a_r_s_))
    Unify t_ with a list of ASCII characters constructed from c_h_a_r_s_.


i_n_t_ PPLL__uunniiffyy__ssttrriinngg__cchhaarrss((t_e_r_m___t_ ?_t_,_ c_o_n_s_t_ c_h_a_r_ *_c_h_a_r_s_))
    Unify t_ with a Prolog string object created from c_h_a_r_s_.


i_n_t_ PPLL__uunniiffyy__iinntteeggeerr((t_e_r_m___t_ ?_t_,_ l_o_n_g_ n_))
    Unify t_ with a Prolog integer from n_.


i_n_t_ PPLL__uunniiffyy__ffllooaatt((t_e_r_m___t_ ?_t_,_ d_o_u_b_l_e_ f_))
    Unify t_ with a Prolog float from f_.


i_n_t_ PPLL__uunniiffyy__ppooiinntteerr((t_e_r_m___t_ ?_t_,_ v_o_i_d_ *_p_t_r_))
    Unify  t_ with a  Prolog integer  describing the pointer.   See  also
    PPLL__ppuutt__ppooiinntteerr(())and PPLL__ggeett__ppooiinntteerr(()).


i_n_t_ PPLL__uunniiffyy__ffuunnccttoorr((t_e_r_m___t_ ?_t_,_ f_u_n_c_t_o_r___t_ f_))
    If  t_ is a compound term with  the given functor, just succeed.   If
    it  is unbound,  create a term  and bind the  variable, else  fails.
    Not  that this function  does not create a  term if the argument  is
    already instantiated.


i_n_t_ PPLL__uunniiffyy__lliisstt((t_e_r_m___t_ ?_l_,_ t_e_r_m___t_ -_h_,_ t_e_r_m___t_ -_t_))
    Unify  l_ with a list-cell (./2).   If successful, write  a reference
    to  the head of  the list to h_  and a reference  to the tail of  the
    list  in t_.   This  reference may  be used for  subsequent calls  to
    this  function.   Suppose we  want to  return a list  of atoms  from
    a  char **.   We could  use the  example described  by PPLL__ppuutt__lliisstt(()),
    followed by  a call to PPLL__uunniiffyy(()), or we can use the code  below.  If
    the  predicate argument is unbound,  the difference is minimal  (the
    code  based on PPLL__ppuutt__lliisstt(())is  probably slightly faster).   If  the
    argument  is bound, the code below may fail before reaching  the end
    of  the word-list, but even  if the unification succeeds, this  code
    avoids a duplicate (garbage) list and a deep unification.

    foreign_t
    pl_get_environ(term_t env)
    { term_t l = PL_copy_term_ref(env);
      term_t a = PL_new_term_ref();
      extern char **environ;

      while(*environ)
      { if ( !PL_unify_list(l, a, l) ||
             !PL_unify_atom_chars(a, *environ) )
          PL_fail;
      }

      return PL_unify_nil(l);
    }


i_n_t_ PPLL__uunniiffyy__nniill((t_e_r_m___t_ ?_l_))
    Unify l_ with the atom [].


i_n_t_ PPLL__uunniiffyy__aarrgg((i_n_t_ i_n_d_e_x_,_ t_e_r_m___t_ ?_t_,_ t_e_r_m___t_ ?_a_))
    Unifies the i_n_d_e_x_-_t_h_ argument (1-based) of t_ with a_.


i_n_t_ PPLL__uunniiffyy__tteerrmm((t_e_r_m___t_ ?_t_,_ ._._._))
    Unify  t_ with a (normally) compound  term.  The remaining  arguments
    is  a  sequence  of a  type  identifier,  followed by  the  required
    arguments.      This  predicate  is  an  extension  to  the  Quintus
    and  SICStus foreign  interface  from which  the SWI-Prolog  foreign
    interface  has been  derived, but has  proved to  be a powerful  and
    comfortable  way to create compound terms from C. Due to  the vararg
    packing/unpacking and  the required type-switching this interface is
    slightly  slower than using the primitives.   Please note that  some
    bad  C-compilers have fairly low  limits on the number of  arguments
    that may be passed to a function.

    The type identifiers are:

    PL_VARIABLE nnoonnee
         No op.  Used in arguments of PL_FUNCTOR.

    PL_ATOM aattoomm__tt
         Unify the argument with an atom, as in PPLL__uunniiffyy__aattoomm(()).

    PL_INTEGER lloonngg
         Unify the argument with an integer, as in PPLL__uunniiffyy__iinntteeggeerr(()).

    PL_FLOAT ddoouubbllee
         Unify  the  argument  with  a  float,  as  in  PPLL__uunniiffyy__ffllooaatt(()).
         Note  that,  as the  argument  is  passed using  the  C  vararg
         conventions, a float must be casted to a double explicitly.

    PL_STRING ccoonnsstt cchhaarr **
         Unify   the   argument   with   a   string   object,    as   in
         PPLL__uunniiffyy__ssttrriinngg__cchhaarrss(()).

    PL_TERM tteerrmm__tt
         Unify  a  subterm.    Note  this  may the  return  value  of  a
         PPLL__nneeww__tteerrmm__rreeff(())call to get access to a variable.

    PL_CHARS ccoonnsstt cchhaarr **
         Unify the argument  with an atom,  constructed from the C  char
         *, as in PPLL__uunniiffyy__aattoomm__cchhaarrss(()).

    PL_FUNCTOR ffuunnccttoorr__tt,, ......
         Unify the argument  with a compound  term.  This  specification
         should be  followed by  exactly as many  specifications as  the
         number of arguments of the compound term.

    PL_LIST iinntt lleennggtthh,, ......
         Create  a  list  of  the  indicated  length.     The  following
         arguments contain the elements of the list.

    For  example, to  unify an argument  with the term  language(dutch),
    the following skeleton may be used:

    static functor_t FUNCTOR_language1;

    static void
    init_constants()
    { FUNCTOR_language1 = PL_new_functor(PL_new_atom("language"), 1);
    }

    foreign_t
    pl_get_lang(term_t r)
    { return PL_unify_term(r,
                           PL_FUNCTOR, FUNCTOR_language1,
                               PL_CHARS, "dutch");
    }

    install_t
    install()
    { PL_register_foreign("get_lang", 1, pl_get_lang, 0);
      init_constants();
    }


55..66..66 CCaalllliinngg PPrroolloogg ffrroomm CC

The Prolog  engine can  be called from  C. There  are to interfaces  for
this.    For the  first, a  term is  created that  could be  used as  an
argument to  ccaallll//11 and  next PPLL__ccaallll(()) is used  to call Prolog.    This
system is simple,  but does not allow  to inspect the different  answers
to  a non-deterministic  goal  and is  relatively  slow as  the  runtime
system needs  to find the predicate.   The  other interface is based  on
PPLL__ooppeenn__qquueerryy(()), PPLL__nneexxtt__ssoolluuttiioonn(())and  PPLL__ccuutt__qquueerryy(())or PPLL__cclloossee__qquueerryy(()).
This mechanism is more powerful, but also more complicated to use.


55..66..66..11 PPrreeddiiccaattee rreeffeerreenncceess

This  section  discusses   the  functions  used  to  communicate   about
predicates.   Though a Prolog predicate  may defined or not,  redefined,
etc., a Prolog predicate has a handle that is  not destroyed, nor moved.
This handle is known by the type predicate_t.


p_r_e_d_i_c_a_t_e___t_ PPLL__pprreedd((f_u_n_c_t_o_r___t_ f_,_ m_o_d_u_l_e___t_ m_))
    Return  a handle to a predicate for the specified name/arity  in the
    given module.   This function always succeeds, creating a handle for
    an undefined predicate if no handle was available.


p_r_e_d_i_c_a_t_e___t_ PPLL__pprreeddiiccaattee((c_o_n_s_t_ c_h_a_r_ *_n_a_m_e_,_ i_n_t_ a_r_i_t_y_,_ c_o_n_s_t_ c_h_a_r_*_ m_o_d_u_l_e_))

    Same   a  PPLL__pprreedd(()),   but  provides  a  more  convenient   interface
    to the C-programmer.


v_o_i_d_ PPLL__pprreeddiiccaattee__iinnffoo((p_r_e_d_i_c_a_t_e___t_ p_,_ a_t_o_m___t_ *_n_,_ i_n_t_ *_a_,_ m_o_d_u_l_e___t_ *_m_))
    Return  information on the  predicate p_.   The  name is stored  over
    n_,  the  arity  over a_,  while  m_  receives the  definition  module.
    Note  that  the  latter need  not  be  the same  as  specified  with
    PPLL__pprreeddiiccaattee(()).    If the  predicate was  imported  into the  module
    given  to PPLL__pprreeddiiccaattee(()), this function will return the  module where
    the predicate was defined.


55..66..66..22 IInniittiiaattiinngg aa qquueerryy ffrroomm CC

This  section discusses  the  functions  for creating  and  manipulating
queries from C. Note that a foreign context can have  at most one active
query.    This  implies it  is allowed  to  make strictly  nested  calls
between  C and  Prolog (Prolog  calls C,  calls Prolog,  calls C,  etc.,
but it  is nnoott  allowed to  open multiple queries  and start  generating
solutions for  each of them  by calling PPLL__nneexxtt__ssoolluuttiioonn(()).   Be sure  to
call PPLL__ccuutt__qquueerryy(()) or PPLL__cclloossee__qquueerryy(())on  any query  you opened  before
opening the next or returning control back to Prolog.


q_i_d___t_ PPLL__ooppeenn__qquueerryy((m_o_d_u_l_e___t_ c_t_x_,_ i_n_t_ f_l_a_g_s_,_ p_r_e_d_i_c_a_t_e___t_ p_,_ t_e_r_m___t_ +_t_0_))

    Opens  a query  and returns  an identifier for  it.   This  function
    always  succeeds,  regardless whether  the predicate  is defined  or
    not.    c_t_x_ is  the c_o_n_t_e_x_t_  m_o_d_u_l_e_ of  the goal.    When NULL,  the
    context  module of  the calling  context will  be used,  or user  if
    there  is no calling  context (as may  happen in embedded  systems).
    Note  that the  context module  only matters  for m_o_d_u_l_e___t_r_a_n_s_p_a_r_e_n_t_
    predicates.   See ccoonntteexxtt__mmoodduullee//11 and mmoodduullee__ttrraannssppaarreenntt//11.  The  p_
    argument  specifies the  predicate, and  should be the  result of  a
    call  to PPLL__pprreedd(()) or PPLL__pprreeddiiccaattee(()).   Note that  it is allowed  to
    store  this handle as global data  and reuse it for future  queries.
    The  term-reference t_0_ is the  first of a vector of  term-references
    as returned by PPLL__nneeww__tteerrmm__rreeffss((n_)).

    The  f_l_a_g_s_  arguments provides  some additional  options  concerning
    debugging  and  exception handling.    It  is a  bitwise or  of  the
    following values:

    PL_Q_NORMAL
         Normal operation.    The  debugger inherits  its settings  from
         the environment.   If an exception  occurs that is not  handled
         in Prolog, a  message is printed and  the tracer is started  to
         debug the error.

    PL_Q_NODEBUG
         Switch off the debugger while executing the goal.   This option
         is used by many  calls to hook-predicates to avoid  tracing the
         hooks.   An example is  pprriinntt//11 calling ppoorrttrraayy//11 from  foreign
         code.

    PL_Q_CATCH_EXCEPTION
         If an  exception is  raised while  executing the  goal, do  not
         report it, but make it available for PPLL__eexxcceeppttiioonn(()).

    PL_Q_PASS_EXCEPTION
         As PL_Q_CATCH_EXCEPTION,  but do  not invalidate the  exception-
         term  while   calling  PPLL__cclloossee__qquueerryy(()).       This  option   is
         experimental.

    The  example below opens a query to the predicate is_a/2  to find the
    ancestor of for some name.

    char *
    ancestor(const char *me)
    { term_t a0 = PL_new_term_refs(2);
      static predicate_t p;

      if ( !p )
        p = PL_predicate("is_a", 2, "database");

      PL_put_atom_chars(a0, me);
      PL_open_query(NULL, TRUE, p, a0);
      ...
    }


i_n_t_ PPLL__nneexxtt__ssoolluuttiioonn((q_i_d___t_ q_i_d_))
    Generate the first (next)  solution for the given query.  The return
    value  is TRUE if  a solution  was found, or  FALSE to indicate  the
    query  could not be proven.  This function may be  called repeatedly
    until it fails to generate all solutions to the query.


v_o_i_d_ PPLL__ccuutt__qquueerryy((q_i_d_))
    Discards  the query, but does not delete any of the data  created by
    the  query.   It just  invalidate q_i_d_,  allowing for a  new call  to
    PPLL__ooppeenn__qquueerryy(())in this context.


v_o_i_d_ PPLL__cclloossee__qquueerryy((q_i_d_))
    As  PPLL__ccuutt__qquueerryy(()),  but all  data and bindings  created by the  query
    are destroyed.


i_n_t_ PPLL__ccaallll__pprreeddiiccaattee((m_o_d_u_l_e___t_ m_,_ i_n_t_ d_e_b_u_g_,_ p_r_e_d_i_c_a_t_e___t_ p_r_e_d_,_ t_e_r_m___t_ +_t_0_))

    Shorthand   for  PPLL__ooppeenn__qquueerryy(()),   PPLL__nneexxtt__ssoolluuttiioonn(()),  PPLL__ccuutt__qquueerryy(()),
    generating  a single solution.   The arguments  are the same as  for
    PPLL__ooppeenn__qquueerryy(()), the return value is the same as PPLL__nneexxtt__ssoolluuttiioonn(()).


i_n_t_ PPLL__ccaallll((t_e_r_m___t_,_ m_o_d_u_l_e___t_))
    Call term just like  the Prolog predicate oonnccee//11.  T_e_r_m_ is called in
    the  specified module, or in the context  module if module_t  = NULL.
    Returns  TRUE if  the call succeeds,  FALSE otherwise.   Figure  5.4
    shows an example to  obtain the number of defined atoms.  All checks
    are omitted to improve readability.


55..66..77 DDiissccaarrddiinngg DDaattaa

The Prolog  data created and  term-references needed  to setup the  call
and/or analyse  the result can  in most cases  be discarded right  after
the  call.    PPLL__cclloossee__qquueerryy(())allows  for destructing  the  data,  while
leaving the  term-references.   The calls below may  be used to  destroy
term-references and data.  See figure 5.4 for an example.


f_i_d___t_ PPLL__ooppeenn__ffoorreeiiggnn__ffrraammee(())
    Created  a foreign  frame,  holding a  mark that  allows the  system
    to  undo  bindings and  destroy data  created after  it  as well  as
    providing  the  environment  for  creating term-references.     This
    function   is  called  by  the  kernel  before  calling   a  foreign
    predicate.


v_o_i_d_ PPLL__cclloossee__ffoorreeiiggnn__ffrraammee((f_i_d___t_ i_d_))
    Discard  all term-references  created  after the  frame was  opened.
    All  other Prolog data is retained.  This function is called  by the
    kernel whenever a foreign function returns control back to Prolog.


v_o_i_d_ PPLL__ddiissccaarrdd__ffoorreeiiggnn__ffrraammee((f_i_d___t_ i_d_))
    Same  as PPLL__cclloossee__ffoorreeiiggnn__ffrraammee(()), but  also undo  all bindings  made
    since the open and destroy all Prolog data.

It is obligatory to call either of the two  closing functions to discard
a foreign frame.  Foreign frames may be nested.

int
count_atoms()
{ fid_t fid = PL_open_foreign_frame();
  term_t goal  = PL_new_term_ref();
  term_t a1    = PL_new_term_ref();
  term_t a2    = PL_new_term_ref();
  functor_t s2 = PL_new_functor(PL_new_atom("statistics"), 2);

  int atoms;

  PL_put_atom_chars(a1, "atoms");
  PL_cons_functor(goal, s2, a1, a2);
  PL_call(t, NULL);         /* call it in current module */

  PL_get_integer(a2, &atoms);
  PL_discard_foreign_frame(fid);

  return atoms;
}

                      Figure 5.4:  Calling Prolog


55..66..88 FFoorreeiiggnn CCooddee aanndd MMoodduulleess

Modules are  identified via a  unique handle.   The following  functions
are available to query and manipulate modules.


m_o_d_u_l_e___t_ PPLL__ccoonntteexxtt(())
    Return the module  identifier of the context module of the currently
    active foreign predicate.


i_n_t_ PPLL__ssttrriipp__mmoodduullee((t_e_r_m___t_ +_r_a_w_,_ m_o_d_u_l_e___t_ *_m_,_ t_e_r_m___t_ -_p_l_a_i_n_))
    Utility  function.  If  r_a_w_ is a  term, possibly holding the  module
    construct  <m_o_d_u_l_e_>:<r_e_s_t_>this function will make p_l_a_i_n_ a  reference
    to  <r_e_s_t_>  and fill  m_o_d_u_l_e_ *_  with <m_o_d_u_l_e_>.    For further  nested
    module  constructs  the inner  most module  is  returned via  m_o_d_u_l_e_
    *_.   If  r_a_w_ is  not a module  construct a_r_g_ will  simply be put  in
    p_l_a_i_n_.   If m_o_d_u_l_e_ *_ is NULL  it will be set to the  context module.
    Otherwise  it will be left untouched.   The following example  shows
    how  to obtain the  plain term and module  if the default module  is
    the user module:

    { module m = PL_new_module(PL_new_atom("user"));
      term_t plain = PL_new_term_ref();

      PL_strip_module(term, &m, plain);
      ...


a_t_o_m___t_ PPLL__mmoodduullee__nnaammee((m_o_d_u_l_e___t_))
    Return the name of m_o_d_u_l_e_ as an atom.


m_o_d_u_l_e___t_ PPLL__nneeww__mmoodduullee((a_t_o_m___t_ n_a_m_e_))
    Find  an existing or create a new module with name specified  by the
    atom n_a_m_e_.


55..66..99 PPrroolloogg eexxcceeppttiioonnss iinn ffoorreeiiggnn ccooddee

This  section  discusses PPLL__eexxcceeppttiioonn(())  and PPLL__tthhrrooww(()),  the  interface
functions  to  detect  and  generate  Prolog   exceptions  from  C-code.
PPLL__tthhrrooww(())is similar to tthhrrooww//11, and  may be used to return an exception
from  a foreign  predicate.    After  calling  PPLL__tthhrrooww(()),  the  function
implementing a foreign predicate  should return failure.  If  success is
returned, the exception is simply discarded.  Calling PPLL__tthhrrooww(()) outside
the context  of a function implementing  a foreign predicate results  in
undefined behaviour.

PPLL__eexxcceeppttiioonn(()) may be used after a call to  PPLL__nneexxtt__ssoolluuttiioonn(())fails,  and
returns  a term  reference to  an  exception term  if an  exception  was
raised, and 0 otherwise.

If a  C-function, implementing a predicate  calls Prolog and detects  an
exception using PPLL__eexxcceeppttiioonn(()), it can handle this exception,  or return
with  the exception.    Some caution  is required  though.    It is  nnoott
allowed to call PPLL__cclloossee__qquueerryy(())or PPLL__ddiissccaarrdd__ffoorreeiiggnn__ffrraammee(())afterwards,
as this  will invalidate the  exception term.   Below  is the code  that
calls a Prolog defined arithmetic function (see aarriitthhmmeetthhiicc__ffuunnccttiioonn//11).

If PPLL__nneexxtt__ssoolluuttiioonn(()) succeeds, the  result is  analysed and  translated
to  a number,  after  which the  query  is closed  and all  Prolog  data
created after  PPLL__ooppeenn__ffoorreeiiggnn__ffrraammee(())is destroyed.   On the other  hand,
if PPLL__nneexxtt__ssoolluuttiioonn(())fails  and if  an exception was  raised, just  pass
it.   Otherwise  generate an exception  (PPLL__eerrrroorr(()) is an internal  call
for building  the standard error  terms and calling PPLL__tthhrrooww(())).   After
this,  the Prolog  environment should  be discarded using  PPLL__ccuutt__qquueerryy(())
and PPLL__cclloossee__ffoorreeiiggnn__ffrraammee(())to avoid invalidating the exception term.

static int
prologFunction(ArithFunction f, term_t av, Number r)
{ int arity = f->proc->definition->functor->arity;
  fid_t fid = PL_open_foreign_frame();
  qid_t qid;
  int rval;

  qid = PL_open_query(NULL, TRUE, f->proc, av);

  if ( PL_next_solution(qid) )
  { rval = valueExpression(av+arity-1, r);
    PL_close_query(qid);
    PL_discard_foreign_frame(fid);
  } else
  { term_t except;

    if ( (except = PL_exception(qid)) )
    { rval = PL_throw(except);          /* pass exception */
    } else
    { char *name = stringAtom(f->proc->definition->functor->name);

                                        /* generate exception */
      rval = PL_error(name, arity-1, NULL, ERR_FAILED, f->proc);
    }

    PL_cut_query(qid);                  /* donot destroy data */
    PL_close_foreign_frame(fid);        /* same */
  }

  return rval;
}


i_n_t_ PPLL__tthhrrooww((t_e_r_m___t_ e_x_c_e_p_t_i_o_n_))
    Generate  an exception (as  tthhrrooww//11) and return  FALSE. Below is  an
    example returning an exception from foreign predicate:

    foreign_t
    pl_hello(term_t to)
    { char *s;

      if ( PL_get_atom_chars(to, &s) )
      { Sprintf("Hello \"%s\"\n", s);

        PL_succeed;
      } else
      { term_t except = PL_new_term_ref();

        PL_unify_term(except,
                      PL_FUNCTOR, PL_new_functor(PL_new_atom("type_error"), 2),
                        PL_ATOM,    "atom",
                        PL_TERM,    to);

        return PL_throw(except);
      }
    }


t_e_r_m___t_ PPLL__eexxcceeppttiioonn((q_i_d___t_ q_i_d_))
    If  PPLL__nneexxtt__ssoolluuttiioonn(()) fails, this  can  be  due to  normal  failure
    of  the  Prolog  call, or  because  an  exception was  raised  using
    tthhrrooww//11.   This function returns  a handle to the exception term  if
    an exception was raised, or 0 if the Prolog goal simply failed..


55..66..1100 MMiisscceellllaanneeoouuss


i_n_t_ PPLL__ccoommppaarree((t_e_r_m___t_ t_1_,_ t_e_r_m___t_ t_2_))
    Compares  two terms using  the standard order  of terms and  returns
    -1, 0 or 1.  See also ccoommppaarree//33.


55..66..1111 CCaattcchhiinngg SSiiggnnaallss ((SSooffttwwaarree IInntteerrrruuppttss))

SWI-Prolog  catches the  Unix  signals SIGINT,  SIGFPE and  SIGSEGV.  To
avoid  problems with  foreign  code attempting  to catch  these  signals
foreign code  should call PPLL__ssiiggnnaall(()) to install signal handlers  rather
than the Unix library function signal().  SWI-Prolog  will always handle
SIGINT  itself.   SIGFPE  and SIGSEGV  are passed  to  the foreign  code
handlers if Prolog did not expect that signal.


v_o_i_d_ (_*_)_(_)_ PPLL__ssiiggnnaall((s_i_g_,_ f_u_n_c_))
    This  function  should be  used to  install  signal handlers  rather
    than  the Unix  library function  signal().   It ensures  consistent
    signal  handling  between   SWI-Prolog  and  the  foreign  code  and
    reinstalls  signal handlers  if a state  created with ssaavvee__pprrooggrraamm//11
    is restarted.


55..66..1122 EErrrroorrss aanndd wwaarrnniinnggss

Two standard functions are available to print standard  Prolog errors to
the standard error stream.


i_n_t_ PPLL__wwaarrnniinngg((f_o_r_m_a_t_,_ a_1_,_ ._._._))
    Print  an  error message  starting  with `[WARNING: ',  followed  by
    the  output from  f_o_r_m_a_t_, followed  by a `]'  and a newline.    Then
    start  the tracer.   f_o_r_m_a_t_ and  the arguments are  the same as  for
    pprriinnttff((2)).  Always returns FALSE.


55..66..1133 EEnnvviirroonnmmeenntt CCoonnttrrooll ffrroomm FFoorreeiiggnn CCooddee


i_n_t_ PPLL__aaccttiioonn((i_n_t_,_ C___t_y_p_e_))
    Perform  some  action on  the  Prolog system.    i_n_t_  describes  the
    action,  C___t_y_p_e_ provides the argument if necessary.   The actions are
    listed in table 5.1.
    ___________________________________________________________________
    | PL_ACTION_TRACE        |Start Prolog tracer                      |
    | PL_ACTION_DEBUG        |Switch on Prolog debug mode              |
    | PL_ACTION_BACKTRACE    |Print   backtrace   on   current   output|
    |                        |stream.   The  argument (an  int) is  the|
    |                        |number of frames printed.                |
    | PL_ACTION_HALT         |Halt  Prolog  execution.     This  action|

    |                        |should be called rather  than Unix exit()|
    |                        |to give  Prolog the opportunity  to clean|
    |                        |up.  This call does not return.          |
    | PL_ACTION_ABORT        |Generate a Prolog abort.   This call does|
    |                        |not return.                              |
    | PL_ACTION_BREAK        |Create a  standard Prolog  break environ-|
    |                        |ment.     Returns after  the  user  types|
    |                        |control-D.                               |

    | PL_ACTION_SYMBOLFILE   |The  argument (a  char  *) is  considered|
    |                        |to  be hold  the  symbolfile for  further|
    |                        |incremental   loading.        Should   be|
    |                        |called by user  applications that perform|
    |                        |incremental loading  as well and  want to|
    |________________________|inform_Prolog_of_the_new_symbol_table.___|

                     Table 5.1:  PPLL__aaccttiioonn(())options


55..66..1144 QQuueerryyiinngg PPrroolloogg


C___t_y_p_e_ PPLL__qquueerryy((i_n_t_))
    Obtain  status  information  on  the  Prolog system.     The  actual
    argument  type depends on the  information required.  i_n_t_  describes
    what information is wanted.  The options are given in table 5.2.
    ___________________________________________________________________
    | PL_QUERY_ARGC          |Return an  integer holding the  number of|
    |                        |arguments given to Prolog from Unix.     |
    | PL_QUERY_ARGV          |Return  a char  **  holding the  argument|
    |                        |vector given to Prolog from Unix.        |
    | PL_QUERY_SYMBOLFILE    |Return  a  char  *  holding  the  current|

    |                        |symbol file of the running process.      |
    | PL_QUERY_ORGSYMBOLFILE |Return  the initial  symbol file  (before|
    |                        |loading)  of  Prolog.    By  setting  the|
    |                        |symbol  file   to  this  value   no  name|
    |                        |clashes can occur  with previously loaded|
    |                        |foreign  files  (but no  symbols  can  be|
    |                        |shared  with  earlier loaded  modules  as|
    |                        |well).                                   |

    | PL_MAX_INTEGER         |Return a  long, representing  the maximal|
    |                        |integer  value  represented  by  Prolog's|
    |                        |tagged integers.                         |
    | PL_MIN_INTEGER         |Return  a long,  represented the  minimal|
    |                        |integer value.                           |
    | PL_QUERY_VERSION       |Return a  long, representing  the version|

    |                        |as 10; 000M* +100m* +p, where  M is  the |
    |                        |major,  m the  minor version  number and |
    |                        |p the  patch-level.   For  example, 20717|
    |________________________|means_2.7.17.____________________________|

                     Table 5.2:  PPLL__qquueerryy(()) options


55..66..1155 RReeggiisstteerriinngg FFoorreeiiggnn PPrreeddiiccaatteess


i_n_t_ PPLL__rreeggiisstteerr__ffoorreeiiggnn((n_a_m_e_,_ a_r_i_t_y_,_ f_u_n_c_t_i_o_n_,_ f_l_a_g_s_))
    Register  a C-function to implement a Prolog predicate.   After this
    call returns successfully  a predicate with name n_a_m_e_ (a char *) and
    arity  a_r_i_t_y_ (a C int)  is created.   When called in Prolog,  Prolog
    will  call f_u_n_c_t_i_o_n_.  f_l_a_g_s_ forms bitwise or'ed list of  options for
    the installation.  These are:
    ___________________________________________________________________
    | PL_FA_NOTRACE          |Predicate cannot be seen in the tracer   |
    | PL_FA_TRANSPARENT      |Predicate is module transparent          |
    | PL_FA_NONDETERMINISTIC |Predicate  is  non-deterministic.     See|
    |________________________|also_PPLL__rreettrryy(())._________________________|


55..66..1166 FFoorreeiiggnn CCooddee HHooookkss

For various specific applications some hooks re provided.


P_L___d_i_s_p_a_t_c_h___h_o_o_k___t_ PPLL__ddiissppaattcchh__hhooookk((P_L___d_i_s_p_a_t_c_h___h_o_o_k___t_))
    If  this hook  is not  NULL, this  function is  called when  reading
    from  the  terminal.     It is  supposed  to  dispatch  events  when
    SWI-Prolog  is connected  to a window  environment.   It can  return
    two  values:  PL_DISPATCH_INPUT indicates Prolog input is  available
    on  file descriptor 0 or PL_DISPATCH_TIMEOUT to indicate a  timeout.
    The  old hook is  returned.  The  type PL_dispatch_hook_t is  defined
    as:

    typedef int  (*PL_dispatch_hook_t)(void);


v_o_i_d_ PPLL__aabboorrtt__hhooookk((P_L___a_b_o_r_t___h_o_o_k___t_))
    Install  a hook  when aabboorrtt//00 is  executed.   SWI-Prolog aabboorrtt//00  is
    implemented  using C  setjmp()/longjmp() construct.   The hooks  are
    executed  in  the  reverse order  of  their registration  after  the
    longjmp()  took place and before  the Prolog toplevel is  reinvoked.
    The type PL_abort_hook_t is defined as:

    typedef void (*PL_abort_hook_t)(void);


i_n_t_ PPLL__aabboorrtt__uunnhhooookk((P_L___a_b_o_r_t___h_o_o_k___t_))
    Remove  a hook installed with  PPLL__aabboorrtt__hhooookk(()).   Returns FALSE if  no
    such hook is found, TRUE otherwise.


v_o_i_d_ PPLL__rreeiinniitt__hhooookk((P_L___r_e_i_n_i_t___h_o_o_k___t_))
    Install  a  hook   that  is  called  when  a  saved  program  (using
    ssaavvee__pprrooggrraamm//[[11,,22]]) is restored.   The  hooks are called in  reverse
    order.  The type PL_reinit_hook_t is defined as:

    typedef void (*PL_reinit_hook_t)(int argc, char **argv);


i_n_t_ PPLL__rreeiinniitt__uunnhhooookk((P_L___r_e_i_n_i_t___h_o_o_k___t_))
    Remove  a hook installed with PPLL__rreeiinniitt__hhooookk(()).  Returns FALSE  if no
    such hook is found, TRUE otherwise.


55..66..1177 EEmmbbeeddddiinngg SSWWII--PPrroolloogg iinn aa CC--pprrooggrraamm

As  of  version  2.1.0,  SWI-Prolog may  be  embedded  in  a  C-program.
To  reach  at  a compiled  C-program  with  SWI-Prolog  as  an  embedded
application is very  similar to creating a statically linked  SWI-Prolog
executable as described in section 5.4.1.

The  file   .../pl/include/stub.c  defines   SWI-Prologs  default   main
program:

int
main(int argc, char **argv, char **env)
{ if ( !PL_initialise(argc, argv, env) )
    PL_halt(1);

  PL_install_readline();        /* delete if you don't want readline */

  PL_halt(PL_toplevel() ? 0 : 1);
}

This  may be  replaced with  your own  main C-program.    The  interface
function  PPLL__iinniittiiaalliissee(()) mmuusstt  be   called  before  any  of  the  other
SWI-Prolog  foreign  language  functions  described  in   this  chapter.
PPLL__iinniittiiaalliissee(()) interprets all  the command-line  arguments, except  for
the -t toplevel flag that is interpreted by PPLL__ttoopplleevveell(()).


i_n_t_ PPLL__iinniittiiaalliissee((i_n_t_ a_r_g_c_,_ c_h_a_r_ *_*_a_r_g_v_,_ c_h_a_r_ *_*_e_n_v_i_r_o_n_))
    Initialises  the SWI-Prolog heap and  stacks, restores the boot  QLF
    file,  loads the system and personal initialisation files,  runs the
    aatt__iinniittiiaalliizzaattiioonn//11 hooks and finally runs the -g goal hook.

    PPLL__iinniittiiaalliissee(()) returns  1  if all  initialisation succeeded  and  0
    otherwise.    Various fatal errors  may cause  PL_initialise to  call
    PPLL__hhaalltt((1_)), preventing it from returning at all.


v_o_i_d_ PPLL__iinnssttaallll__rreeaaddlliinnee(())
    Installs  the GNU-readline line-editor.  Embedded  applications that
    do  not use the  Prolog toplevel should  normally delete this  line,
    shrinking the Prolog kernel significantly.


i_n_t_ PPLL__ttoopplleevveell(())
    Runs  the  goal of  the -t toplevel  switch  (default pprroolloogg//00)  and
    returns 1 if successful, 0 otherwise.


v_o_i_d_ PPLL__hhaalltt((i_n_t_ s_t_a_t_u_s_))
    Cleanup  the Prolog  environment and  calls exit()  with the  status
    argument.


55..77 LLiinnkkiinngg eemmbbeeddddeedd aapppplliiccaattiioonnss uussiinngg pplllldd

The utility program  plld may be used  to link a combination of  C-files
and  Prolog files  into  a  stand-alone executable.     It is  a  simple
Bourne-shell script  that automates most  of the  steps outlined in  the
previous sections.

In the normal  usage, a copy is  made of the default embedding  template
.../pl/include/stub.c.   Additional foreign  predicates are defined  and
added  to the  extension table  PL_extensions.    The  main() routine  is
modified to suit  your application.  PPLL__iinniittiiaalliissee(()) mmuusstt be passed  the
program-name (a_r_g_v_[_0_]_).   The other elements of the command-line  may be
modified.  Next, plld is typically invoked as:

plld -o output stubfile.c [other-c-or-o-files] [plfiles]

plld  will first  split the  options into  various groups  for both  the
C-compiler and the Prolog  compiler.  Next, it will add  various default
options to the  C-compiler and call it  to create an executable  holding
the  user's C-code  and the  Prolog kernel.    Then,  it  will call  the
SWI-Prolog compiler  to create a  saved state  from the provided  Prolog
files  and finally,  it  will attach  this saved  state to  the  created
emulator to create the requested executable.

Below, it  is described how the options  are split and which  additional
options are passed.

--hheellpp
    Print brief synopsis.

--ppll p_r_o_l_o_g_
    Select  the prolog to use.   This prolog  is used for two  purposes:
    get  the home-directory as well  as the compiler/linker options  and
    create a saved state of the Prolog code.

--vv
    Select  verbose operation,  showing the  various programs and  their
    options.

--oo o_u_t_f_i_l_e_
    Reserved to specify the final output file.

--lll_i_b_r_a_r_y_
    Specifies  a library for the C-compiler.   By default, -lpl  and the
    libraries needed by the Prolog kernel are given.

--LLl_i_b_r_a_r_y_-_d_i_r_e_c_t_o_r_y_
    Specifies  a library directory for the  C-compiler.  By default  the
    directory containing -lpl for the current architecture is passed.

-g | -Iinclude-directory | -Ddefinition
    These  options  are passed  to  the C-compiler.    By  default,  the
    include directory containing  SWI-Prolog.h is passed.  plld adds two
    additional * -Ddef flags:

    --DD____SWI_PROLOG__
         Indicates the code is to be connected to SWI-Prolog.

    --DD____SWI_EMBEDDED__
         Indicates the creation of an embedded program.

 *_._o_ | *_._c_ | *_._C_ | *_._c_x_x_ | *_._c_p_p_
    Passed as input files to the C-compiler

 *_._p_l_ |*_._q_l_f_
    Passed  as  input  files  to  the  Prolog  compiler  to  create  the
    saved-state.

 *
    I.e.  all other options.  These are passed as linker options  to the
    C-compiler.


55..77..11 AA ssiimmppllee eexxaammppllee

The  following is  a very  simple example  going through  all the  steps
outlined above.   It  provides an arithmetic expression  evaluator.   We
will call  the application calc  and define it in  the files calc.c  and
calc.pl.  The Prolog file is simple:

calc(Atom) :-
        term_to_atom(Expr, Atom),
        A is Expr,
        write(A),
        nl.

The  C-part  of   the  application  parses  the  command-line   options,
initialises the  Prolog engine, locates  the calc/1 predicate and  calls
it.  The coder is in figure 5.5.

#include <stdio.h>
#include <SWI-Prolog.h>

PL_extension PL_extensions [] =
{

/*{ "name",     arity,  function,       PL_FA_<flags> },*/

  { NULL,       0,      NULL,           0 }     /* terminating line */
};

#define MAXLINE 1024

int
main(int argc, char **argv, char **env)
{ char expression[MAXLINE];
  char *e = expression;
  char *program = argv[0];
  char *plav[2];
  int n;

  /* combine all the arguments in a single string */

  for(n=1; n<argc; n++)
  { if ( n != 1 )
      *e++ = ' ';
    strcpy(e, argv[n]);
    e += strlen(e);

  }

  /* make the argument vector for Prolog */

  plav[0] = program;
  plav[1] = NULL;

  /* initialise Prolog */

  if ( !PL_initialise(1, plav, env) )
    PL_halt(1);

  /* Lookup calc/1 and make the arguments and call */

  { predicate_t pred = PL_predicate("calc", 1, "user");

    term_t h0 = PL_new_term_refs(1);
    int rval;

    PL_put_atom_chars(h0, expression);
    rval = PL_call_predicate(NULL, FALSE, pred, h0);

    PL_halt(rval ? 0 : 1);

  }

  return 0;
}

             Figure 5.5:  C-source for the calc application

The application is now created using the following command-line:

% plld -o calc calc.c calc.pl

The following indicates the usage of the application:

% calc pi/2
1.5708


55..88 EExxaammppllee ooff UUssiinngg tthhee FFoorreeiiggnn IInntteerrffaaccee

Below is an example  showing all stages of the declaration of  a foreign
predicate that transforms atoms possibly holding  uppercase letters into
an atom only holding lower case letters.  Figure  5.6 shows the C-source
file, figure 5.7 illustrates compiling and loading of foreign code.
/*  Include file depends on local installation */

#include <SWI-Prolog.h>
#include <stdlib.h>
#include <ctype.h>

foreign_t
pl_lowercase(term_t u, term_t l)
{ char *copy;
  char *s, *q;

  int rval;

  if ( !PL_get_atom_chars(u, &s) )
    return PL_warning("lowercase/2: instantiation fault");
  copy = malloc(strlen(s)+1);

  for( q=copy; *s; q++, s++)

    *q = (isupper(*s) ? tolower(*s) : *s);
  *q = '\0';

  rval = PL_unify_atom_chars(l, copy);
  free(copy);

  return rval;
}

install_t
install()
{ PL_register_foreign("lowercase", 2, pl_lowercase, 0);
}

                   Figure 5.6:  Lowercase source file

% gcc -I/usr/local/lib/pl-\plversion/include -fpic -c lowercase.c
% gcc -shared -o lowercase.so lowercase.o

% pl
Welcome to SWI-Prolog (Version \plversion)
Copyright (c) 1993-1996 University of Amsterdam.  All rights reserved.

For help, use ?- help(Topic). or ?- apropos(Word).

1 ?- load_foreign_library(lowercase).

Yes
2 ?- lowercase('Hello World!', L).

L = 'hello world!'

Yes

    Figure 5.7:  Compiling the C-source and loading the object file


55..99 NNootteess oonn UUssiinngg FFoorreeiiggnn CCooddee


55..99..11 MMeemmoorryy AAllllooccaattiioonn

SWI-Prolog's  memory  allocation  is  based  on  the  mmaalllloocc((3))  library
routines.   Foreign  applications can safely  use mmaalllloocc((3)),  rreeaalllloocc((3))
and ffrreeee((3)).   Memory allocation using bbrrkk((2)) or ssbbrrkk((2)) is  not allowed
as these calls conflict with mmaalllloocc((3)).


55..99..22 DDeebbuuggggiinngg FFoorreeiiggnn CCooddee

Statically  linked foreign  code  or embedded  systems can  be  debugged
normally.     Most  modern  environments  provide  debugging  tools  for
dynamically  loaded shared  objects  or dynamic  load  libraries.    The
following example traces  the code of lowercase  using ggddbb((1)) in a  Unix
environment.

% gcc -I/usr/local/lib/pl-2.2.0/include -fpic -c -g lowercase.c
% gcc -shared -o lowercase.so lowercase.o
% gdb pl
(gdb) r
Welcome to SWI-Prolog (Version \plversion)
Copyright (c) 1993-1996 University of Amsterdam.  All rights reserved.

For help, use ?- help(Topic). or ?- apropos(Word).

?- load_foreign_library(lowercase).
<type Control-C>
(gdb) shared                    % loads symbols for shared objects
(gdb) break pl_lowercase
(gdb) continue
?- lowercase('HELLO', X).


55..99..33 NNaammee CCoonnfflliiccttss iinn CC mmoodduulleess

In  the  current  version  of the  system  all  public  C  functions  of
SWI-Prolog are in the symbol table.  This can lead  to name clashes with
foreign code.    Someday I  should write a  program to  strip all  these
symbols from the symbol table  (why does Unix not have that?).   For now
I can only suggest to give your function another name.   You can do this
using the C preprocessor.  If---for example---your  foreign package uses
a function warning(), which happens to exist in SWI-Prolog  as well, the
following macro should fix the problem.

#define warning warning_

Note  that shared  libraries do  not  have this  problem as  the  shared
library loader  will only look  for symbols in  the main executable  for
symbols that are not defined in the library itself.


55..99..44 CCoommppaattiibbiilliittyy ooff tthhee FFoorreeiiggnn IInntteerrffaaccee

The term-reference  mechanism was first used  by Quintus Prolog  version
3.     SICStus  Prolog version  3  is  strongly  based  on  the  Quintus
interface.  The  described SWI-Prolog interface is similar to  using the
Quintus or SICStus interfaces, defining all  foreign-predicate arguments
of  type  +term.    SWI-Prolog  explicitly uses  type  functor_t,  while
Quintus  and SICStus  uses <n_a_m_e_>  and  <a_r_i_t_y_>.   As  the  names of  the
functions differ  from Prolog to  Prolog, a  simple macro layer  dealing
with the names can also deal with this detail.  For example:

#define QP_put_functor(t, n, a) PL_put_functor(t, PL_new_functor(n, a))

The  PL_unify_*()  functions are  lacking from  the  Quintus and  SICStus
interface.    They can  easily  be emulated  or the  put/unify  approach
should be used to write compatible code.

The PPLL__ooppeenn__ffoorreeiiggnn__ffrraammee(())/PPLL__cclloossee__ffoorreeiiggnn__ffrraammee(())combination  is lacking
from both  other Prologs.   SICStus has  PPLL__nneeww__tteerrmm__rreeffss((0_)), followed  by
PPLL__rreesseett__tteerrmm__rreeffss(())that allows for discarding term references.

The  Prolog interface  for  the graphical  user interface  package  XPCE
shares about  90% of the code  using a simple  macro layer to deal  with
different naming and calling conventions of the interfaces.


CChhaapptteerr 66..  GGEENNEERRAATTIINNGG RRUUNNTTIIMMEE AAPPPPLLIICCAATTIIOONNSS

This  chapter  describes  the  features  of  SWI-Prolog  for  delivering
applications that can run without the development version  of the system
installed.

A SWI-Prolog  built application  consists of  at least two  parts:   the
emulator  and the  compiled application.    The latter  is  in the  same
format  as a  SWI-Prolog  boot-file  and SWI-Prolog  pre-compiled  (QLF)
file.   This  format is  fast loadable  and abstracted  just far  enough
to  be machine  independent.    This  implies an  application  delivered
in  binary format  can run  on any  computer for  which  an emulator  is
available without modification.


qqssaavvee__pprrooggrraamm((+_F_i_l_e_,_ +_L_i_s_t_O_f_O_p_t_i_o_n_s_))
    Saves  the current  state of  the program  to the  file F_i_l_e_.    The
    result is an  executable shell-script, that will start the emulator.
    L_i_s_t_O_f_O_p_t_i_o_n_s_ is a list of <K_e_y_>= <V_a_l_u_e_>pairs.  The available keys
    are described in table 6.1.
 _______________________________________________________________________
 |__KKeeyy________________||OOppttiioonn__||________TTyyppee__________||DDeessccrriippttiioonn______________________________________________||__
 || local      | --LL   ||   K-bytes    |Size (Limit) of local stack       |
 | global     | --GG   ||   K-bytes    |Size (Limit) of global stack      |
 | trail      | --TT   ||   K-bytes    |Size (Limit) of trail stack       |
 | argument   | --AA   ||   K-bytes    |Size (Limit) of argument stack    |
 | goal       | --gg   ||     atom     |Initialisation goal               |
 | toplevel   | --tt   ||     atom     |Prolog toplevel goal              |

 |_init_file___|--ff___||_____atom_____|Personal_initialisation_file______|_
 | autoload   |      |     bool     |If true, run aauuttoollooaadd//00 first     |
 | map        |      |     atom     |File containing info on dump      |
 | op         |      |save/standard |Save operator declarations?       |
 |_stand_alone_|_____|_____bool_____|Include_the_emulator_in_the_state_|_

          Table 6.1:  <K_e_y_> = <V_a_l_u_e_> pairs for qqssaavvee__pprrooggrraamm//22

    The /bin/sh script contains the following data:

     1.  The s_h_e_l_l_ s_c_r_i_p_t_ h_e_a_d_e_r_ starts as:

         #!/bin/sh
         #SAVE-VERSION=<num>
         #PROLOG-VERSION=<num>
         exec ${SWIPL-/path-to-emulator} -x $0 "$@"

     2.  The  s_e_t_t_i_n_g_s_  s_e_c_t_i_o_n_ contains  the  default  values  for  the
         various command line options.

     3.  The  p_r_e_d_i_c_a_t_e_s_  s_e_c_t_i_o_n_  contains  all  predicates   from  the
         currently running  system.   Clauses of  predicates defined  as
         v_o_l_a_t_i_l_e_ (see vvoollaattiillee//11) are  nnoott saved.  Neither  are foreign
         predicates (see also below).

     4.  The r_e_c_o_r_d_  s_e_c_t_i_o_n_ contains  the database  records saved  with
         rreeccoorrddaa//33  and friends.    The  current version  saves  records
         using directives.

     5.  The f_l_a_g_  s_e_c_t_i_o_n_ contains  the  global flags  saved using  the
         ffllaagg//33 predicate.  Flags are saved as directives.

     6.  The  f_e_a_t_u_r_e_  s_e_c_t_i_o_n_   contains  all  features  that  do   not
         originate from the emulator itself.  See sseett__ffeeaattuurree//22.

     7.  The i_m_p_o_r_t_  s_e_c_t_i_o_n_ contains  the imports  as far  as they  are
         not handled  by the  auto-import system.   That  is, an  import
         is stored  if the module  is user or  the module user  contains
         a  different definition  as  the  one imported  in  the  target
         module.'

    Before   writing  the  data   to  file,   qqssaavvee__pprrooggrraamm//22 will   run
    aauuttoollooaadd//00  to all  required  autoloading the  system can  discover.
    See aauuttoollooaadd//00.

    Provided  the  application  does  not  require  any  of  the  Prolog
    libraries  to  be  loaded  at  runtime,   the  only  file  from  the
    SWI-Prolog development  environment required is the emulator itself.
    The  emulator may  be built in  two flavours.   The  default is  the
    d_e_v_e_l_o_p_m_e_n_t_  e_m_u_l_a_t_o_r_.  The  r_u_n_t_i_m_e_ e_m_u_l_a_t_o_r_ is similar, but  lacks
    the  tracer.  The stand-alone program cchhppll((1)) may be used  to change
    the default path to the emulator.

    If the  option stand_alone(on)is present,  the emulator is prepended
    for  the  state.    If  the emulator  is  started  and no  state  is
    specified  using  the -x  flag,  it will  test whether  a  boot-file
    (state)  is attached  to the  emulator itself and  load this  state.
    Provided  the application  has all libraries  loaded, the  resulting
    file may be started anywhere.


qqssaavvee__pprrooggrraamm((+_F_i_l_e_))
    Equivalent to qsave_program(File, []).


aauuttoollooaadd
    Check  the current Prolog program  for predicates that are  referred
    to,  are  undefined and  have a  definition in  the Prolog  library.
    Load the appropriate libraries.

    This  predicate is used  by qqssaavvee__pprrooggrraamm//[[11,,22]] to ensure the  saved
    state  will not  depend  on one  of the  libraries.   The  predicate
    aauuttoollooaadd//00  will find all ddiirreecctt references to predicates.   It does
    not  find predicates referenced via meta-predicates.   The predicate
    log/2  is  defined  in the  library(quintus)  to provide  a  quintus
    compatible means to compute  the natural logarithm of a number.  The
    following program will  behave correctly if its state is executed in
    an environment where the library(quintus) is not available:

    logtable(From, To) :-
            From > To, !.
    logtable(From, To) :-
            log(From, Value),
            format('~d~t~8|~2f~n', [From, Value]),
            F is From + 1,
            logtable(F, To).

    However,  the following implementation  refers to log/2 through  the
    meta-predicate  mmaapplliisstt//33.   Autoload will not  be able to find  the
    reference.   This problem may be fixed either by loading  the module
    libtary(quintus)  explicitly or  use  rreeqquuiirree//11 to  tell the  system
    that the predicate log/2 is required by this module.

    logtable(From, To) :-
            findall(X, between(From, To, X), Xlist),
            maplist(log, Xlist, SineList),
            write_table(Xlist, SineList).

    write_table([], []).
    write_table([I|IT], [V|VT]) :-
            format('~d~t~8|~2f~n', [I, V]),
            write_table(IT, VT).


vvoollaattiillee +_N_a_m_e_/_A_r_i_t_y_,_ ._._._
    Declare  that  the clauses  of specified  predicates  should nnoott  be
    saved  to the program.   The  volatile declaration is normally  used
    to avoid that  the clauses of dynamic predicates that represent data
    for the current session is saved in the state file.


66..11 LLiimmiittaattiioonnss ooff qqssaavvee__pprrooggrraamm

There  are  three  areas  that  require  special  attention  when  using
qqssaavvee__pprrooggrraamm//[[11,,22]].

  o If  the  program  is an  embedded  Prolog  application or  uses  the
    foreign  language interface,  care has  to be taken  to restore  the
    appropriate foreign context.  See section 6.2 for details.

  o If  the program uses directives (:- goal. lines) that  perform other
    actions then  setting predicate attributes (dynamic, volatile, etc.)
    or  loading files  (consult,  etc.), the  directive may  need to  be
    prefixed with iinniittiiaalliizzaattiioonn//11.

  o `Database references as  returned by ccllaauussee//33, rreeccoorrddeedd//33, etc.  are
    not preserved and may thus not be part of the database when saved.


66..22 RRuunnttiimmeess aanndd FFoorreeiiggnn CCooddee

Some  applications may  need  to  use the  foreign  language  interface.
Object code is  by definition machine-dependent and thus cannot  be part
of the saved program file.

To complicate the matter even further there are various  ways of loading
foreign code:

  o U_s_i_n_g_ t_h_e_ l_i_b_r_a_r_y_(_s_h_l_i_b_)_ p_r_e_d_i_c_a_t_e_s_
    This  is the preferred way of dealing  with foreign code.   It loads
    quickly and ensures  an acceptable level of independence between the
    versions  of the emulator  and the  foreign code loaded.   It  works
    on  Unix machines supporting shared libraries and  library functions
    to  load them.   Most modern  Unixes satisfy this  constraint..   It
    also  works on the Win32 platform:  Windows-NT, '95 and  Windows 3.1
    running win32s.

  o S_t_a_t_i_c_ l_i_n_k_i_n_g_
    This  mechanism works on  all machines,  but generally requires  the
    same  C-compiler and linker to be  used for the external code as  is
    used  to build SWI-Prolog itself.   This mechanism is the  preferred
    way if shared libraries are not supported.

  o U_s_i_n_g_ llooaadd__ffoorreeiiggnn//22,_5_
    ]  Basically only works on  Unix system supporting the a.out  format
    executables.   This mechanism is  slow and non-portable.  It  should
    be avoided whenever possible.

To make  a runtime  executable that  can run on  multiple platforms  one
must make runtime  checks to find the correct  way of linking.   Suppose
we have  a source-file  myextension defining  the installation  function
iinnssttaallll(()).

If  this file  is compiled  to a  shared library,  llooaadd__ffoorreeiiggnn__lliibbrraarryy//11
will load this library and call the installation  function to initialise
the  foreign code.    If it  is  loaded as  a static  extension,  define
iinnssttaallll(()) as the predicate iinnssttaallll//00:

static foreign_t
pl_install()
{ install();

  PL_succeed;
}

PL_extension PL_extensions [] =
{
/*{ "name",     arity,  function,       PL_FA_<flags> },*/

  { "install",  0,      pl_install,     0 },
  { NULL,       0,      NULL,           0 }     /* terminating line */
};

Now, use the following Prolog code to load the foreign library:

load_foreign_extensions :-
        current_predicate(install, install), !, % static loaded
        install.
load_foreign_extensions :-                      % shared library
        load_foreign_library(foreign(myextension)).

:- initialization load_foreign_extensions.

The path  alias foreign  is defined  by ffiillee__sseeaarrcchh__ppaatthh//22.   By  default
it  searches  the  directories <h_o_m_e_>/lib/<a_r_c_h_> and  <h_o_m_e_>/lib.     The
application can specify additional rules for ffiillee__sseeaarrcchh__ppaatthh//22.


66..33 FFiinnddiinngg AApppplliiccaattiioonn ffiilleess

If your application  uses files that are  not part of the saved  program
such as database  files, configuration files, etc., the  runtime version
has to be able  to locate these files.   The ffiillee__sseeaarrcchh__ppaatthh//22mechanism
in combination with  the -palias command-line argument is the  preferred
way to  locate runtime  files.   The first  step is to  define an  alias
for the  toplevel directory  of your  application.   We  will call  this
directory gnatdir in our examples.

A  good  place  for storing  data  associated  with  SWI-Prolog  runtime
systems is  below the emulator's  home-directory.   swi is a  predefined
alias for this directory.  The following is  a useful default definition
for the search path.

user:file_search_path(gnatdir, swi(gnat)).

The  application  should  locate   all  files  using  absolute_file_name.
Suppose   gnatdir   contains   a  file   config.pl   to   define   local
configuration.  Then use the code below to load this file:

configure_gnat :-
        (   absolute_file_name(gnatdir('config.pl'), ConfigFile)
        ->  consult(ConfigFile)
        ;   format(user_error, 'gnat: Cannot locate config.pl~n'),
            halt(1)
        ).


66..44 UUssiinngg cchhppll ffoorr CCoonnffiigguurraattiioonn IInnffoorrmmaattiioonn


66..44..11 CChhaannggiinngg tthhee eemmuullaattoorr ooff aa rruunnttiimmee aapppplliiccaattiioonn

The program chpl, may  be used to manipulate the header of  a SWI-Prolog
bootfile or state created with qqssaavvee__pprrooggrraamm//[[11,,22]].

It will be used  most commonly by the installer of a  SWI-Prolog runtime
application  to specify  the path  to the  emulator.    If the  end-user
decided to install the SWI-Prolog runtime environment in

/usr/local/lib/rt-pl-2.1.4

the gnat application can be told to use this emulator using:

% /usr/local/lib/rtpl-2.1.4/bin/chpl -e /usr/local/lib/rt-pl-
2.1.4/bin/pl gnat

Now,  gnat may  be  installed in  any public  or private  directory  for
binaries.


66..44..22 PPaassssiinngg aa ppaatthh ttoo tthhee aapppplliiccaattiioonn

Suppose   the  system   administrator  has   installed  the   SWI-Prolog
runtime  environment  in  /usr/local/lib/rt-pl-2.1.4.     A  user  wants
to  install  gnat,   but  gnat  will  look  for  its   configuration  in
/usr/local/lib/rt-pl-2.1.4/gnat where the user cannot write.

The   user   decides   to   install   the   gnat    runtime   files   in
/users/bob/lib/gnat.     For   one-time  usage,  the  user   may  decide
to start gnat using the command:

% gnat -p gnatdir=/users/bob/lib/gnat

For a more  widely used executable, this is  not very comfortable.   The
user may decide  to edit the shell-script part  of gnat.  Upto the  line
holding

# End Header

gnat is a  simple /bin/sh script.   After this line, the file is  binary
and may  contain long lines.   Most editors  are not capable of  editing
such files.   Instead of editing the file directly, the  program cchhppll((1))
may be used  to extract and replace the  header of gnat.  The  following
editing sequence  will work  with any  editor capable  of editing  ASCII
files.

% chpl -x gnat > gnat.hdr
% emacs gnat.hdr
% chpl -h gnat.hdr gnat

The header may be changed to the following to install gnat properly:

#!/bin/sh
# SWI-Prolog version: 2.1.4
# SWI-Prolog save-version: 25
exec ${SWIPL-/usr/local/lib/rt-pl-2.1.4/bin/pl} -x $0 \
     -p gnatdir=/users/bob/lib/gnat "$@"


66..55 TThhee RRuunnttiimmee EEnnvviirroonnmmeenntt


66..55..11 TThhee RRuunnttiimmee EEmmuullaattoorr

The sources  may be  used to built  two versions  of the emulator.    By
default,  the d_e_v_e_l_o_p_m_e_n_t_ e_m_u_l_a_t_o_r_  is built.    This emulator  contains
all features  for interactive development  of Prolog  applications.   If
the system is  configured using --enable-runtime, mmaakkee((1)) will  create a
r_u_n_t_i_m_e_ v_e_r_s_i_o_n_  of the emulator.   This emulator  is equivalent to  the
development version, except for the following features:

  o N_o_ i_n_p_u_t_ e_d_i_t_i_n_g_
    The  GNU library -lreadline  that provides EMACS compatible  editing
    of input lines will not be linked to the system.

  o N_o_ t_r_a_c_e_r_
    The  tracer and  all its options  are removed,  making the system  a
    little faster too.

  o N_o_ p_r_o_f_i_l_e_r_
    pprrooffiillee//33 and friends are  not supported.  This saves some space and
    provides better performance.

  o N_o_ i_n_t_e_r_r_u_p_t_
    Keyboard  interrupt (Control-C  normally)  is not  rebound and  will
    normally terminate the application.

  o f_e_a_t_u_r_e_(_r_u_n_t_i_m_e_,_ t_r_u_e_)_ s_u_c_c_e_e_d_s_
    This  may  be used  to verify  your application  is  running in  the
    runtime environment rather than the development environment.

  o ccllaauussee//[[22,,33]] d_o_ n_o_t_ w_o_r_k_ o_n_ s_t_a_t_i_c_ p_r_e_d_i_c_a_t_e_s_
    This  feature inhibits  listing your  program.   It is  only a  very
    limited protection however.

The  following  fragment   is  an  example  for  building  the   runtime
environment in  HOME/lib/rt-pl-2.1.4.   If possible, the  shared-library
interface should be configured to ensure it can serve  a large number of
applications.

% cd pl-2.1.4
% mkdir runtime
% cd runtime
% ../src/configure --enable-runtime --prefix=$HOME
% make
% make rt-install

The  runtime directory  contains  the components  listed  below.    This
directory may be tar'ed and shipped with your application.

            ________________________________________________
            |_README.RT__|Info_on_the_runtime_environment___|
            | bin/pl     |The emulator itself               |

            |_bin/chpl___|The_utility_to_change_the_runtime_|
            | man/chpl.1 |Manual page for chpl              |
            |_man/pl.1___|Manual_page_for_pl________________|
            |_swipl______|pointer_to_the_home_directory_(.)_|
            | lib/       |directory for shared libraries    |
            |_lib/<a_r_c_h_>/|machine-specific_shared_libraries_|


CChhaapptteerr 77..  HHAACCKKEERRSS CCOORRNNEERR

This  appendix  describes  a  number  of  predicates  which  enable  the
Prolog  user  to  inspect the  Prolog  environment  and  manipulate  (or
even redefine)  the debugger.    They can be  used as  entry points  for
experiments with debugging  tools for Prolog.  The  predicates described
here should  be handled  with some  care as it  is easy  to corrupt  the
consistency of the Prolog system by misusing them.


77..11 EExxaammiinniinngg tthhee EEnnvviirroonnmmeenntt SSttaacckk


pprroolloogg__ccuurrrreenntt__ffrraammee((-_F_r_a_m_e_))
    Unify   F_r_a_m_e_  with  an  integer   providing  a  reference  to   the
    parent  of  the  current  local stack  frame.    A  pointer  to  the
    current  local frame  cannot be provided  as the predicate  succeeds
    deterministically  and therefore its frame is  destroyed immediately
    after succeeding.


pprroolloogg__ffrraammee__aattttrriibbuuttee((+_F_r_a_m_e_,_ +_K_e_y_,_ -_V_a_l_u_e_))
    Obtain  information  about  the local  stack  frame  F_r_a_m_e_.    F_r_a_m_e_
    is  a  frame reference  as  obtained through  pprroolloogg__ccuurrrreenntt__ffrraammee//11,
    pprroolloogg__ttrraaccee__iinntteerrcceeppttiioonn//44or  this predicate.   The key values  are
    described below.

    aalltteerrnnaattiivvee
         V_a_l_u_e_ is unified with  an integer reference to the  local stack
         frame in  which execution  is  resumed if  the goal  associated
         with F_r_a_m_e_  fails.    Fails  if the  frame has  no  alternative
         frame.

    hhaass__aalltteerrnnaattiivveess
         V_a_l_u_e_ is unified  with true if F_r_a_m_e_  still is a candidate  for
         backtracking.  false otherwise.

    ggooaall
         V_a_l_u_e_ is unified with the  goal associated with F_r_a_m_e_.   If the
         definition module of the active predicate is not  user the goal
         is represented as <m_o_d_u_l_e_>:<g_o_a_l_>.  Do not instantiate variables
         in this goal unless you kknnooww what you are doing!

    ccllaauussee
         V_a_l_u_e_ is  unified with  a  reference to  the currently  running
         clause.    Fails  if the  current  goal  is associated  with  a
         foreign  (C) defined  predicate.    See  also  nntthh__ccllaauussee//33 and
         ccllaauussee__pprrooppeerrttyy//22.

    lleevveell
         V_a_l_u_e_ is unified  with the recursion level  of F_r_a_m_e_.  The  top
         level frame is at level `0'.

    ppaarreenntt
         V_a_l_u_e_ is unified with an integer reference to  the parent local
         stack frame of F_r_a_m_e_.  Fails if F_r_a_m_e_ is the top frame.

    ccoonntteexxtt__mmoodduullee
         V_a_l_u_e_ is  unified with the  name of the  context module of  the
         environment.

    ttoopp
         V_a_l_u_e_ is  unified with  true if F_r_a_m_e_  is the  top Prolog  goal
         from a recursive  call back from the  foreign language.   false
         otherwise.

    hhiiddddeenn
         V_a_l_u_e_ is  unified with  true if the  frame is  hidden from  the
         user, either  because a  parent has  the hide-childs  attribute
         (all  system  predicates),  or  the  system   has  no  trace-me
         attribute.

    ppcc
         V_a_l_u_e_ is unified with  the program-pointer saved on behalve  of
         the parent-goal if  the parent-goal is  not owned by a  foreign
         predicate.

    aarrgguummeenntt((N_))
         V_a_l_u_e_ is  unified with the N_-th  slot of the  frame.   Argument
         1 is  the first  argument of  the goal.    Arguments above  the
         arity refer to local variables.  Fails silently if N_  is out of
         range.


77..22 IInntteerrcceeppttiinngg tthhee TTrraacceerr


pprroolloogg__ttrraaccee__iinntteerrcceeppttiioonn((+_P_o_r_t_,_ +_F_r_a_m_e_,_ +_P_C_,_ -_A_c_t_i_o_n_))
    Dynamic  predicate, normally not defined.  This predicate  is called
    from  the SWI-Prolog debugger just before it would show a port.   If
    this  predicate succeeds the debugger  assumes the trace action  has
    been  taken care of and continues execution as described  by A_c_t_i_o_n_.
    Otherwise the normal Prolog debugger actions are performed.

    P_o_r_t_  is one  of call,  redo,  exit, fail  or unify.    F_r_a_m_e_ is  an
    integer  reference to  the current  local stack frame.    P_C_ is  the
    current  value  of the  program-counter, relative  to  the start  of
    the  current clause,  or 0  if it  is invalid,  for example  because
    the  current frame runs a foreign  predicate, or no clause has  been
    selected  yet.    A_c_t_i_o_n_ should  be unified  with one  of the  atoms
    continue  (just continue execution), retry (retry the  current goal)
    or fail (force the  current goal to fail).  Leaving it a variable is
    identical to continue.

    Together  with  the predicates  described in  section  3.37 and  the
    other  predicates of this chapter this predicate enables  the Prolog
    user  to define a complete new debugger in Prolog.  Besides  this it
    enables  the Prolog programmer monitor  the execution of a  program.
    The  example below records  all goals trapped  by the tracer in  the
    database.

    prolog_trace_interception(Port, Frame, _PC, continue) :-
            prolog_frame_attribute(Frame, goal, Goal),
            prolog_frame_attribute(Frame, level, Level),
            recordz(trace, trace(Port, Level, Goal)).

    To  trace the execution of `go' this way the following  query should
    be given:

    ?- trace, go, notrace.


pprroolloogg__sskkiipp__lleevveell((-_O_l_d_,_ +_N_e_w_))
    Unify  O_l_d_ with  the old  value of `skip  level' and  than set  this
    level  according to N_e_w_.   New  is an integer,  or the special  atom
    very_deep  (meaning don't  skip).    The `skip  level' is  a  global
    variable  of the  Prolog system  that disables the  debugger on  all
    recursion  levels deeper than  the level of the  variable.  Used  to
    implement  the trace options  `skip' (sets skip  level to the  level
    of  the frame) and `up' (sets skip level to the level of  the parent
    frame (i.e. the level of this frame minus 1).


77..33 EExxcceeppttiioonn HHaannddlliinngg

A  start has  been made  to  make exception  handling available  to  the
Prolog user.   On exceptions a  dynamic and multifile defined  predicate
eexxcceeppttiioonn//33 is called.   If this user defined predicate  succeeds Prolog
assumes the  exception has  been taken care  of.   Otherwise the  system
default exception handler is called.


eexxcceeppttiioonn((+_E_x_c_e_p_t_i_o_n_,_ +_C_o_n_t_e_x_t_,_ -_A_c_t_i_o_n_))
    Dynamic  predicate,  normally not  defined.   Called  by the  Prolog
    system  on run-time exceptions.  Currently eexxcceeppttiioonn//33 is  only used
    for  trapping undefined  predicates.   Future versions might  handle
    signal  handling, floating exceptions  and other runtime errors  via
    this mechanism.  The values for E_x_c_e_p_t_i_o_n_ are described below.

    uunnddeeffiinneedd__pprreeddiiccaattee
         If E_x_c_e_p_t_i_o_n_ is undefined_predicate C_o_n_t_e_x_t_ is  instantiated to
         a term N_a_m_e_/A_r_i_t_y_.   N_a_m_e_ refers to  the name and A_r_i_t_y_ to  the
         arity of  the undefined predicate.    If the definition  module
         of the  predicate is  not u_s_e_r_,  C_o_n_t_e_x_t_  will be  of the  form
         <M_o_d_u_l_e_>:<N_a_m_e_>/<A_r_i_t_y_>.    If the  predicate  fails Prolog  will
         print the  default error  warning  and start  the tracer.    If
         the predicate succeeds it should instantiate the  last argument
         either to the  atom fail to tell  Prolog to fail the  predicate
         or the atom retry to tell Prolog to retry the predicate.   This
         only  makes sense  if the  exception  handler has  defined  the
         predicate.  Otherwise it will lead to a loop.

    wwaarrnniinngg
         If prolog  wants to  give a warning  while reading  a file,  it
         will first raise the  exception w_a_r_n_i_n_g_.  The  context argument
         is  a  term  of  the  form  warning(<P_a_t_h_>, <L_i_n_e_N_o_>, <M_e_s_s_a_g_e_>),
         where P_a_t_h_  is  the absolute  filename of  the  file prolog  is
         reading; L_i_n_e_N_o_  is an  estimate of the  line number where  the
         error occurred and  M_e_s_s_a_g_e_ is a  Prolog string indicating  the
         message.    The A_c_t_i_o_n_  argument  is ignored.    The  error  is
         supposed to be presented  to the user if the  exception handler
         succeeds.   Otherwise  the standard Prolog  warning message  is
         printed.

         This exception  is used  by the library(emacs_interface),  that
         integrates error handling with GNU Emacs.


77..44 RReeaaddlliinnee IInntteerraaccttiioonn

The  following  predicates  are  available   if  feature(readline, true)
succeeds.    They allow  for direct  interaction with  the GNU  readline
library.  See also rreeaaddlliinnee((3))


rrll__rreeaadd__iinniitt__ffiillee((+_F_i_l_e_))
    Read  a readline  initialisation file.   Readline  by default  reads
    ~/.inputrc.     This  predicate  may be  used  to  read  alternative
    readline initialisation files.


rrll__aadddd__hhiissttoorryy((+_L_i_n_e_))
    Add  a  line  to  the  Control-P/Control-N  history  system  of  the
    readline library.


CChhaapptteerr 88..  SSUUMMMMAARRYY


88..11 PPrreeddiiccaatteess

The  predicate summary  is used  by the  Prolog  predicate aapprrooppooss//11  to
suggest predicates from a keyword.

 !/0                           Cut (discard choicepoints)
 !/1                           Cut block.  See bblloocckk//33
 ,/2                           Conjunction of goals
 ->/2                          If-then-else
 *->/2                         Soft-cut
 ./2                           Consult.  Also list constructor
 ;/2                           Disjunction of goals.  Same as |//22
 </2                           Arithmetic smaller

 =/2                           Unification
 =../2                         ``Univ.''  Term to list conversion
 =:=/2                         Arithmetic equal
 =</2                          Arithmetic smaller or equal
 ==/2                          Identical
 =@=/2                         Structural identical
 =\=/2                         Arithmetic not equal

 >/2                           Arithmetic larger
 >=/2                          Arithmetic larger or equal
 @</2                          Standard order smaller
 @=</2                         Standard order smaller or equal
 @>/2                          Standard order larger
 @>=/2                         Standard order larger or equal
 \+/1                          Negation by failure.  Same as nnoott//11
 \=/2                          Not unifyable

 \==/2                         Not identical
 \=@=/2                        Not structural identical
 ^/2                           Existential quantification (bbaaggooff//33, sseettooff//33)
 |/2                           Disjunction of goals.  Same as ;//22
 abolish/1                     Remove predicate definition from the database
 abolish/2                     Remove predicate definition from the database
 abort/0                       Abort execution, return to top level

 absolute_file_name/2          Get absolute path name
 absolute_file_name/3          Get absolute path name with options
 access_file/2                 Check access permissions of a file
 append/1                      Append to a file
 append/3                      Concatenate lists
 apply/2                       Call goal with additional arguments
 apropos/1                     library(online_help) Show related predicates and manual sections
 arg/3                         Access argument of a term

 arithmetic_function/1         Register an evaluable function
 assert/1                      Add a clause to the database
 assert/2                      Add a clause to the database, give reference
 asserta/1                     Add a clause to the database (first)
 asserta/2                     Add a clause to the database (first)
 assertz/1                     Add a clause to the database (last)
 assertz/2                     Add a clause to the database (last)

 at_end_of_stream/0            Test for end of file on input
 at_end_of_stream/1            Test for end of file on stream
 at_halt/1                     Register goal to run at hhaalltt//11
 at_initialization/1           Register goal to run at start-up
 atom/1                        Type check for an atom
 atom_char/2                   Convert between atom and ASCII value
 atom_chars/2                  Convert between atom and list of ASCII values
 atom_length/2                 Determine length of an atom

 atom_prefix/2                 Test for start of atom
 atom_to_term/3                Convert between atom and term
 atomic/1                      Type check for primitive
 autoload/0                    Autoload all predicates now
 bagof/3                       Find all solutions to a goal
 between/3                     Integer range checking/generating
 block/3                       Start a block (`catch'/`throw')

 break/0                       Start interactive toplevel
 call/1                        Call a goal
 call/[2..]                    Call with additional arguments
 call_dll_function/2           Win32:  Call function in dynamic link library (.dll file)
 call_shared_object_function/2 UNIX: Call C-function in shared (.so) file
 call_with_depth_limit/3       Prove goal with bounded depth
 catch/3                       Call goal, watching for exceptions
 character_count/2             Get character index on a stream

 chdir/1                       Change working directory
 checklist/2                   Invoke goal on all members of a list
 clause/2                      Get clauses of a predicate
 clause/3                      Get clauses of a predicate
 clause_property/2             Get properties of a clause
 close/1                       Close stream
 close_dde_conversation/1      Win32:  Close DDE channel

 close_dll/1                   Win32:  Close dynamic link library (.dll file)
 close_shared_object/1         UNIX: Close shared library (.so file)
 compare/3                     Compare, using a predicate to determine the order
 compiling/0                   Is this a compilation run?
 compound/1                    Test for compound term
 concat/3                      Append two atoms
 concat_atom/2                 Append a list of atoms
 concat_atom/3                 Append a list of atoms with separator

 consult/1                     Read (compile) a Prolog source file
 context_module/1              Get context module of current goal
 convert_time/8                Convert time stamp
 copy_term/2                   Make a copy of a term
 current_arithmetic_function/1 Examine evaluable functions
 current_atom/1                Examine existing atoms
 current_flag/1                Examine existing flags

 current_foreign_library/2     library(shlib) Examine loaded shared libraries (.so files)
 current_functor/2             Examine existing name/arity pairs
 current_input/1               Get current input stream
 current_key/1                 Examine existing database keys
 current_module/1              Examine existing modules
 current_module/2              Examine existing modules
 current_op/3                  Examine current operator declarations
 current_output/1              Get the current output stream

 current_predicate/2           Examine existing predicates
 current_stream/3              Examine open streams
 dde_current_connection/2      Win32:  Examine open DDE connections
 dde_current_service/2         Win32:  Examine DDE services provided
 dde_execute/2                 Win32:  Execute command on DDE server
 dde_register_service/2        Win32:  Become a DDE server
 dde_request/3                 Win32:  Make a DDE request

 dde_poke/3                    Win32:  POKE operation on DDE server
 dde_unregister_service/1      Win32:  Terminate a DDE service
 debug/0                       Test for debugging mode
 debugging/0                   Show debugger status
 default_module/2              Get the default modules of a module
 delete/3                      Delete all matching members from a list
 delete_file/1                 Remove a file from the file system
 discontiguous/1               Indicate distributed definition of a predicate

 dwim_match/2                  Atoms match in ``Do What I Mean'' sense
 dwim_match/3                  Atoms match in ``Do What I Mean'' sense
 dwim_predicate/2              Find predicate in ``Do What I Mean'' sense
 dynamic/1                     Indicate predicate definition may change
 ed/0                          Edit last edited predicate
 ed/1                          Edit a predicate
 edit/0                        Edit last edited file

 edit/1                        Edit a file
 edit_source/1                 (hook) Intercept editing
 ensure_loaded/1               Consult a file if that has not yet been done
 erase/1                       Erase a database record or clause
 exception/3                   (hook) Handle runtime exceptions
 exists_directory/1            Check existence of directory
 exists_file/1                 Check existence of file
 exit/2                        Exit from named block.  See bblloocckk//33

 expand_answer/2               Expand answer of query
 expand_file_name/2            Wildcard expansion of file names
 expand_file_search_path/2     Wildcard expansion of file paths
 expand_query/4                Expanded entered query
 expand_term/2                 Compiler:  expand read term into clause(s)
 explain/1                     library(explain) Explain argument
 explain/2                     library(explain) 2nd argument is explanation of first

 export/1                      Export a predicate from a module
 export_list/2                 List of public predicates of a module
 fail/0                        Always false
 fail/1                        Immediately fail named block.  See bblloocckk//33
 feature/2                     Get system configuration parameters
 file_base_name/2              Get file part of path
 file_directory_name/2         Get directory part of path
 file_name_extension/3         Add, remove or test file extensions

 file_search_path/2            Define path-aliases for locating files
 fileerrors/2                  Do/Don't warn on file errors
 findall/3                     Find all solutions to a goal
 flag/3                        Simple global variable system
 flatten/2                     Transform nested list into flat list
 float/1                       Type check for a floating point number
 flush/0                       Output pending characters on current stream

 flush_output/1                Output pending characters on specified stream
 forall/2                      Prove goal for all solutions of another goal
 foreign_file/1                Examine loaded foreign files
 format/1                      Formatted output
 format/2                      Formatted output with arguments
 format/3                      Formatted output on a stream
 format_predicate/2            Program ffoorrmmaatt//[[11,,22]]
 free_variables/2              Find unbound variables in a term

 functor/3                     Get name and arity of a term or construct a term
 garbage_collect/0             Invoke the garbage collector
 gensym/2                      Generate unique atoms from a base
 get/1                         Read first non-blank character
 get/2                         Read first non-blank character from a stream
 get0/1                        Read next character
 get0/2                        Read next character from a stream

 get_single_char/1             Read next character from the terminal
 get_time/1                    Get current time
 getenv/2                      Get shell environment variable
 ground/1                      Verify term holds no unbound variables
 halt/0                        Exit from Prolog
 halt/1                        Exit from Prolog with status
 hash_term/2                   Hash-value of ground term
 help/0                        Give help on help

 help/1                        Give help on predicates and show parts of manual
 history_depth/1               Number of remembered queries
 ignore/1                      Call the argument, but always succeed
 import/1                      Import a predicate from a module
 index/1                       Change clause indexing
 initialization/1              Initialization directive
 int_to_atom/2                 Convert from integer to atom

 int_to_atom/3                 Convert from integer to atom (non-decimal)
 integer/1                     Type check for integer
 intersection/3                Set intersection
 is/2                          Evaluate arithmetic expression
 is_absolute_file_name/1       True if arg defines an absolute path
 is_list/1                     Type check for a list
 is_set/1                      Type check for a set
 keysort/2                     Sort, using a key

 last/2                        Last element of a list
 leash/1                       Change ports visited by the tracer
 length/2                      Length of a list
 library_directory/1           (hook) Directories holding Prolog libraries
 limit_stack/2                 Limit stack expansion
 line_count/2                  Line number on stream
 line_position/2               Character position in line on stream

 list_to_set/2                 Remove duplicates
 listing/0                     List program in current module
 listing/1                     List predicate
 load_files/2                  Load source files with options
 load_foreign/2                Load foreign (C) module
 load_foreign/5                Load foreign (C) module
 load_foreign_library/1        library(shlib) Load shared library (.so file)
 load_foreign_library/2        library(shlib) Load shared library (.so file)

 make/0                        Reconsult all changed source files
 make_fat_filemap/1            Win32:  Create file containing non-FAT filenames
 make_library_index/1          Create autoload file INDEX.pl
 maplist/3                     Transform all elements of a list
 member/2                      Element is member of a list
 memberchk/2                   Deterministic mmeemmbbeerr//22
 merge/3                       Merge two sorted lists

 merge_set/3                   Merge two sorted sets
 meta_predicate/1              Quintus compatibility
 module/1                      Query/set current type-in module
 module/2                      Declare a module
 module_transparent/1          Indicate module based meta predicate
 msort/2                       Sort, do not remove duplicates
 multifile/1                   Indicate distributed definition of predicate
 name/2                        Convert between atom and list of ASCII characters

 nl/0                          Generate a newline
 nl/1                          Generate a newline on a stream
 nodebug/0                     Disable debugging
 nonvar/1                      Type check for bound term
 noprotocol/0                  Disable logging of user interaction
 nospy/1                       Remove spy point
 nospyall/0                    Remove all spy points

 not/1                         Negation by failure (argument not provable).  Same as \+//11
 notrace/0                     Stop tracing
 notrace/1                     Do not debug argument goal
 nth0/3                        N-th element of a list (0-based)
 nth1/3                        N-th element of a list (1-based)
 nth_clause/3                  N-th clause of a predicate
 number/1                      Type check for integer or float
 number_chars/2                Convert between number and atom

 numbervars/4                  Enumerate unbound variables of a term using a given base
 once/1                        Call a goal deterministically
 op/3                          Declare an operator
 open/3                        Open a file (creating a stream)
 open/4                        Open a file (creating a stream)
 open_dde_conversation/3       Win32:  Open DDE channel
 open_null_stream/1            Open a stream to discard output

 open_shared_object/2          UNIX: Open shared library (.so file)
 open_shared_object/3          UNIX: Open shared library (.so file)
 peek_byte/1                   Read character without removing
 peek_byte/2                   Read character without removing
 phrase/2                      Activate grammar-rule set
 phrase/3                      Activate grammar-rule set (returning rest)
 please/3                      Query/change environment parameters
 plus/3                        Logical integer addition

 portray/1                     (hook) Modify behaviour of pprriinntt//11
 portray_clause/1              Pretty print a clause
 predicate_property/2          Query predicate attributes
 predsort/3                    Sort, using a predicate to determine the order
 preprocessor/2                Install a preprocessor before the compiler
 print/1                       Print a term
 print/2                       Print a term on a stream

 profile/3                     Obtain execution statistics
 profile_count/3               Obtain profile results on a predicate
 profiler/2                    Obtain/change status of the profiler
 prolog/0                      Run interactive toplevel
 prolog_current_frame/1        Reference to goal's environment stack
 prolog_frame_attribute/3      Obtain information on a goal environment
 prolog_load_context/2         Context information for directives
 prolog_skip_level/2           Indicate deepest recursion to trace

 prolog_to_os_filename/2       Convert between Prolog and OS filenames
 prolog_trace_interception/4   library(user) Intercept the Prolog tracer
 prompt1/1                     Change prompt for 1 line
 prompt/2                      Change the prompt used by rreeaadd//11
 proper_list/1                 Type check for list
 protocol/1                    Make a log of the user interaction
 protocola/1                   Append log of the user interaction to file

 protocolling/1                On what file is user interaction logged
 put/1                         Write a character
 put/2                         Write a character on a stream
 qcompile/1                    Compile source to Quick Load File
 qload/1                       Load Quick Load File as ccoonnssuulltt//11
 qsave_program/1               Create runtime application
 qsave_program/2               Create runtime application
 read/1                        Read Prolog term

 read/2                        Read Prolog term from stream
 read_clause/1                 Read clause
 read_clause/2                 Read clause from stream
 read_history/6                Read using history substitution
 read_link/3                   Read a symbolic link
 read_term/2                   Read term with options
 read_term/3                   Read term with options from stream

 read_variables/2              Read clause including variable names
 read_variables/3              Read clause including variable names from stream
 recorda/2                     Record term in the database (first)
 recorda/3                     Record term in the database (first)
 recorded/2                    Obtain term from the database
 recorded/3                    Obtain term from the database
 recordz/2                     Record term in the database (last)
 recordz/3                     Record term in the database (last)

 redefine_system_predicate/1   Abolish system definition
 rename_file/2                 Change name of file
 repeat/0                      Succeed, leaving infinite backtrack points
 require/1                     This file requires these predicates
 reset_profiler/0              Clear statistics obtained by the profiler
 restore/1                     Restore saved-state (ssaavvee//11, ssaavvee__pprrooggrraamm//11)
 retract/1                     Remove clause from the database

 retractall/1                  Remove unifying clauses from the database
 reverse/2                     Inverse the order of the elements in a list
 same_file/2                   Succeeds if arguments refer to same file
 save/1                        Save program including current goal
 save/2                        Save program including current goal
 save_program/1                Save the current program on a file
 save_program/2                Save the current program on a file
 see/1                         Change the current input stream

 seeing/1                      Query the current input stream
 seen/0                        Close the current input stream
 select/3                      Select element of a list
 set_feature/2                 Define a system feature
 set_input/1                   Set current input stream from a stream
 set_output/1                  Set current output stream from a stream
 set_tty/2                     Set `tty' stream

 setarg/3                      Destructive assignment on term
 setenv/2                      Set shell environment variable
 setof/3                       Find all unique solutions to a goal
 sformat/2                     Format on a string
 sformat/3                     Format on a string
 shell/0                       Execute interactive subshell
 shell/1                       Execute OS command
 shell/2                       Execute OS command

 show_profile/1                Show results of the profiler
 size_file/2                   Get size of a file in characters
 skip/1                        Skip to character in current input
 skip/2                        Skip to character on stream
 rl_add_history/1              Add line to readline(3) history
 rl_read_init_file/1           Read readline(3) init file
 sleep/1                       Suspend execution for specified time

 sort/2                        Sort elements in a list
 source_file/1                 Examine currently loaded source files
 source_file/2                 Obtain source file of predicate
 source_location/2             Location of last read term
 spy/1                         Force tracer on specified predicate
 stack_parameter/4             Some systems:  Query/Set runtime stack parameter
 statistics/0                  Show execution statistics
 statistics/2                  Obtain collected statistics

 stream_position/3             Get/seek to position in file
 string/1                      Type check for string
 string_concat/3               ccoonnccaatt//33 for strings (non-deterministic)
 string_length/2               Determine length of a string
 string_to_atom/2              Conversion between string and atom
 string_to_list/2              Conversion between string and list of ASCII
 style_check/1                 Change level of warnings

 sublist/3                     Determine elements that meet condition
 subset/2                      Generate/check subset relation
 substring/4                   Get part of a string
 subtract/3                    Delete elements that do not meet condition
 succ/2                        Logical integer successor relation
 swritef/2                     Formatted write on a string
 swritef/3                     Formatted write on a string
 tab/1                         Output number of spaces

 tab/2                         Output number of spaces on a stream
 tell/1                        Change current output stream
 telling/1                     Query current output stream
 term_expansion/2              (hook) Convert term before compilation
 term_to_atom/2                Convert between term and atom
 throw/1                       Raise an exception (see ccaattcchh//33)
 time/1                        Determine time needed to execute goal

 time_file/2                   Get last modification time of file
 tmp_file/2                    Create a temporary filename
 told/0                        Close current output
 trace/0                       Start the tracer
 trace/1                       Set trace-point on predicate
 trace/2                       Set/Clear trace-point on ports
 tracing/0                     Query status of the tracer
 trim_stacks/0                 Release unused memory resources

 true/0                        Succeed
 tty_get_capability/3          Get terminal parameter
 tty_goto/2                    Goto position on screen
 tty_put/2                     Write control string to terminal
 ttyflush/0                    Flush output on terminal
 union/3                       Union of two sets
 unknown/2                     Trap undefined predicates

 unload_foreign_library/1      library(shlib) Detach shared library (.so file)
 unsetenv/1                    Delete shell environment variable
 use_module/1                  Import a module
 use_module/2                  Import predicates from a module
 var/1                         Type check for unbound variable
 visible/1                     Ports that are visible in the tracer
 volatile/1                    Predicates that are not saved
 wait_for_input/3              Wait for input with optional timeout

 wildcard_match/2              Csh(1) style wildcard match
 win_exec/2                    Win32:  spawn Windows task
 write/1                       Write term
 write/2                       Write term to stream
 write_ln/1                    Write term, followed by a newline
 write_canonical/1             Write a term with quotes, ignore operators
 write_canonical/2             Write a term with quotes, ignore operators on a stream

 write_term/2                  Write term with options
 write_term/3                  Write term with options to stream
 writef/1                      Formatted write
 writef/2                      Formatted write on stream
 writeq/1                      Write term, insert quotes
 writeq/2                      Write term, insert quotes on stream


88..22 AArriitthhmmeettiicc FFuunnccttiioonnss

 */2                     Multiplication
 **/2                    Power function

 +/2                     Addition
 -/1                     Unary minus
 -/2                     Subtraction
 //2                     Division
 ///2                    Integer division
 /\/2                    Bitwise and
 <</2                    Bitwise left shift
 >>/2                    Bitwise right shift

 ./2                     List of one character:  character code
 \/1                     Bitwise negation
 \//2                    Bitwise or
 ^/2                     Power function
 abs/1                   Absolute value
 acos/1                  Inverse (arc) cosine
 asin/1                  Inverse (arc) sine

 atan/1                  Inverse (arc) tangent
 atan/2                  Rectangular to polar conversion
 ceil/1                  Smallest integer larger than arg
 ceiling/1               Smallest integer larger than arg
 cos/1                   Cosine
 cputime/0               Get CPU time
 e/0                     Mathematical constant
 exp/1                   Exponent (base e)

 float/1                 Explicitly convert to float
 float_fractional_part/1 Fractional part of a float
 float_integer_part/1    Integer part of a float
 floor/1                 Largest integer below argument
 integer/1               Round to nearest integer
 log/1                   Natural logarithm
 log10/1                 10 base logarithm

 max/2                   Maximum of two numbers
 min/2                   Minimum of two numbers
 mod/2                   Remainder of division
 random/1                Generate random number
 rem/2                   Remainder of division
 round/1                 Round to nearest integer
 truncate/1              Truncate float to integer
 pi/0                    Mathematical constant

 sign/1                  Extract sign of value
 sin/1                   Sine
 sqrt/1                  Square root
 tan/1                   Tangent
 xor/2                   Bitwise exclusive or


88..33 OOppeerraattoorrss

 $                     1    fx   Bind toplevel variable
 ^                   200   xfy   Predicate
 ^                   200   xfy   Arithmetic function
 mod                 300   xfx   Arithmetic function
 *                   400   yfx   Arithmetic function
 /                   400   yfx   Arithmetic function
 //                  400   yfx   Arithmetic function
 <<                  400   yfx   Arithmetic function

 >>                  400   yfx   Arithmetic function
 xor                 400   yfx   Arithmetic function
 +                   500    fx   Arithmetic function
 -                   500    fx   Arithmetic function
 ?                   500    fx   XPCE: obtainer
 \                   500    fx   Arithmetic function
 +                   500   yfx   Arithmetic function

 -                   500   yfx   Arithmetic function
 /\                  500   yfx   Arithmetic function
 \/                  500   yfx   Arithmetic function
 :                   600   xfy   module:term separator
 <                   700   xfx   Predicate
 =                   700   xfx   Predicate
 =..                 700   xfx   Predicate
 =:=                 700   xfx   Predicate

 <                   700   xfx   Predicate
 ==                  700   xfx   Predicate
 =@=                 700   xfx   Predicate
 =\=                 700   xfx   Predicate
 >                   700   xfx   Predicate
 >=                  700   xfx   Predicate
 @<                  700   xfx   Predicate

 @=<                 700   xfx   Predicate
 @>                  700   xfx   Predicate
 @>=                 700   xfx   Predicate
 is                  700   xfx   Predicate
 \=                  700   xfx   Predicate
 \==                 700   xfx   Predicate
 =@=                 700   xfx   Predicate
 not                 900    fy   Predicate

 \+                  900    fy   Predicate
 ,                  1000   xfy   Predicate
 ->                 1050   xfy   Predicate
 *->                1050   xfy   Predicate
 ;                  1100   xfy   Predicate
 |                  1100   xfy   Predicate
 discontiguous      1150    fx   Predicate

 dynamic            1150    fx   Predicate
 module_transparent 1150    fx   Predicate
 multifile          1150    fx   Predicate
 volatile           1150    fx   Predicate
 initialization     1150    fx   Predicate
 :-                 1200    fx   Introduces a directive
 ?-                 1200    fx   Introduces a directive
 -->                1200   xfx   DCGrammar:  rewrite

 :-                 1200   xfx   head :- body.  separator
