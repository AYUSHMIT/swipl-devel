\chapter{SWI-Prolog extensions}
\label{sec:extensions}

This chapter describes extensions to the Prolog language introduced with
SWI-Prolog version~7. The changes bring more modern syntactical
conventions to Prolog such as key-value maps as primary citizens and a
restricted form of \jargon{functional notation}. They also extend Prolog
basic types with strings, providing a natural notation to textual
material as opposed to identifiers (atoms) and lists.

These extensions make the syntax more intuitive to new users, simplify
the integration of domain specific languages (DSLs) and facilitate a
more natural Prolog representation for popular exchange languages such
as XML and JSON.

While many programs run unmodified in SWI-Prolog version~7, especially
those that pass double quoted strings to general purpose list processing
predicates require modifications. We provide a tool (list_strings/0)
that we used to port a huge code base in half a day.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Lists are special}
\label{sec:ext-lists}

As of version~7, SWI-Prolog lists can be distinguished unambiguously at
runtime from \funcref{.}{2} terms and the atom \const{'[]'}. The
constant \verb$[]$ is special constant that is not an atom.  It has
the following properties:

\begin{code}
?- atom([]).
false.
?- atomic([]).
true.
?- [] == '[]'.
false.
?- [] == [].
true.
\end{code}

The `cons' operator for creating list cells has changed from the pretty
atom \verb$'.'$ to the ugly atom \verb|'$cons'|.

This modification has minimal impact on typical Prolog code. It does
affect foreign code (see \secref{foreign}) that uses the normal atom and
compound term interface for manipulation lists. In most cases this can
be avoided by using the dedicated list functions. For convenience, the
macros \const{ATOM_nil} and \const{ATOM_dot} are provided by
\file{SWI-Prolog.h}.

Another place that is affected is write_canonical/1. Impact is minimized
by using the list syntax for lists.


\subsection{Motivating '\$cons' and [] for lists}
\label{sec:ext-list-motivation}

Representing lists the conventional way using \funcref{.}{2} as
cons-cell and '[]' as list terminator both poses conflicts, while these
conflicts are easily avoided.

\begin{itemize}
    \item Using ./2 prevents using this commonly used symbol as an
operator because \verb$a.B$ cannot be distinguished from \verb$[a|B]$.

    \item Using \verb$'[]'$ as list terminator prevents dynamic distinction
between atoms and lists. As a result, we cannot use \jargon{multi lists}
(arbitrary deeply nested lists) of atoms. Note that multi lists of atoms
are a good (intermediate) representation of a flat list that is
assembled from sub sequences. The alternative, using difference lists or
DCGs is often less natural and sometimes demands for `opening' proper
lists (i.e., copying the list while replacing the terminating empty list
with a variable) that have to be added to the sequence. Another use-case
for distinguishing atoms from lists is representing external data of an
unknown structure that may contain both sequences and identifiers.

Avoiding \verb$'[]'$ as a list terminator also makes the various
text representations unambiguous, which allows us to write predicates
that require a textual argument to accept both atoms, strings, and lists
of character codes or one-character atoms. Traditionally, the empty list
can be interpreted both as the string "[]" and "".
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax changes}
\label{sec:ext-syntax}

\subsection{Operators and quoted atoms}
\label{sec:ext-syntax-op}

As of SWI-Prolog version~7, quoted atoms loose their operator property.
This means that expressions such as \verb$A == 'dynamic'$ are valid
syntax, regardless of the operator definitions. From questions on the
mailinglist this is what people expect,\footnote{We believe that most
users expect an operator declaration to define a new token, which would
explain why the operator name is often quoted in the declaration, but
not while the operator is used. We are afraid that allowing for this
easily creates ambiguous syntax. Also, many development environments are
based on tokenization. Having dynamic tokenization due to operator
declarations would make it hard to support Prolog in such editors.}
while deliberately quoted operators are extremely rare and can easily be
replaced. To simplify debugging, operator declarations that define an
operator that cannot be written without quotes raises a domain error:

\begin{code}
?- op(700, xfy, 'is a').
ERROR: Domain error: `unquoted_atom' expected, found `is a'
\end{code}


\subsection{Allow for dotted identifiers}
\label{sec:ext-syntax-dotted-id}

Quite a few languages allow for dots (.) in identifiers to express type
extensions or some form of hierarchy. Although SWI-Prolog version~7
makes the dot available as operator, this is different from supporting
it inside identifiers because usage inside identifiers does not allow
for brackets or white space. Furthermore, SWI-Prolog version~7 reserves
the dot for its \jargon{functional notation} extension (see
\secref{ext-map-functions}).

Whether or not dots are allowed in identifiers is controlled by the
\prologflag{allow_dot_in_atom}, which is \const{true} by default.


\subsection{Compound terms with zero arguments}
\label{sec:ext-compound-zero}

As of SWI-Prolog version~7, the system supports compound terms that have
no arguments. This implies that e.g., \exam{name()} is valid syntax.
This extension aims at functions on maps (see \secref{maps}) as well as
the implementation of domain specific languages (DSLs). To minimise the
consequences, the classic predicates functor/3 and \predref{=..}{2} have
not been modified. The predicates compound_name_arity/3 and
compound_name_arguments/3 have been added. These predicates operate only
on compound terms and behave consistently for compounds with zero
arguments. Code that \jargon{generalises} a term using the sequence
below should generally be changed to use compound_name_arity/3.

\begin{code}
    ...,
    functor(Specific, Name, Arity),
    functor(General, Name, Arity),
    ...,
\end{code}

Replacement of \predref{=..}{2} by compound_name_arguments/3 is
typically needed to deal with code that follow the skeleton below.

\begin{code}
    ...,
    Term0 =.. [Name|Args0],
    maplist(convert, Args0, Args),
    Term =.. [Name|Args],
    ...,
\end{code}

For predicates, goals and arithmetic functions (evaluable terms), <name>
and <name>() are \emph{equivalent}. Below are some examples that
illustrate this behaviour.

\begin{code}
go() :- format('Hello world~n').

?- go().
Hello world

?- go.
Hello world

?- Pi is pi().
Pi = 3.141592653589793.

?- Pi is pi.
Pi = 3.141592653589793.
\end{code}

Note that the \emph{cannonical} representation of predicate heads and
functions without arguments is an atom. Thus, \term{clause}{go(), Body}
returns the clauses for go/0, but \term{clause}{-Head, -Body, +Ref}
unifies \arg{Head} with an atom if the clause specified by \arg{Ref} is
part of a predicate with zero arguments.


\subsection{Double quoted strings}
\label{sec:ext-dquotes}

As of SWI-Prolog version~7, text encloses in double quotes (e.g.,
\verb$"Hello world"$) is read as a string object as defined in
\secref{strings}. \Secref{ext-dquotes-motivation} below motivates this
choice. The predicates in this section can help adapting your program to
this new convention. We have adapted a huge code base with which we were
not familiar in about half a day.

\begin{description}
    \predicate{list_strings}{0}{}
This predicate may be used to assess compatibility issues due to
the representation of double quoted text as string objects. See
\secref{ext-dquotes} and \secref{ext-dquotes-motivation}.  To
use it, load your program into Prolog and run list_strings/0.  The
predicate lists source locations of string objects encountered in
the program that are not considered safe.  Such string need to be
examined manually, after which one of the actions below may be
appropriate:

\begin{itemize}
    \item Rewrite the code.  For example, change  \verb$[X] = "a"$
          into \verb$X = 0'a$.
    \item If a particular module relies heavily on representing
          strings as lists of character code, consider adding the
	  following directive to the module.  Note that this flag
	  only applies to the module in which it appears.

	  \begin{code}
	  :- set_prolog_flag(double_quotes, codes).
	  \end{code}
    \item If the strings appear in facts and usage is safe, add a
          clause to the multifile predicate check:string_predicate/1
	  to silence list_strings/0 on all clauses of that predicate.
    \item If the strings appear as an argument to a predicate that
          can handle string objects, add a clause to the multifile
	  predicate check:valid_string_goal/1 to silence list_strings/0.
\end{itemize}

    \predicate{check:string_predicate}{1}{:PredicateIndicator}
Declare that \arg{PredicateIndicator} has clauses that contain strings,
but that this is safe. For example, if there is a predicate
\nopredref{help_info}{2}, where the second argument contains a double
quoted string that is handled properly by the predicates of the
applications' help system, add the following declaration to stop
list_strings/0 from complaining:

\begin{code}
:- multifile check:string_predicate/1.

string_predicate(user:help_info/2).
\end{code}

    \predicate{check:valid_string_goal}{1}{:Goal}
Declare that calls to \arg{Goal} are safe.  The module qualification
is the actual module in which \arg{Goal} is defined.  For example, a
call to format/3 is resolved by the predicate system:format/3. and
the code below specifies that the second argument may be a string
(system predicates that accept strings are defined in the library).

\begin{code}
:- multifile check:valid_string_goal/1.

check:valid_string_goal(system:format(_,S,_)) :- string(S).
\end{code}
\end{description}


\subsubsection{Why has the representation of double quoted text changed?}
\label{sec:ext-dquotes-motivation}

Prolog defines two forms of quoted text. Traditionally, single quoted
text is mapped to atoms while double quoted text is mapped to a list of
\jargon{character codes} (integers) or characters represented as
1-character atoms. Representing text using atoms is often considered
inadequate for several reasons:

\begin{itemize}
    \item It hides the conceptual difference between text and
          program symbols.  Where content of text often matters because
	  it is used in I/O, program symbols are merely identifiers
	  that match with the same symbol elsewhere. Program symbols
	  can often be consistently replaced, for example to obfuscate
	  or compact a program.

    \item Atoms are globally unique identifiers.  They are stored
          in a shared table.  Volatile strings represented as atoms
	  come at a significant price due to the required cooperation
	  between threads for creating atoms. Reclaiming
	  temporary atoms using \jargon{Atom garbage collection} is a
	  costly process that requires significant synchronisation.

    \item Many Prolog systems (not SWI-Prolog) put severe restrictions
          on the length of atoms or the maximum number of atoms.
\end{itemize}

Representing text as a list of character codes or 1-character atoms
also comes at a price:

\begin{itemize}
    \item It is not possible to distinguish (at runtime) a list of
          integers or atoms from a string.  Sometimes this information
	  can be derived from (implicit) typing.  In other cases the
	  list must be embedded in a compound term to distinguish
	  the two types.  For example, \verb$s("hello world")$ could
	  be used to indicate that we are dealing with a string.

	  Lacking runtime information, debuggers and the toplevel can
	  only use heuristics to decide whether to print a list of
	  integers as such or as a string (see portray_text/1).

	  While experienced Prolog programmers have learned to cope
	  with this, we still consider this an unfortunate situation.

    \item Lists are expensive structures, taking 2 cells per character
          (3 for SWI-Prolog in its current form).  This stresses memory
	  consumption on the stacks while pushing them on the stack and
	  dealing with them during garbage collection is unnecessarilly
	  expensive.
\end{itemize}

We observe that in many programs, most strings are only handled as a
single unit during their lifetime. Examining real code tells us that
double quoted strings typically appear in one of the following roles:

\begin{description}
    \item [ A DCG literal ]  Although represented as a list of codes
is the correct representation for handling in DCSs, the DCG translator
can recognise the literal and convert it to the proper representation.
Such code need not be modified.

    \item [ A format string ]  This is a typical example of text that
is conceptually not a program identifier.  Format is designed to deal
with alternative representations of the format string.  Such code
need not be modified.

    \item [ Getting a character code ] The construct \verb$[X] = "a"$
is a commonly used template for getting the character code of the
letter 'a'.  ISO Prolog defines the syntax \verb$0'a$ for this purpose.
Code using this must be modified.  The modified code will run on any
ISO compliant processor.

    \item [ As argument to list predicates to operate on strings ]
Here, we see code such as \verb$append("name:", Rest, Codes)$.  Such
code needs to be modified.  In this particular example, the
following is a good portable alternative: \verb$phrase("name:", Codes, Rest)$

    \item [ Checks for a character to be in a set ]
Such tests are often performed with code such as this:
\verb.memberchk(C, "~!@#$").. This is a rather inefficient check in a
traditional Prolog system because it pushes a list of character codes
cell-by-cell the Prolog stack and then traverses this list
cell-by-cell to see whether one of the cells unifies with \arg{C}. If
the test is successful, the string will eventually be subject to garbage
collection.  The best code for this is to write a predicate as below,
which pushes noting on the stack and performs an indexed lookup to see
whether the character code is in `my_class'.

\begin{code}
my_class(0'~).
my_class(0'!).
...
\end{code}

An alternative to reach the same effect is to use term expansion to
create the clauses:

\begin{code}
term_expansion(my_class(_), Clauses) :-
	findall(my_class(C),
		string_code(_, "~!@#$", C),
		Clauses).

my_class(_).
\end{code}

Finally, the predicate string_code/3 can be exploited directly as a
replacement for the memberchk/2 on a list of codes. Although the string
is still pushed onto the stack, it is more compact and only a single
entity.
\end{description}

We offer the predicate list_strings/0 to help porting your program.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Maps: structures with named arguments}
\label{sec:maps}

SWI-Prolog version~7 introduces maps as an abstract object with a
concrete modern syntax and functional notation for accessing members and
as well as access functions defined by the user. The syntax for a map is
illustrated below. \arg{Class} is either a variable or an atom. As with
compound terms, there is \textbf{no} space between the class and the
opening brace. The keys are either atoms or small integers (up to
\prologflag{max_tagged_integer}). The values are arbitrary Prolog terms
which are parsed using the same rules as used for arguments in compound
terms.

\begin{quote}
Class{Key1:Value1, Key2:Value2, ...}
\end{quote}

A map can not hold duplicate keys. The map is transformed into an opaque
internal representation that does \emph{not} respect the order in which
the key-value pairs appear in the input text. If a map is written, the
keys are written according to the standard order of terms (see
\secref{standardorder}). Here are some examples, where the second
example illustrates that the order is not maintained and the third
illustrates an anonymous map.

\begin{code}
?- A = point{x:1, y:2}.
A = point{x:1, y:2}.

?- A = point{y:2, x:1}.
A = point{x:1, y:2}.

?- A = _{first_name:"Mel", last_name:"Smith"}.
A = _G1476{first_name:"Mel", last_name:"Smith"}.
\end{code}

Maps can be unified following the standard symmetric Prolog unification
rules. As maps use an internal canonical form, the order in which the
named keys are represented is not relevant. This behaviour is
illustrated by the following example.

\begin{code}
?- point{x:1, y:2} = Class{y:2, x:X}.
Class = point,
X = 1.
\end{code}


\subsection{Functions on maps}
\label{sec:ext-map-functions}

The infix operator dot (\term{op}{100, yfx, .} is used to extract values
and evaluate functions on maps. Functions are recognised if they appear
in the argument of a \jargon{goal} in the source text, possibly nested
in a term. The keys act as field selector, which is illustrated in this
example.

\begin{code}
?- X = point{x:1,y:2}.x.
X = 1.

?- Pt = point{x:1,y:2}, write(Pt.y).
2
Pt = point{x:1,y:2}.

?- X = point{x:1,y:2}.C.
X = 1,
C = x ;
X = 2,
C = y.
\end{code}

The compiler translates a goal that contains \funcref{.}{2} terms in its
arguments into a conjunction of calls to \predref{.}{3} defined in the
\const{system} module. Note that this implies that terms \funcref{.}{2}
cannot be created by writing them explicitly in your source code. Such
terms can still be created with functor/3, \predref{=..}{2},
compound_name_arity/3 and
compound_name_arguments/3.\footnote{Traditional code is unlikely to use
\funcref{.}{2} terms because they were practically reserved for usage in
lists. We do not provide a quoting mechanism as found in functional
languages because it would only be needed to quote \funcref{.}{2} terms,
such terms are rare and term manipulation provides an escape route.}

\begin{description}
    \predicate{.}{3}{+Map, +Function, -Result}
This predicate is called to evaluate \funcref{.}{2} terms found in the
arguments of a goal. This predicate evaluates the field extraction
described above, user defined functions described in
\secref{ext-map-user-functions} and the predefined functions on maps
described in \secref{ext-maps-predefined}.
\end{description}


\subsubsection{User defined functions on maps}
\label{sec:ext-map-user-functions}

The class of a map associates the map to a module.  If the dot
notation uses a compound term, this calls the goal below.

\begin{quote}
<module>:<name>(Arg1, ..., +Map, -Value)
\end{quote}

Functions are normal Prolog predicates. The map infrastructure provides
a more convenient syntax for representing the head of such predicates
without worrying about the argument calling conventions. The code below
defines a function \term{multiply}{Times} on a point that creates a new
point by multiplying both coordinates. and \term{len}{}\footnote{as
\term{length}{} would result in a predicate length/2, this name cannot
be used. This might change in future versions.} to compute the length
from the origin. The . and \verb$:=$ operators are used to abstract the
location of the predicate arguments. It is allowed to define multiple a
function with multiple clauses, providing overloading and
non-determinism.

\begin{code}
:- module(point, []).

M.multiply(F) := point{x:X, y:Y} :-
	X is M.x*F,
	Y is M.y*F.

M.len() := Len :-
	Len is sqrt(M.x**2 + M.y**2).
\end{code}

After these definitions, we can evaluate the following functions:

\begin{code}
?- X = point{x:1, y:2}.multiply(2).
X = point{x:2, y:4}.

?- X = point{x:1, y:2}.multiply(2).len().
X = 4.47213595499958.
\end{code}

\subsubsection{Predefined functions on maps}
\label{sec:ext-maps-predefined}

Maps currently define the following reserved functions:

\begin{description}
    \mapfunction{put}{1}{+New}
Evaluates to a new map where the key-values in \arg{New} replace
or extend the key-values in the original map.  See put_map/3.

    \mapfunction{put}{2}{+Key, +Value}
Evaluates to a new map where the \arg{Key}-\arg{Value} replaces
or extends the key-values in the original map.  See put_map/4.
\end{description}


\subsection{Predicates for managing maps}
\label{ext-map-predicates}

This section documents the predicates that are defined on maps.  We use
the naming and argument conventions of the traditional \pllib{assoc}.

\begin{description}
    \predicate{is_map}{1}{@Term}
True if \arg{Term} is a map.  This is the same as \exam{is_map(Term,_)}.

    \predicate{is_map}{2}{@Term, -Class}
True if \arg{Term} is a map of \arg{Class}.

    \predicate{get_map}{3}{?Key, +Map, -Value}
Unify the value associated with \arg{Key} in map with \arg{Value}.  If
\arg{Key} is unbound, all associations in \arg{Map} are returned on
backtracking.  The order in which the associations are returned is
undefined.  This predicate is normally accessed using the functional
notation \exam{Map.Key}.  See \secref{ext-map-functions}.

    \predicate{map_create}{3}{-Map, +Class, +Data}
Create a map in \arg{Class} from \arg{Data}. \arg{Data} is a list of
attribute-value pairs using the syntax \exam{Key:Value},
\exam{Key=Value}, \exam{Key-Value} or \exam{Key(Value)}. An exception is
raised if \arg{Data} is not a proper list, one of the elements is not of
the shape above, a key is neither an atom nor a small integer or there
is a duplicate key.

    \predicate{map_pairs}{3}{?Map, ?Class, ?Pairs}
Bi-directional mapping between a map and an ordered list of pairs
(see \secref{pairs}).

    \predicate{put_map}{3}{+New, +MapIn, -MapOut}
\arg{MapOut} is a new map created by replacing or adding key-value pairs
from \arg{New} to \arg{Map}. \arg{New} is either a map or a valid input
for map_create/3. This predicate is normally accessed using the
functional notation. Below are some examples:

\begin{code}
?- A = point{x:1, y:2}.put(_{x:3}).
A = point{x:3, y:2}.

?- A = point{x:1, y:2}.put([x=3]).
A = point{x:3, y:2}.

?- A = point{x:1, y:2}.put([x=3,z=0]).
A = point{x:3, y:2, z:0}.
\end{code}

    \predicate{put_map}{4}{+Key, +MapIn, +Value, -MapOut}
\arg{MapOut} is a new map created by replacing or adding
\arg{Key}-\arg{Value} to \arg{MapIn}. This predicate is normally
accessed using the functional notation. Below is an example:

\begin{code}
?- A = point{x:1, y:2}.put(x, 3).
A = point{x:3, y:2}.
\end{code}

    \predicate{del_map}{4}{+Key, +MapIn, ?Value, -MapOut}
True when \arg{Key}-\arg{Value} is in \arg{MapIn} and \arg{MapOut}
contains all associations of \arg{MapIn} except for \arg{Key}.

    \infixop{=~=}{+Map1}{+Map2}
This operator specifies a \jargon{partial unification} between
\arg{Map1} and \arg{Map2}. It is true when the classes and the values
associated with all \emph{common} keys have been unified.  The values
associated to keys that do not appear in the other map are ignored.
Partial unification is symmetric.  For example, given a list of maps,
find maps that represent a point with X equal to zero:

\begin{code}
    member(Map, List),
    Map =~= point{x:0, y:Y}.
\end{code}
\end{description}


\subsection{A motivation for maps as primary citizens}
\label{sec:ext-maps-motivation}

Maps, or key-value associations, are a common data structure. A good old
example are \jargon{property lists} as found in Lisp, while a good
recent example is formed by JavaScript \jargon{objects}. Traditional
Prolog does not offer native properly lists. As a result, people are
using a wide range of data structures for key-value associations:

\begin{itemize}
    \item Using compound terms and positional arguments, e.g.,
          \exam{point(1,2)}.
    \item Using compound terms with library \pllib{record}, which
	  generates access predicates for a term using positional
	  arguments from a description.
    \item Using lists of terms \exam{Name=Value}, \exam{Name-Value},
          \exam{Name:Value} or \exam{Name(Value)}.
    \item Using library \pllib{assoc} which represents the
          associations as a balanced binary tree.
\end{itemize}

This situation is unfortunate. Each of these have their advantages and
disadvantages. E.g., compound terms are compact and fast, but inflexible
and using positional arguments quickly breaks down. Library
\pllib{record} fixes this, but the syntax is considered hard to use.
Lists are flexible, but expensive and the alternative key-value
representations that are used complicate the matter even more. Library
\pllib{assoc} allows for efficient manipulation of changing
associations, but the syntactical representation of an assoc is complex,
which makes them unsuitable for e.g., \jargon{options lists} as seen in
predicates such as open/4.


\subsection{Implementation notes about maps}
\label{sec:ext-maps-implementation}

Although maps are designed as an abstract data type and we deliberately
reserve the possibility to change the representation and even use
multiple representations, this section describes the current
implementation.

Maps are currently represented as a compound term using the functor
\verb$`map`$. The first argument is the class. The remaining arguments
create an array of sorted key-value pairs. This representation is
compact and guarantees good locality. Lookup is order $\log(N)$, while
adding valuesm deleting values and merging with other maps has order
$N$. The main disadvantage is that changing values in large maps is
costly, both in terms of memory and time.

Future versions may share keys in a separate structure or use a binary
trees to allow for cheaper updates. One of the issues is that the
representation must either be kept cannonical or unification must be
extended to compensate for alternate representations.
