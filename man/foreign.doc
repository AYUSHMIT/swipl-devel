\chapter{Foreign Language Interface}

\newlength{\tableft}
\settowidth{\tableft}{\tt PL_QUERY_ORGSYMBOLFILE}

SWI-Prolog offers a powerful interface to C \cite{Kernighan:78}. The
main design objectives of the foreign language interface are flexibility
and performance. A foreign predicate is a C-function that has the same
number of arguments as the predicate represented. C-functions are
provided to anylyse the passed terms, convert them to basic C-types as
well as to instantiate arguments using unification. Non-deterministics
foreign predicates are supported, providing the foreign function with a
handle to control backtracking.

C can call Prolog predicates, providing both an query interface and
an interface to extract multiple solutions from an non-deterministic
Prolog predicate.  There is no limit to the nesting of Prolog calling
C, calling Prolog, etc.  It is also possible to write the `main' in
C and use Prolog as an embedded logical engine.


\section{Overview of the Interface}

A special include file called $<$SWI-Prolog.h$>$ should be included with
each C-source file that is to be loaded via the foreign interface.  The
installation process installs this file in the directory \tty{include}
in the SWI-Prolog home directory (\tty{?- feature(home, Home).}).  This
C-header file defines various data types, macros and functions that can
be used to communicate with SWI-Prolog.  Functions and macros can be
divided into the following categories:

\begin{shortlist}
\setlength{\itemsep}{-2pt}
    \item Analysing Prolog terms
    \item Constructing new terms
    \item Unifying terms
    \item Returning control information to Prolog
    \item Registering foreign predicates with Prolog
    \item Calling Prolog from C
    \item Global actions on Prolog (halt, break, abort, etc.)
\end{shortlist}


\section{Linking Foreign Modules}

Foreign modules may be linked to Prolog in three ways. Using {\em
static} linking, the extensions, a small description file and the basic
SWI-Prolog object file are linked together to form a new executable.
Using {\em dynamic} linking, the extensions are linked to a shared
library ({\tt .so} file on most Unix systems) or dynamic-link library
({\tt .DLL} file on Microsoft platforms) and loaded into the the running
Prolog process.%
    \footnote{The system also contains code to load {\tt .o} files
	      directly for some operating systems, notably Unix systems
	      using the BSD a.out executable format. As the number of
	      Unix platforms supporting this gets quickly smaller and
	      this interface is difficult to port and slow, it is no
	      longer described in this manual.  The best alternatively
	      would be to use the dld package on machines donot have
	      shared libraries}.

\subsection{What linking is provided?}

The {\em static} linking schema can be used on all versions of
SWI-Prolog.  The feature/2 predicate may be used to find out what
other linking methods are provided for this version.

\begin{itemize}
    \tick{feature(open_shared_object, true)}
\index{dlopen}\index{.so files}%
If this succeeds the system provides the open_shared_object/2 and
related predicates that allow for handling Unix shared object files
based on the Unix library functions dlopen() and friends. See
section~\ref{sec:shlib}.
    \tick{feature(dll, true)}
If this succeeds the system provides an interface for loading \tty{.DLL}
files by means of open_dll/2 and friends. See section~\ref{sec:shlib}.
\end{itemize}

If either the feature {\em open_shared_object} or {\em dll} is true, the
library \tty{library(shlib)} provides a common interface for loading
foreign files from Prolog.


\subsection{What kind of loading should I be using?}

All described approaches have their advantages and disadvantages. Static
linking is portable and allows for debugging on all platforms. It is
relatively cumbersome and the libraries you need to pass to the linker
may vary from system to system.

Loading shared objects or DLL files provides sharing and protection and
is generally the best choice. The old (and also badly portable)
save/[1,2] and save_program/[1,2] donot cooperate with this mechanism,
but the more recent qsave_program/[1,2] can be used to created programs
that load the apropriate library at startup.

Note that the definition of the foreign predicates is the same, regardless
of the linking type used.


\section{Dynamic Linking of shared libraries}

The interface defined in this section allows the user to load shared
libraries (\tty{.so} files on most Unix systems).  This interface is portable
to all machines providing the function dlopen() or an equivalent,
normally from the library -ldl.  These functions provide the basic
interface layer.  It is advised to use the predicates from
section~\ref{sec:shlib} in your application.


.BD
.C open_shared_object 2 +File, -Handle
{\em File} is the name of a \tty{.so} file (see your C programmers
documentation on how to create a \tty{.so} file).  This file is attached to
the current process and {\em Handle} is unified with a handle to the
shared object. Equivalent to {\tt open_shared_object(File, [global],
Handle)}.  See also load_foreign_library/[1,2].
.C open_shared_object 3 +File, +Options, -Handle
As open_shared_object/2, but allows for additional flags to be passed.
{\em Options} is a list of atoms.  {\tt now} implies the symbols are
resolved immediately rather than lazy (default).  {\tt global} implies
symbols of the loaded object are visible while loading other shared
objects (by default they are local).  Note that these flags may not
be supported by your operating system.  Check the documentation of
dlopen() or equivalent on your operating system.
.C close_shared_object 1 +Handle
Detach the shared object identified by {\em Handle}.
.C call_shared_object_function 2 +Handle, +Function
Call the named function in the loaded shared library.  The function
is called without arguments and the return-value is ignored.  Normally
this function installs foreign language predicates using calls to
PL_register_foreign().
.ED


\section{Using the library shlib for {\tt .DLL} and .{\tt so} files}
						         \label{sec:DLL}
						         \label{sec:shlib}

This section discusses the functionality of the (autoload) library {\tt
shlib.pl}, providing an interface to shared libraries. Currently it 
supports MS-Windows DLL (\tty{.DLL}) libraries and Unix \tty{.so}
(shared object) files.

.BD
.C load_foreign_library 1 +Lib
Equivalent to load_foreign_library(Lib, install).
.C load_foreign_library 2 +Lib, +Entry
Search for the given foreign library and link it to the current
SWI-Prolog instance.  The library may be specified with or without the
extension.  First, absolute_file_name/3 is used to locate the file.  If
this succeeds, the full path is passed to the low-level function to open
the library.  Otherwise, the plain library name is passed, exploiting
the operating-system defined search mechanism for the shared library.
The file_search_path/2 alias mechanism defines the alias \tty{foreign},
which refers to the directories \mbox{<plhome>{\tt /lib/}<arch>} and
\mbox{<plhome>\tt/lib}, in this order.

If the library can be loaded, the function called {\em Entry} will be
called without arguments. The return value of the function is ignored.

The {\em Entry} function will normally call PL_register_foreign() to
declare functions in the library as foreign predicates.
.C unload_foreign_library 1 +Lib
If the foreign library defines the function \tty{uninstall}, this
function will be called without arguments and its return value is
ignored.  Next, abolish/2 is used to remove all known foreign predicates
defined in the library. Finally the library itself is detatched from the
process.
.C current_foreign_library 2 -Lib, -Predicates
Query the currently loaded foreign libraries and their predicates.  {\em
Predicates} is a list with elements of the form {\em Module:Head},
indicating the predicates installed with PL_register_foreign() when
the entry-point of the library was called.
.ED

Figure~\ref{fig:msgbox} connects a Windows message-box using a foreign
function.  This example was tested using Windows~NT and Microsoft Visual
C++ 2.0.

\begin{figure}[h]
\begin{boxed}
\begin{code}
#include <windows.h>
#include <SWI-Prolog.h>

static foreign_t
pl_say_hello(term_t to)
{ char *a;

  if ( PL_get_atom_chars(to, &a) )
  { MessageBox(NULL, a, "DLL test", MB_OK|MB_TASKMODAL);

    PL_succeed;
  }

  PL_fail;
}

install_t
install()
{ PL_register_foreign("say_hello", 1, pl_say_hello, 0);
}
\end{code}
\end{boxed}
    \caption{MessageBox() example in Windows~NT}
    \label{fig:msgbox}
\end{figure}


\subsection{Static Linking}				\label{sec:staticl}

Below is an outline of the files structure required for statically
linking SWI-Prolog with foreign extensions. \verb$.../pl$ refers to the
SWI-Prolog home directory (see feature/2). \tty{<arch>} refers to the
architecture identifier that may be obtained using feature/2.

\begin{center}
\begin{tabular}{ll}
\verb$.../pl/runtime/<arch>/libpl.a$	& SWI-Library \\
\verb$.../pl/include/SWI-Prolog.h$	& Include file \\
\verb$.../pl/include/SWI-Stream.h$	& Stream I/O include file \\
\verb$.../pl/include/SWI-Exports$	& Export declarations (AIX only) \\
\verb$.../pl/include/stub.c$		& Extension stub 
\end{tabular}
\end{center}

The definition of the foreign predicates is the same as for dynamic
linking.  Unlike with dynamic linking however, there is no
initialisation function.  Instead, the file \verb$.../pl/include/stub.c$
may be copied to your project and modified to define the foreign
extensions.  Below is stub.c, modified to link the lowercase example
described later in this chapter:

\begin{boxed}\begin{code}
/*  Copyright (c) 1991 Jan Wielemaker. All rights reserved.
    jan@swi.psy.uva.nl

    Purpose: Skeleton for extensions
*/

#include <stdio.h>
#include <SWI-Prolog.h>

extern foreign_t pl_lowercase(term, term);

PL_extension PL_extensions [] =
{
/*{ "name",	 arity,  function,	PL_FA_<flags> },*/

  { "lowercase", 2	 pl_lowercase,  0 },
  { NULL,	 0, 	 NULL,		0 }	/* terminating line */
};


int
main(int argc, char **argv, char **env)
{ if ( !PL_initialise(argc, argv, env) )
    PL_halt(1);

  PL_install_readline();		/* delete if not required */

  PL_halt(PL_toplevel() ? 0 : 1);
}
\end{code}\end{boxed}

Now, a new executable may be created by compilign this file and linking
it to libpl.a from the runtime directory and the libraries required by
both the extensions and the SWI-Prolog kernel. This may be done by hand,
or using the {\tt plld} utility described in section~\ref{sec:plld}.


\subsection{Dynamic Linking based on load_foreign/[2,5]}

The predicates below are considered obsolete. They are briefly described
here for compatibility purposes.  New code should use the predicates
from the library \tty{shlib}.

.BD
.C load_foreign 2 +File, +Entry
Load a foreign file or list of files specified by {\em File}.  The files
are searched for similar to consult/1.  Except that the `\tty{.o}'
extension is used rather than `\tty{.pl}'.

{\em Entry} defines the entry point of the resulting executable.  The
entry point will be called by Prolog to install the foreign predicates.
.C load_foreign 2 +File, +Entry, +Options, +Libraries, +Size
The first two arguments are identical to those of load_foreign/2. {\em
Options} is (a list of) additional option to be given to the loader.
The options are inserted just before the files. {\em Libraries} is (a
list of) libraries to be passed to the loader. They are inserted just
after the files. If {\em Size} is specified Prolog first assumes that
the resulting executable will fit in {\em Size} bytes and do the loading
in one pass.
.C foreign_file 1 ?File
Is true if {\em File} is the absolute path name of a file loaded as
foreign file.
.ED

\section{Interface Data types}

\subsection{Type {\tt term_t}: a reference to a Prolog term}

The principal data-type is \tty{term_t}. Type \tty{term_t} is what
Quintus calls \tty{QP_term_ref}. This name indicates better what the
type represents: it is a {\em handle} for a term rather than the term
itself. Terms can only be represented and manipulated using this type,
as this is the only safe way to ensure the Prolog kernel is aware of all
terms referenced by foreign code and thus allows the kernel to perform
garbage-collection and/or stack-shifts while foreign code is active,
for example during a callback from C.

A term reference is a C unsigned long, representing the offset of a
variable on the Prolog environment-stack.  A foreign function is passed
term references for the predicate-arguments, one for each argument.  If
references for intermediate results are needed, such references may be
created using PL_new_term_ref() or PL_new_term_refs().  These references
normally live till the foreign function returns control back to Prolog.
Their scope can be explicitely limited using PL_open_foreign_frame()
and PL_close_foreign_frame()/PL_discard_foreign_frame().

A term_t always refers to a valid Prolog term (variable, atom, integer,
float or compound term). A term lives either until backtracking takes us
back to a point before the term was created, the garbage collector has
collected the term or the term was created after a
PL_open_foreign_frame() and PL_discard_foreign_frame() has been called.

The foreign-interface functions can either {\em read}, {\em unify} or
{\em write} to term-references.  In the this document we use the
following notation for arguments of type term_t:

\begin{tabular}{|p{\tableft}|p{3.5in}|}
\hline
\tt term_t +t	& Accessed in read-mode.  The `+' indicates the
		  argument is `input'. \\
\tt term_t -t	& Accessed in write-mode. \\
\tt term_t ?t	& Accessed in unify-mode. \\
\hline
\end{tabular}

Term references are obtained in any of the following ways.

\begin{itemize}
\tick{Passed as argument}
    The C-functions implementing foreign predicates are passed their
    arguments as term-references.  These references may be read or
    unified.  Writing to these variables causes undefined behaviour.
\tick{Created by PL_new_term_ref()}
    A term created by PL_new_term_ref() is normally used to build
    temporary terms or be written by one of the interface functions.
    For example, PL_get_arg() writes a reference to the term-argument
    in its last argument.
\tick{Created by PL_new_term_refs(int n)}
    This function returns a set of term refs with the same characteristics
    as PL_new_term_ref().  See PL_open_query().
\tick{Created by PL_copy_term_ref(term_t t)}
    Creates a new term-reference to the same term as the argument.  The
    term may be written to.  See figure~\ref{fig:pl-display}.
\end{itemize}

Term-references can savely be copied to other C-variables of type
term_t, but all copies will always refer to the same term.

.BF
.F term_t PL_new_term_ref 0
Return a fresh reference to a term.  The reference is allocated on the
{\em local} stack.  Allocating a term-reference may trigger a stack-shift
on machines that cannot use sparse-memory management for allocation the
Prolog stacks.  The returned reference describes a variable.
.F term_t PL_new_term_refs 1 int n
Return {\em n} new term references.  The first term-reference is returned.
The others are {\tt{\em t}+1}, {\tt{\em t}+2}, etc.  There are two reasons
for using this function.  PL_open_query() expects the arguments as a set
of consecutive term references and {\em very} time-critical code requiring
a number of term-references can be written as:

\begin{code}
pl_mypredicate(term_t a0, term_t a1)
{ term_t t0 = PL_new_term_refs(2);
  term_t t1 = t0+1;

  ...
}
\end{code}
.F term_t PL_copy_term_ref 1 term_t from
Create a new term reference and make it point initialy to the same
term as {\em from}.  This function is commonly used to copy a predicate
argument to a term reference that may be written.
.EF


\subsubsection{Interaction with the garbage collector and stack-shifter}

Prolog implements two mechanisms for avoiding stack overflow: garbage
collection and stack expansion. On machines that allow for it, Prolog
will use virtual memory management to detect stack overflow and expand
the runtime stacks. On other machines Prolog will reallocate the stacks
and update all pointers to them. To do so, Prolog needs to know which
data is referenced by C-code. As all Prolog data known by C is
referenced through term references (\tty{term_t}), Prolog has all
information necessary to perform its memory management without 
special precautions from the C-programmer.


\subsection{Other foreign interface types}

\begin{description}
    \item[atom_t]
An atom in Prologs internal representation.  Atoms are pointers to an
opaque structure.  They are a unique representation for represented
text, which implies that atom {\em A} represents the same text as
atom {\em B} if-and-only-if {\em A} and {\em B} are the same pointer.

Atoms are the central representation for textual constants in Prolog
The transformation of C a character string to an atom implies a
hash-table lookup.  If the same atom is needed often, it is advised
to store its reference in a global variable to avoid repeated lookup.
    \item[functor_t]
A functor is the internal representation of a name/arity pair. They are
used to find the name and arity of a compound term as well as to
construct new compound terms. Like atoms they live for the whole Prolog
session and are unique.
    \item[predicate_t]
Handle to a Prolog predicate. Predicate handles live forever (although
they can loose their definition).
    \item[qid_t]
Query Identifier. Used by
PL_open_query()/PL_next_solution()/PL_close_query() to handle
backtracking from C.
    \item[fid_t]
Frame Identifier. Used by
PL_open_foreign_frame()/PL_close_foreign_frame().
    \item[module_t]
A module is a unique handle to a Prolog module. Modules are used only
to call predicates in a specific module.
    \item[foreign_t]
Return type for a C-function implementing a Prolog predicate.
    \item[control_t]
Passed as additional argument to non-deterministic foreign functions.
See PL_retry*() and PL_foreign_context*().
    \item[install_t]
Type for the \tty{install()} and \tty{uninstall()} functions of shared
or dynamic link libraries.  See section~\ref{sec:shlib}.
\end{description}

\section{The Foreign Include File}

\subsection{Argument Passing and Control}

If Prolog encounters a foreign predicate at run time it will call a
function specified in the predicate definition of the foreign predicate.
The arguments (1, ..., arity) pass the Prolog arguments to the goal as
Prolog terms.  Foreign functions should be declared of type {\tt
foreign_t}.  Deterministic foreign functions have two alternatives to
return control back to Prolog:

.BF
.M void PL_succeed 0
Succeed deterministically. PL_succeed is defined as ``return TRUE''.
.M void PL_fail 0
Fail and start Prolog backtracking.  PL_fail is defined as ``return
FALSE''.
.EF

\subsubsection{Non-deterministic Foreign Predicates}

By default foreign predicates are deterministic.  Using the {\tt
PL_FA_NONDETERMINISTIC} attribute (see PL_register_foreign()) it is
possible to register a predicate as a non-deterministic predicate.
Writing non-deterministic foreign predicates is slightly more
complicated as the foreign function needs context information for
generating the next solution.  Note that the same foreign function
should be prepared to be simultaneously active in more than one goal.
Suppose the natural_number_below_n/2 is a non-deterministic foreign
predicate, backtracking over all natural numbers lower than the first
argument.  Now consider the following predicate:

\begin{boxed}\begin{code}
quotient_below_n(Q, N) :-
	natural_number_below_n(N, N1),
	natural_number_below_n(N, N2),
	Q =:= N1 / N2, !.
\end{code}\end{boxed}

In this predicate the function natural_number_below_n/2 simultaneously
generates solutions for both its invocations.

Non-deterministic foreign functions should be prepared to handle three
different calls from Prolog:

\begin{description}
    \item[Initial call ({\tt PL_FIRST_CALL})]\mbox{}\\
Prolog has just created a frame for the foreign function and asks it to
produce the first answer.
    \item[Redo call ({\tt PL_REDO})]\mbox{}\\
The previous invocation of the foreign function associated with the
current goal indicated it was possible to backtrack.  The foreign
function should produce the next solution.
    \item[Terminate call ({\tt PL_CUTTED})]\mbox{}\\
The choice point left by the foreign function has been destroyed by
a cut.  The foreign function is given the opportunity to clean the
environment.
\end{description}

Both the context information and the type of call is provided by an
argument of type {\tt control_t} appended to the argument list for
deterministic foreign functions.  The macro PL_foreign_control()
extracts the type of call from the control argument.  The foreign
function can pass a context handle using the PL_retry*() macros and
extract the handle from the extra argument using the
PL_foreign_context*() macro.

.BF
.M void PL_retry 1 long
The foreign function succeeds while leaving a choice point. On
backtracking over this goal the foreign function will be called again,
but the control argument now indicates it is a `Redo' call and the
macro PL_foreign_context() will return the handle passed via
PL_retry(). This handle is a 30 bits signed value (two bits are used
for status indication).
.M void PL_retry_adress 1 void *
As PL_retry(), but ensures an address as returned by malloc() is
correctly recovered by PL_foreign_context_address().
.M int PL_foreign_control 1 control_t
Extracts the type of call from the control argument.  The return values
are described above.  Note that the function should be prepared to
handle the {\tt PL_CUTTED} case and should be aware that the other
arguments are not valid in this case.
.M long PL_foreign_context 1 control_t
Extracts the context from the context argument.  In the call type is
{\tt PL_FIRST_CALL} the context value is 0L.  Otherwise it is the value
returned by the last PL_retry() associated with this goal (both if the
call type is {\tt PL_REDO} as {\tt PL_CUTTED}).
.M void * PL_foreign_context_address 1 control_t
Extracts an address as passed in by PL_retry_adress().
.EF

Note: If a non-deterministic foreign function returns using PL_succeed
or PL_fail,  Prolog assumes the foreign function has cleaned its
environment. {\bf No} call with control argument {\tt PL_CUTTED} will follow.

The code of figure~\ref{fig:nondetermf} shows a skeleton for a
non-deterministic foreign predicate definition.

\begin{figure}
\begin{boxed}\begin{code}
typedef struct			/* define a context structure */
{ ...
} context;

foreign_t
my_function(term_t a0, term_t a1, foreign_t handle)
{ struct context * ctxt;

  switch( PL_foreign_control(handle) )
  { case PL_FIRST_CALL:
        ctxt = malloc(sizeof(struct context));
	...
	PL_retry_adress(ctxt);
    case PL_REDO:
	ctxt = PL_foreign_context_address(handle);
	...
	PL_retry_adress(ctxt);
    case PL_CUTTED:
	free(ctxt);
	PL_succeed;
  }
}
\end{code}\end{boxed}
    \caption{Skeleton for non-deterministic foreign functions}
    \label{fig:nondetermf}
\end{figure}


\subsection{Atoms and functors}

The following functions provide for communication using atoms and
functors.

.BF
.F atom_t PL_new_atom 1 const char *
Return an atom handle for the given C-string.  This function always
succeeds.  The returned handle is valid for the entire session.
.F char * PL_atom_chars 1 atom_t atom
Return a C-string for the text represented by the given atom.  The
returned text will not be changed by Prolog.  It is not allowed to
modify the contents, not even `temporary' as the string may reside
in read-only memory.
.F functor_t PL_new_functor 2 atom_t name, int arity
Returns a {\em functor identifier}, a handle for the name/arity
pair.  The returned handle is valid for the entire Prolog session.
.F atom_t PL_functor_name functor_t f
Return an atom representing the name of the given functor.
.F int PL_functor_arity functor_t f
Return the arity of the given functor.
.EF


\subsection{Analysing Terms via the Foreign Interface}

Each argument of a foreign function (except for the control argument) is
of type {\em term_t}, an opaque handle to a Prolog term. Three groups of
functions are available for the analysis of terms. The first just
validates the type, like the Prolog predicates var/1, atom/1, etc and
are called \tty{PL_is_*()}. The second group attemps to translate the
argument into a C primitive type. These predicates take a \tty{term_t}
and a pointer to the apropriate C-type and return \tty{TRUE} or
\tty{FALSE} depending on successful or unsuccessful translation. If the
translation fails, the pointed-to data is never modified.

\subsubsection{Testing the type of a term}

.BF
.F int PL_term_type 1 term_t
Obtain the type of a term, which should be a term returned by
one of the other interface predicates or passed as an argument. The
function returns the type of the Prolog term. The type identifiers are
listed below.  Note that the extraction functions \tty{PL_ge_t*()} also
validate the type and thus the two sections below are equivalent.

\begin{code}
	if ( PL_is_atom(t) )
	{ char *s;

	  PL_get_atom_chars(t, &s);
	  ...;
	}

or

	char *s;
	if ( PL_get_atom_chars(t, &s) )
	{ ...;
	}
\end{code}

\begin{tabular}{|p{\tableft}|p{3.5in}|}
\hline
\tt PL_VARIABLE & An unbound variable. The value of term as such is a unique
	          identifier for the variable. \\
\tt PL_ATOM	& A Prolog atom. \\
\tt PL_STRING	& A Prolog string. \\
\tt PL_INTEGER  & A Prolog integer. \\
\tt PL_FLOAT    & A Prolog floating point number. \\
\tt PL_TERM	& A compound term. Note that a list is a compound term with
	          name `.' and arity 2. \\
\hline
\end{tabular}
.EF

The functions PL_is_$<$type$>$ are an alternative to PL_term_type(). The
test ``PL_is_var(term)'' is equivalent to ``PL_term_type(term) ==
PL_VARIABLE'', but the first is considerably faster. On the other hande,
using a switch over PL_term_type() is faster and more readable then
using an if-then-else using the functions below.  All these functions
return either \tty{TRUE} or \tty{FALSE}.

.BF
.F int PL_is_variable 1 term_t
Returns non-zero if {\em term} is a variable.
.F int PL_is_atom 1 term_t
Returns non-zero if {\em term} is an atom.
.F int PL_is_string 1 term_t
Returns non-zero if {\em term} is a string.
.F int PL_is_integer 1 term_t
Returns non-zero if {\em term} is an integer.
.F int PL_is_float 1 term_t
Returns non-zero if {\em term} is a float.
.F int PL_is_compound 1 term_t
Returns non-zero if {\em term} is a compound term.
.F int PL_is_functor 2 term_t, functor_t
Returns non-zero if {\em term} is compound and its functor is {\em functor}.
This test is equivalent to PL_get_functor(), followed by testing the
functor, but easier to write and faster.
.F int PL_is_list 1 term_t
Returns non-zero if {\em term} is a compound term with functor ./2 or
the atom \tty{[]}.
.F int PL_is_atomic 1 term_t
Returns non-zero if {\em term} is atomic (not variable or compound).
.F int PL_is_number 1 term_t
Returns non-zero if {\em term} is an integer or float.
.EF


\subsubsection{Reading data from a term}

The functions \tty{PL_get_*()} read information from a Prolog term. Most
of them take two arguments.  The first is the input term and the second
is a pointer to the output value or a term-reference.

.BF
.F int PL_get_atom 2 term_t +t, atom_t *a
If {\em t} is an atom, store the unique atom identifier over {\em a}.
See also PL_string_from_atom() and PL_new_atom().  If there is
no need to access the data (characters) of an atom, it is advised to
manipulate atoms using their handle.
.F int PL_get_atom_chars 2 term_t +t, char **s
If {\em t} is an atom, store a pointer to a 0-terminated C-string in
{\em s}.  It is explicitely {\bf not} allows to modifify the contents
of this string.  Some built-in atoms may have the string allocated in
read-only memory, so `temporary manipulation' can cause an error.
.F int PL_get_string 2 term_t +t, char **s, int *len
If {\em t} is a string object, store a pointer to a 0-terminated
C-string in {\em s} and the length of the string in {\em len}.  Note
that this pointer is invalidated by backtracting, garbage-collection
and stack-shifts, so generally the only save operations are to pass
it immediately to a C-function that doesn't involve Prolog.
.F int PL_get_chars 3 term_t +t, char **s, unsigned flags
Convert the argument term {\em t} to a 0-terminated C-string.  {\em
flags} is a bitwise disjunction from two groups of constants.  The
first specifies which term-types should converted and the second
how the argument is stored.  Below is a specification of these
constants.  \tty{BUF_RING} implies, if the data is not static
(as from an atom), the data is copied to the next buffer from a
ring of four (4) buffers.  This is a convienent way of converting
multiple arguments passed to a foreign predicate to C-strings.  If
BUF_MALLOC is used, the data must be freed using free() when not
needed any longer.

\begin{tabular}{|p{\tableft}|p{3.5in}|}
\hline
\tt CVT_ATOM	& Convert if term is an atom \\
\tt CVT_STRING	& Convert if term is a string \\
\tt CVT_LIST	& Convert if term is a list of integers between 1 and 255 \\
\tt CVT_INTEGER	& Convert if term is an integer (using \tty{\%d}) \\
\tt CVT_FLOAT	& Convert if term is a float (using \tty{\%f}) \\
\tt CVT_NUMBER	& Convert if term is a integer or float \\
\tt CVT_ATOMIC	& Convert if term is atomic \\
\tt CVT_VARIABLE& Convert variable to print-name \\
\tt CVT_ALL	& Convert if term is any of the above, except for
  		  variables \\
\hline
\tt BUF_DISCARDABLE	& Data must copied immediately \\
\tt BUF_RING	& Data is stored in a ring of buffers \\
\tt BUF_MALLOC	& Data is copied to a new buffer returned by malloc() \\
\hline
\end{tabular}
.F int PL_get_list_chars 3 +term_t l, char **s, unsigned flags
Same as {\tt PL_get_chars({\em l}, {\em s}, CVT_LIST|{\em flags})},
provided {\em flags} contains no of the \tty{CVT_*} flags.
.F int PL_get_integer 2 +term_t t, int *i
If {\em t} is a Prolog integer, assign its value over {\em i}.  On
32-bit machines, this is the same as PL_get_long(), but avoids a
warning from the compiler.  See also PL_get_long().
.F int PL_get_long 2 term_t +t, long *i
If {\em t} is a Prolog integer, assign its value over {\em i}.  Note
that Prolog integers have limited value-range.  If {\em t} is a floating
point number that can be represented as a long, this function succeeds
as well.
.F int PL_get_pointer 2 term_t +t, void **ptr
In the current system, pointers are represented by Prolog integers,
but need some manipulation to make sure they donot get truncated due
to the limited Prolog integer range.  PL_put_pointer()/PL_get_pointer()
guarantees pointers in the range of malloc() are handled without
truncating.
.F int PL_get_float 2 term_t +t, double *f
If {\em t} is a float or integer, its value is assigned over {\em f}.
.F int PL_get_functor 2 term_t +t, functor_t *f
If {\em t} is compound or an atom, the Prolog representation of the
name-arity pair will be assigned over {\em f}. See also
PL_get_name_arity() and PL_is_functor().
.F int PL_get_name_arity 3 term_t +t, atom_t *name, int *arity
If {\em t} is compound or an atom, the functor-name will be assigned
over {\em name} and the arity over {\em arity}. See also
PL_get_functor() and PL_is_functor().
.F int PL_get_module 2 term_t +t, module_t *module
If {\em t} is an atom, the system will lookup or create the
corresponding module and assign an opaque pointer to it over {\em
module},.
.F int PL_get_arg 3 int index, term_t +t, term_t -a
If {\em t} is compound and index is between 1 and arity (including),
assign {\em a} with a term-reference to the argument.
.EF


\subsubsection{Reading a list}

The functions from this section are intended to read a Prolog list from
C.  Suppose we expect a list of atoms, the following code will print the
atoms, each on a line:

\begin{boxed}\begin{code}
foreign_t
pl_write_atoms(term_t l)
{ term_t head = PL_new_term_ref();	/* variable for the elements */
  term_t list = PL_copy_term_ref();	/* copy as we need to write */

  while( PL_get_list(list, head, list) )
  { char *s;

    if ( PL_get_atom_chars(head, &s) )
      Sprintf("%s\n", s);
    else
      PL_fail;
  }

  return PL_get_nil(list);		/* test end for [] */
}
\end{code}\end{boxed}


.BF
.F int PL_get_list 3 term_t +l, term_t -h, term_t -t
If {\em l} is a list and not \tty{[]} assign a term-reference to the
head to {\em h} and to the tail to {\em t}.
.F int PL_get_head 2 term_t +l, term_t -h
If {\em l} is a list and not \tty{[]} assign a term-reference to the
head to {\em h}.
.F int PL_get_tail 2 term_t +l, term_t -t
If {\em l} is a list and not \tty{[]} assign a term-reference to the
tail to {\em t}.
.F int PL_get_nil 1 term_t +l
Succeeds if {\em} represents the atom \tty{[]}.
.EF


\subsubsection{An example: defining display/1 in C}

Figure~\ref{fig:pl-display} shows a definition of display/1 to
illustrate the described functions.

\begin{figure}
\begin{boxed}
\begin{code}
foreign_t
pl_display(term_t t)
{ functor_t functor;
  int arity, len, n;
  char *s;

  switch( PL_term_type(t) )
  { case PL_VARIABLE:
    case PL_ATOM:
    case PL_INTEGER:
    case PL_FLOAT:
      PL_get_chars(t, &s, CVT_ALL);
      Sprintf("%s", s);
      break;
    case PL_STRING:
      PL_get_string_chars(t, &s, &len);
      Sprintf("\"%s\"", s);
      break;
    case PL_TERM:
    { term_t a = PL_new_term_ref();

      PL_get_name_arity(t, &name, &arity);
      Sprintf("%s(", PL_string_from_atom(name));
      for(n=1; n<=arity; n++)
      { PL_get_arg(n, t, a);
	if ( n > 1 )
	  Sprintf(", ");
	pl_display(a);
      }
      Sprintf(")");
      break;
    default:
      PL_fail;				/* should not happen */
  }

  PL_succeed;
}
\end{code}
\end{boxed}
    \caption{A Foreign definition of display/1}
    \label{fig:pl-display}
\end{figure}


\subsection{Constructing Terms}

Terms can be constructed using functions from the \tty{PL_put_*()} and
\tty{PL_cons_*()} families. This approach builds the term `inside-out',
starting at the leaves and subsequently creating compound terms.
Alternatively, terms may be created `top-down', first creating a
compound holding only variables and subsequently unifying the arguments.
This section discusses functions for the first approach. This approach
is generally used for creating arguments for PL_call() and
PL_open_query.

.BF
.F void PL_put_variable 1 term_t -t
Put a fresh variable in the term.  The new variable lives on the global
stack.  Note that the initial variable lives on the local stack and is
lost after a write to the term-references.  After using this function,
the variable will continue to live.
.F void PL_put_atom 2 term_t -t, atom_t a
Put an atom in the term reference from a handle.  See also
PL_new_atom() and PL_string_from_atom().
.F void PL_put_atom_chars 2 term_t -t, const char *chars
Put an atom in the term-reference constructed from the 0-terminated
string.  The string itself will never be references by Prolog after this
function.
.F void PL_put_string_chars 2 term_t -t, const char *chars
Put a string in the term-reference.  The data will be copied.
.F void PL_put_list_chars 2 term_t -t, const char *chars
Put a list of ASCII values in the term-reference.
.F void PL_put_integer 2 term_t -t, long i
Put a Prolog integer in the term reference.
.F void PL_put_pointer 2 term_t -t, void *ptr
Put a Prolog integer in the term-reference.  Provided ptr is in the
`malloc()-area', PL_get_pointer() will get the pointer back.
.F void PL_put_float 2 term_t -t, double f
Put a floating-point value in the term-reference.
.F void PL_put_functor 2 term_t -t, functor_t functor
Create a new compound term from {\em functor} and bind {\em t} to
this term. All arguments of the term will be variables. To create
a term with instantiated arguments, either instantiate the arguments
using the \tty{PL_unify_*()} functions or use PL_cons_functor().
.F void PL_put_list 2 term_t -l
Same as \tty{PL_put_functor(l, PL_new_functor(PL_new_atom("."), 2))}.
.F void PL_put_nil 2 term_t -l
Same as \tty{PL_put_atom_chars("[]")}.
.F void PL_put_term 2 term_t -t1, term_t +t2
Make {\em t1} point to the same term as {\em t2}.
.F void PL_cons_functor 3 term_t -h, functor_t f, ...
Create a term, whose arguments are filled from variable argument list
holding the same number of term_t objects as the arity of the functor.
To create the term \tty{animal(gnu, 50)}, use:

\begin{boxed}\begin{code}
	term_t a1 = PL_new_term_ref();
        term_t a2 = PL_new_term_ref();
	term_t t;

	PL_put_atom_chars(a1, "gnu");
	PL_put_integer(a2, 50);
	PL_cons_functor(t, PL_new_functor(PL_new_atom("animal"), 2),
			a1, a2);
\end{code}\end{boxed}


After this sequence, the term-references {\em a1} and {\em a2} may
be used for other purposes.
.F void PL_cons_list 3 term_t -l, term_t +h, term_t +t
Create a list (cons-) cell in {\em l} from the head and tail.  The
code below creates a list of atoms from a {\tt char **}.  The list
is built tail-to-head.  The \tty{PL_unify_*()} functions can be used
to build a list head-to-tail.

\begin{boxed}\begin{code}
void
put_list(term_t l, int n, char **words)
{ term_t a = PL_new_term_ref();

  PL_put_nil(l);
  while( --n >= 0 )
  { PL_put_atom_chars(a, words[n]);
    PL_put_list(l, a, l);
  }
}
\end{code}\end{boxed}
.EF


\subsection{Unifying data}

The functions of this sections {\em unify} terms with other terms or
translated C-data structures. Except for PL_unify(), the functions of
this section are specific to SWI-Prolog. They have been introduced to
make translation of old code easier, but also because they provide for
a faster mechanism for returning data to Prolog tht requires less
term-references.  Consider the case where we want a foreign function
to return the hostname of the machine Prolog is running on.  Using
the \tty{PL_get_*()} and \tty{PL_put_*()} functions, the code becomes:

\begin{boxed}\begin{code}
foreign_t
pl_hostname(term_t name)
{ char buf[100];
  
  if ( gethostname(buf, sizeof(buf)) )
  { term_t tmp = PL_new_term_ref();

    PL_put_atom_chars(tmp, buf);
    return PL_unify(name, buf);
  }

  PL_fail;
}
\end{code}\end{boxed}

Using PL_unify_atom_chars(), this becomes:

\begin{boxed}\begin{code}
foreign_t
pl_hostname(term_t name)
{ char buf[100];
  
  if ( gethostname(buf, sizeof(buf)) )
    return PL_unify_atom_chars(name, buf);

  PL_fail;
}
\end{code}\end{boxed}


.BF
.F int PL_unify 2 term_t ?t1, term_t ?t2
Unify two Prolog terms and return non-zero on success.
.F int PL_unify_atom 2 term_t ?t, atom_t a
Unify {\em t} with the atom {\em a} and return non-zero on success.
.F int PL_unify_atom_chars 2 term_t ?t, const char *chars
Unify {\em t} with an atom created from {\em chars}  and return non-zero
on success.
.F int PL_unify_list_chars 2 term_t ?t, const char *chars
Unify {\em t} with a list of ASCII characters constructed from
{\em chars}.
.F int PL_unify_string_chars 2 term_t ?t, const char *chars
Unify {\em t} with a Prolog string object created from {\em chars}.
.F int PL_unify_integer 2 term_t ?t, long n
Unify {\em t} with a Prolog integer from {\em n}.
.F int PL_unify_float 2 term_t ?t, double f
Unify {\em t} with a Prolog float from {\em f}.
.F int PL_unify_pointer 2 term_t ?t, void *ptr
Unify {\em t} with a Prolog integer describing the pointer. See also
PL_put_pointer() and PL_get_pointer().
.F int PL_unify_functor 2 term_t ?t, functor_t f
If {\em t} is a compound term with the given functor, just succeed.
If it is unbound, create a term and bind the variable, else fails.
Not that this function does not create a term if the argument is
already instantiated.
.F int PL_unify_list 2 term_t ?l, term_t +h, term_t -t
Unify {\em l} with a list-cell (\tty{./2}) and {\em h} with
the head of the list.  Finally write a reference to the tail
of the list in {\em t}.  This reference may be used for subsequent
calls to this function.  Suppose we want to return a list of atoms
from a {\tt char **}. We could use the example described by
PL_put_list(), followed by a call to PL_unify(), or we can use the
code below.  If the predicate argument is unbound, the difference
is minimal (the code based on PL_put_list() is probably slightly
faster).  If the argument is bound, the code below may fail before
reaching the end of the word-list, but even if the unification
succeeds, this code avoids a duplicate (garbage) list and an
expensive deep unification.

\begin{boxed}\begin{code}
foreign_t
pl_get_environ(term_t env)
{ term_t l = PL_copy_term_ref(env);
  term_t a = PL_new_term_ref();
  extern char **environ;

  while(*environ)
  { PL_put_atom_chars(a, *environ);
    if ( !PL_unify_list(l, a, l) )
      fail;
  }

  return PL_unify_nil(l);
}
\end{code}\end{boxed}
.F int PL_unify_nil 1 term_t ?l
Unifys {\em l} with the atom {\tt []}.
.F int PL_unify_arg 3 int index, term_t ?t, term_t ?a
Unifies the {\em index-th} argument (1-based) of {\em t} with
{\em a}.
.EF


\subsection{Calling Prolog from C}

The Prolog engine can be called from C. There are to interfaces for
this. For the first, a term is created that could be used as an argument
to call/1 and next PL_call() is used to call Prolog. This system is
simple, but does not allow to inspect the different answers to a
non-deterministic goal and is relatively slow as the runtime system
needs to find the predicate. The other interface is based on
PL_open_query(), PL_next_solution() and PL_cut_query() or
PL_close_query(). This mechanism is more powerful, but also more
complicated to use.


\subsubsection{Predicate references}

This section discusses the functions used to communicate about
predicates. Though a Prolog predicate may defined or not, redefined,
etc., a Prolog predicate has a handle that is not destroyed, nor moved.
This handle is known by the type {\tt predicate_t}.

.BF
.F predicate_t PL_pred 2 functor_t f, module_t m
Return a handle to a predicate for the specified name/arity in the given
module. This function always succeeds, creating a handle for an
undefined predicate if no handle was available.
.F predicate_t PL_predicate 3 const char *name, int arity, const char* module
Same a PL_pred(), but provides a more convenient interface to
the C-programmer.
.F void PL_predicate_info 4 predicate_t p, atom_t *n, int *a, module_t *m
Return information on the predicate {\em p}.  The name is stored
over {\em n}, the arity over {\em a}, while {\em m} receives the
definition module.  Note that the latter need not be the same as
specified with PL_predicate().  If the predicate was imported into
the module given to PL_predicate(), this function will return the
module where the predicate was defined.
.EF


\subsubsection{Initiating a query from C}

This section discusses the functions for creating and manipulating
queries from C.  Note that a foreign context can have at most one
active query.  This implies it is allowed to make stricktly nested
calls between C and Prolog (Prolog calls C, calls Prolog, calls C,
etc., but it is {\em not} allowed to open multiple queries and start
generating solutions for each of them by calling PL_next_solution().
Be sure to call PL_cut_query() or PL_close_query() on any query you
opened before opening the next or returning control back to Prolog.


.BF
.F qid_t PL_open_query 4 module_t ctx, int debug, predicate_t p, term_t +t0
Opens a query and returns an identifier for it.	 This function always
succeeds, irregardless whether the predicate is defined or not.  {\em
ctx} is the {\em context module} of the goal.  When {\tt NULL}, the
context module of the calling context will be used, or {\tt user}
if there is no calling context (as may happen in embedded systems).
Note that the context module only matters for {\em module_transparent}
predicates.  See context_module/1 and module_transparent/2.
The {\em debug} argument is normally {\tt TRUE}.  If {\em FALSE}
is specified, the goal is ran in `nodebug' mode, irregardless of
the current debug mode.  The {\em p} argument specifies the predicate,
and should be the result of a call to PL_pred() or PL_predicate().  Note
that it is allowed to store this handle as global data and reuse it
for future queries.  The term-reference {\em t0} is the first of a
vector of term-references as returned by PL_new_term_refs(n).

The example below opens	a query to the predicate is_a/2 to find the
ancestor of for some name.

\begin{boxed}\begin{code}
char *
ancestor(const char *me)
{ term_t a0 = PL_new_term_refs(2);
  static predicate_t p;

  if ( !p )
    p = PL_predicate("is_a", 2, "database");

  PL_put_atom_chars(a0, me);
  PL_open_query(NULL, TRUE, p, a0);
  ...
}
\end{code}\end{boxed}

.F int PL_next_solution 1 qid_t qid
Generate the first (next) solution for the given query.  The return
value is {\em TRUE} if a solution was found, or {\em FALSE} to indicate
the query could not be proven.  This function may be called repeatedly
until it fails to generate all solutions to the query.
.F void PL_cut_query 1 qid
Discards the query, but does not delete any of the data created by the
query.  It just invalidate {\em qid}, allowing for a new call to
PL_open_query() in this context.
.F void PL_close_query 1 qid
As PL_cut_query(), but all data and bindings created by the query are
destroyed.
.F int PL_call_predicate 4 module_t m, int debug, predicate_t pred, term_t +t0
Shorthand for PL_open_query(), PL_next_solution(), PL_cut_query(),
generating a single solution.  The arguments are the same as for
PL_open_query(), the return value is the same as PL_next_solution().
.F int PL_call 2 term_t, module_t
Call term just like the Prolog predicate once/1. {\em Term} is called
in the specified module, or in the context module if module_t = NULL.
Returns \tty{TRUE} if the call succeeds, \tty{FALSE} otherwise.
Figure~\ref{fig:calling} shows an example to obtain the number of
defined atoms. All checks are omitted to improve readability.
.EF

\subsection{Discarding Data}

The Prolog data created and term-references needed to setup the call
and/or analyse the result can in most cases be discarded right after the
call. PL_close_query() allows for destructing the data, while leaving
the term-references. The calls below may be used to destroy
term-references and data. See figure~\ref{fig:calling} for an example.

.BF
.F fid_t PL_open_foreign_frame 0
Created a foreign frame, holding a mark that allows the system to
undo bindings and destroy data created after it as well as providing
the environment for creating term-references.  This function is called
by the kernel before calling a foreing predicate.
.F void PL_close_foreign_frame 1 fid_t id
Discard all term-references created after the frame was opened.  All
other Prolog data is retained.  This function is called by the kernel
whenever a foreign function returns control back to Prolog.
.F void PL_discard_foreign_frame 1 fid_t id
Same as PL_close_foreign_frame(), but also undo all bindings made since
the open and destroy all Prolog data.
.EF

It is obligatory to call either of the two closing functions to discard
a foreign frame.  Foreign frames may be nested.


\begin{figure}
\begin{boxed}
\begin{code}
int
count_atoms()
{ fid_t fid = PL_open_foreign_frame();
  term_t goal  = PL_new_term_ref();
  term_t a1    = PL_new_term_ref();
  term_t a2    = PL_new_term_ref();
  functor_t s2 = PL_new_functor(PL_new_atom("statistics"), 2);
  int atoms;
  
  PL_put_atom_chars(a1, "atoms");
  PL_cons_functor(goal, s2, a1, a2);
  PL_call(t, NULL);         /* call it in current module */
  
  PL_get_integer(a2, &atoms);
  PL_discard_foreign_frame(fid);
  
  return atoms;
}
\end{code}
\end{boxed}
     \caption{Calling Prolog}
     \label{fig:calling}
\end{figure}


\subsection{Foreign Code and Modules}

Modules are identified via a unique handle.  The following functions
are available to query and manipulate modules.

.BF
.F module_t PL_context 0
Return the module identifier of the context module of the currently
active foreign predicate.
.F PL_strip_module 3 term_t +raw, module_t *m, term_t -plain
Utility function. If {\em term_t} is a term, possibly holding the module
construct {\em module:rest} this function will make {\em plain} a
reference to {\em rest} and fill {\em module *} with {\em module}. For
further nested module constructs the inner most module is returned via
{\em module *}. If {\em term} is not a module construct {\em term} will
simply be put in {\em plain}. If {\em module *} is \tty{NULL} it will be
set to the context module. Otherwise it will be left untouched. The
following example shows how to obtain the plain term and module if the
default module is the user module:

\begin{boxed}
\begin{code}
{ module m = PL_new_module(PL_new_atom("user"));
  term_t plain = PL_new_term_ref();

  PL_strip_module(term, &m, plain);
  ...
\end{code}
\end{boxed}

.F atom_t PL_module_name 1 module_t
Return the name of {\em module} as an atom.
.F module_t PL_new_module 1 atom_t
Find an existing or create a new module with name specified by the atom
{\em atomic}.
.EF


\subsection{Misceleneous}

.BF
.F int PL_compare 2 term_t t1, term_t t2
Compares two terms using the standard order of terms and returns -1, 0
or 1.  See also compare/3.
.EF


\subsection{Catching Signals (Software Interrupts)}

SWI-Prolog catches the Unix signals SIGINT, SIGFPE and SIGSEGV.  To
avoid problems with foreign code attempting to catch these signals
foreign code should call PL_signal() to install signal handlers rather
than the Unix library function signal().  SWI-Prolog will always handle
SIGINT itself.  SIGFPE and SIGSEGV are passed to the foreign code
handlers if Prolog did not expect that signal.

.BF
.F void (*PL_signal({\it{sig,~func}})) 0
This function should be used to install signal handlers rather than the
Unix library function signal().  It ensures consistent signal handling
between SWI-Prolog and the foreign code and reinstalls signal handlers
if a state created with save_program/1 is restarted.
.EF


\subsection{Errors and warnings}

Two standard functions are available to print standard Prolog errors to
the standard error stream.

.BF
.F int PL_warning 1 format, a1, ...
Print an error message starting with `\tty{[WARNING: }', followed by
the output from {\em format}, followed by a `\tty{]}' and a newline.
Then start the tracer. {\em format} and the arguments are the same as
for printf(2).  Always returns FALSE.
.EF

\subsection{Environment Control from Foreign Code}
.BF
.F int PL_action 2 int, C_type
Perform some action on the Prolog system. {\em int} describes the
action, {\em C_type} provides the argument if necessary. The actions
are listed in table~\ref{tab:action}.

\begin{table}
\begin{quote}\begin{tabular}{|p{\tableft}|p{3.5in}|}
\hline
\tt PL_ACTION_TRACE	& Start Prolog tracer \\
\tt PL_ACTION_DEBUG	& Switch on Prolog debug mode \\
\tt PL_ACTION_BACKTRACE	& Print backtrace on current output stream.
			  The argument (an int) is the number of frames
			  printed. \\
\tt PL_ACTION_HALT	& Halt Prolog execution. This action should be
			  called rather than Unix exit() to give Prolog
			  the opportunity to clean up. This call does
			  not return. \\
\tt PL_ACTION_ABORT	& Generate a Prolog abort. This call does not
			  return. \\
\tt PL_ACTION_BREAK	& Create a standard Prolog break environment. Returns
			  after the user types control-D. \\
\tt PL_ACTION_SYMBOLFILE& The argument (a char *) is considered to be
			  hold the symbolfile for further incremental
			  loading. Should be called by user applications
			  that perform incremental loading as well and
			  want to inform Prolog of the new symbol table. \\
\hline
\end{tabular}\end{quote}

    \caption{PL_action() options}
    \label{tab:action}
\end{table}
.EF

\subsection{Querying Prolog}
.BF
.F C_type PL_query 1 int
Obtain status information on the Prolog system. The actual argument
type depends on the information required. {\em int} describes what
information is wanted. The  options are given in table~\ref{tab:query}.


\begin{table}
\begin{quote}\begin{tabular}{|p{\tableft}|p{3.5in}|}
\hline
\tt PL_QUERY_ARGC	& Return an integer holding the number of
			  arguments given to Prolog from Unix. \\
\tt PL_QUERY_ARGV	& Return a char ** holding the argument vector
			  given to Prolog from Unix. \\
\tt PL_QUERY_SYMBOLFILE & Return a char * holding the current symbol
			  file of the running process. \\
\tt PL_QUERY_ORGSYMBOLFILE& Return the initial symbol file (before
			  loading) of Prolog. By setting the symbol file
			  to this value no name clashes can occur with
			  previously loaded foreign files (but no symbols
			  can be shared with earlier loaded modules as well).\\
\tt PL_MAX_INTEGER	& Return a long, representing the maximal integer
			  value represented by Prolog's tagged integers. \\
\tt PL_MIN_INTEGER	& Return a long, represented the minimal integer
			  value. \\
\hline
\end{tabular}\end{quote}

    \caption{PL_query() options}
    \label{tab:query}
\end{table}
.EF

\subsection{Registering Foreign Predicates}
.BF
.F int PL_register_foreign 4 name, arity, function, flags
Register a C-function to implement a Prolog predicate. After this call
returns successfully a predicate with name {\em name} (a char *) and
arity {\em arity} (a C int) is created. When called in Prolog, Prolog
will call {\em function}. {\em flags} forms bitwise or'ed list of
options for the installation. These are:

\begin{tabular}{|p{\tableft}|p{3.5in}|}
\hline
\tt PL_FA_NOTRACE	& Predicate cannot be seen in the tracer \\
\tt PL_FA_TRANSPARENT	& Predicate is module transparent \\
\tt PL_FA_NONDETERMINISTIC & Predicate is non-deterministic. This
			  attribute is currently ignored, but will probably
			  be used in future versions. \\
\hline
\end{tabular}
.EF

\subsection{Foreign Code Hooks}

For various specific applications some hooks re provided.

.BF
.F PL_dispatch_hook_t PL_dispatch_hook 1 PL_dispatch_hook_t
If this hook is not NULL, this function is called when reading from the
terminal. It is supposed to dispatch events when SWI-Prolog is connected
to a window environment. It can return two values: {\tt
PL_DISPATCH_INPUT} indicates Prolog input is available on file
descriptor 0 or \tty{PL_DISPATCH_TIMEOUT} to indicate a timeout. The old
hook is returned. The type \tty{PL_dispatch_hook_t} is defined as:
\begin{code}
typedef int  (*PL_dispatch_hook_t)(void);
\end{code}
.F void PL_abort_hook 1 PL_abort_hook_t
Install a hook when abort/0 is executed. SWI-Prolog abort/0 is
implemented using C setjmp()/longjmp() construct.  The hooks are
executed in the reverse order of their registration after the longjmp()
took place and before the Prolog toplevel is reinvoked. The type
\tty{PL_abort_hook_t} is defined as:
\begin{code}
typedef void (*PL_abort_hook_t)(void);
\end{code}
.F int PL_abort_unhook 1 PL_abort_hook_t
Remove a hook installed with PL_abort_hook(). Returns \tty{FALSE} if no
such hook is found, \tty{TRUE} otherwise.
.F void PL_reinit_hook 1 PL_reinit_hook_t
Install a hook that is called when a saved program (using
save_program/[1,2]) is restored. The hooks are called in reverse order.
The type \tty{PL_reinit_hook_t} is defined as:
\begin{code}
typedef void (*PL_reinit_hook_t)(int argc, char **argv);
\end{code}
.F int PL_reinit_unhook 1 PL_reinit_hook_t
Remove a hook installed with PL_reinit_hook(). Returns \tty{FALSE} if
no such hook is found, \tty{TRUE} otherwise.
.EF


\subsection{Embedding SWI-Prolog in a C-program}

As of version 2.1.0, SWI-Prolog may be embedded in a C-program.
To reach at a compiled C-program with SWI-Prolog as an embedded
application is very similar to creating a statically linked SWI-Prolog
executable as described in section~\ref{sec:staticl}.

The file {\tt .../pl/include/stub.c} defines SWI-Prologs default main
program:

\begin{boxed}
\begin{code}
int
main(int argc, char **argv, char **env)
{ if ( !PL_initialise(argc, argv, env) )
    PL_halt(1);

  PL_install_readline();	/* delete if you don't want readline */

  PL_halt(PL_toplevel() ? 0 : 1);
}
\end{code}
\end{boxed}

This may be replaced with your own main C-program. The interface
function PL_initialise() {\bf must} be called before any of the other
SWI-Prolog foreign language functions described in this chapter.  
PL_initialise() interprets all the command-line arguments, except for
the {\tt -t}{\it toplevel} flag that is interpreted by PL_toplevel().

.BF
.F int PL_initialise 3 int argc, char **argv, char **environ
Initialises the SWI-Prolog heap and stacks, restores the boot QLF file,
loads the system and personal initialisation initialisation files, runs
the at_initialisation/1 hooks and finally runs the {\tt -g goal} hook.

PL_initialise() returns 1 if all initialisation succeeded and 0
otherwise.  Various fatal errors may cause PL_initialise to call
PL_halt(1), preventing it from returning at all.
.F void PL_install_readline 0
Installs the GNU-readline line-editor.  Embedded applications that donot
use the Prolog toplevel should normally delete this line, shrinking the
Prolog kernel significantly.
.F int PL_toplevel 0
Runs the goal of the {\tt -t}{\it toplevel} switch (default prolog/0) and
returns 1 if successful, 0 otherwise.
.F void PL_halt 1 int status
Cleanup the Prolog environment and calls exit() with the status
argument.
.EF

\section{Linking embedded and statically linked extensions using plld}
\label{sec:plld}

The utility program {\tt plld} may be used to link a combination of
C-files and Prolog files into a stand-alone executable.  It is a simple
Bourne-shell script that automates most of the steps outlined in the
previous sections.

In the normal usage, a copy is made of the default embedding template
{\tt .../pl/include/stub.c}.  Additional foreign predicates are defined
and added to the extension table {\tt PL_extensions}. The main() routine
is modified to suit your application.  PL_initialise() {\bf must} be
passed the program-name ({\tt argv[0]}).  The other elements of the
command-line may be modified.  Next, {\tt plld} is typically invoked as:

\begin{code}
plld -o output stubfile.c [other-c-or-o-files] [plfiles]
\end{code}

{\tt plld} will first split the options into various groups for both the
C-compiler and the Prolog compiler. Next, it will add various default
options to the C-compiler and call it to create an executable holding
the user's C-code and the Prolog kernel. Then, it will call the
SWI-Prolog compiler to create a saved state from the provided Prolog
files and finally, it will attach this saved state to the created
emulator to create the requested executable.

Below, it is described how the options are split and which additional
options are passed.

\begin{description}
\newcommand{\option}[1]{\item[\tt #1]\mbox{}\\}
    \option{-o {\em outfile}}
Reserved to specify the final output file.
    \option{-l{\em library}}
Specifies a library for the C-compiler.  By default, {\tt -lpl} and the
libraries needed by the Prolog kernel are given.
    \option{-L{\em library-directory}}
Specifies a library directory for the C-compiler.  By default the
directory containing -lpl for the current architecture is passed.
    \option{-g {\rm or} -I{\em include-directory}}
These options are passed to the C-compiler.  By default, the include
directory containing \verb$<SWI-Prolog.h>$ is passed.
    \option{*.o {\rm or} *.c {\rm or} *.C {\rm or} *.cxx {\rm or} *.cpp}
Passed as input files to the C-compiler
    \option{*.pl {\rm or} *.qlf}
Passed as input files to the Prolog compiler to create the saved-state.
    \option{*}
I.e.\ all other options. These are passed as linker options to the
C-compiler.
\end{description}


\subsection{A simple example}

The following is a very simple example going through all the steps
outlined above. It provides an arithmetic expression evaluator. We will
call the application {\tt calc} and define it in the files {\tt calc.c}
and {\tt calc.pl}.  The Prolog file is simple:

\begin{boxed}\begin{code}
calc(Atom) :-
	term_to_atom(Expr, Atom),
	A is Expr,
	write(A),
	nl.
\end{code}\end{boxed}

The C-part of the application parses the command-line options,
initialises the Prolog engine, locates the calc/1 predicate and calls
it.  The coder is in figure~\ref{fig:calc}.

\begin{figure}
\begin{boxed}\begin{code}
#include <stdio.h>
#include <SWI-Prolog.h>

PL_extension PL_extensions [] =
{
/*{ "name",	arity,  function,	PL_FA_<flags> },*/

  { NULL,	0, 	NULL,		0 }	/* terminating line */
};


#define MAXLINE 1024

int
main(int argc, char **argv, char **env)
{ char expression[MAXLINE];
  char *e = expression;
  char *program = argv[0];
  char *plav[2];
  int n;

  /* combine all the arguments in a single string */

  for(n=1; n<argc; n++)
  { if ( n != 1 )
      *e++ = ' ';
    strcpy(e, argv[n]);
    e += strlen(e);
  }

  /* make the argument vector for Prolog */

  plav[0] = program;
  plav[1] = NULL;

  /* initialise Prolog */

  if ( !PL_initialise(1, plav, env) )
    PL_halt(1);

  /* Lookup calc/1 and make the arguments and call */

  { predicate_t pred = PL_predicate("calc", 1, "user");
    term_t h0 = PL_new_term_refs(1);
    int rval;

    PL_put_atom_chars(h0, expression);
    rval = PL_call_predicate(NULL, FALSE, pred, h0);

    PL_halt(rval);
  }

  return 0;
}
\end{code}\end{boxed}
\caption{C-source for the calc application}
\label{fig:calc}
\end{figure}

\noindent
The application is now created using the following command-line:

\begin{code}
% plld -o calc calc.c calc.pl
\end{code}

\noindent
The following indicates the usage of the application:

\begin{code}
% calc pi/2
1.5708
\end{code}


\section{Example of Using the Foreign Interface}

Below is an example showing all stages of the declaration of a foreign
predicate that transforms atoms possibly holding uppercase letters into
an atom only holding lower case letters. Figure~\ref{fig:lowercase-c}
shows the C-source file, figure~\ref{fig:load-foreign} illustrates
compiling and loading of foreign code.


\begin{figure}[htb]
\begin{boxed}
\begin{code}
/*  Include file depends on local installation */
#include <SWI-Prolog.h>
#include <stdlib.h>
#include <ctype.h>

foreign_t
pl_lowercase(term_t u, term_t l)
{ char *copy;
  char *s, *q;
  int rval;

  if ( !PL_get_atom_chars(u, &s) )
    return PL_warning("lowercase/2: instantiation fault");
  copy = malloc(strlen(s)+1);

  for( q=copy; *s; q++, s++)
    *q = (isupper(*s) ? tolower(*s) : *s);
  *q = '\0';

  rval = PL_unify_atom_chars(l, copy);
  free(copy);

  return rval;
}

install_t
install()
{ PL_register_foreign("lowercase", 2, pl_lowercase, 0);
}
\end{code}
\end{boxed}
    \caption{Lowercase source file}
    \label{fig:lowercase-c}
\end{figure}


\begin{figure}[htb]
\begin{boxed}
\begin{code}
% gcc -I/usr/local/lib/pl-2.2.0/include -fpic -c lowercase.c
% gcc -shared -o lowercase.so lowercase.o
% pl
.VERSION

1 ?- load_foreign_library(lowercase).

Yes
2 ?- lowercase('Hello World!', L).

L = 'hello world!' 

Yes
\end{code}
\end{boxed}
    \caption{Compiling the C-source and loading the object file}
    \label{fig:load-foreign}
\end{figure}
\clearpage


\section{Notes on Using Foreign Code}

\subsection{Memory Allocation}

SWI-Prolog's memory allocation is based on the malloc() library
routines.  Foreign applications can savely use malloc(), realloc() and
free(). Memory allocation using brk() or sbrk() is not allowed as these
calls conflict with malloc().

\subsection{Debugging Foreign Code}

Statically linked foreign code or embedded systems can be debugged
normally.  Most modern environments provide debugging tools for
dynamically loaded shared objects or dynamic load libraries.  The
following example traces the code of lowercase using gdb(1) in a
Unix environment.

\begin{boxed}\begin{code}
% gcc -I/usr/local/lib/pl-2.2.0/include -fpic -c -g lowercase.c
% gcc -shared -o lowercase.so lowercase.o
% gdb pl
(gdb) r
.VERSION
?- load_foreign_library(lowercase).
<type Control-C>
(gdb) shared			% loads symbols for shared objects
(gdb) break pl_lowercase
(gdb) continue
?- lowercase('HELLO', X).
\end{code}\end{boxed}

\subsection{Name Conflicts in C modules}

In the current version of the system all public C functions of
SWI-Prolog are in the symbol table.  This can lead to name clashes with
foreign code.  Someday I should write a program to strip all these
symbols from the symbol table (why does Unix not have that?).  For now
I can only suggest to give your function another name.  You can do this
using the C preprocessor.  If --for example-- your foreign package uses
a function warning(), which happens to exist in SWI-Prolog as well, the
following macro should fix the problem.

\begin{code}
#define warning warning_
\end{code}

Note that shared libraries do not have this problem as the shared
library loader will only look for symbols in the main executable for
symbols that are not defined in the library itself.


\subsection{Compatibility of the Foreign Interface}

The term-reference mechanism was first used by Quintus Prolog version 3.
SICStus Prolog version 3 is strongly based on the Quintus interface. The
described SWI-Prolog interface is similar to using the Quintus or
SICStus interfaces, defining all foreign-predicate arguments of type
{\tt +term}.  SWI-Prolog explicitely uses type {\tt functor_t}, while
Quintus and SICStus uses name + arity.  As the names of the functions
differ from Prolog to Prolog, a simple macro layer dealing with the
names can also deal with this detail.  For example:

\begin{code}
#define QP_put_functor(t, n, a)	PL_put_functor(t, PL_new_functor(n, a))
\end{code}

The \tty{PL_unify_*()} functions are lacking from the Quintus and
SICStus interface.  They can easily be emulated or the put/unify
approach should be used to write compatible code.

The PL_open_foreign_frame()/PL_close_foreign_frame() combination is
lacking from both other Prologs.  SICStus has PL_new_term_refs(0),
followed by PL_reset_term_refs() that allows for discarding
term references.

The Prolog interface for the graphical user interface package XPCE
shares about 90\% of the code using a simple macro layer to deal
with different naming and calling conventions of the interfaces.
