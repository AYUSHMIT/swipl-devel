\section{Using hyper links to relate objects}	\label{sec:hyper}

A \class{hyper} is a binary relation between two objects.  Hypers are,
like \class{connection} objects, guarded automatically against
destruction of one of the related objects.  Special methods allow for
easy communication between {\em hypered} objects.

Hypers form an adequate answer if objects need to be related that
depend temporary and incidentally on each other.  It is possible to
be informed of the destruction of hypers, which enables a hypered object
to keep track of its environment.  Good examples for the usage of hypers
are to express the relation between multiple {\em frame} objects working
together to form a single application or maintaining the relation
between an application object (persistent object, model) and its
visualisation (controller).

Hypers are an alternative for using slots.  Suppose we want to define an
application consisting of a main frame and a number of {\em slave}
frames to handle specific tasks in the application.  One approach would
be to relate a sheet for the slave frames with the master and a pointer
to the main window in each slave.  The skeleton for this is given below.%
    \footnote{This example was written before the introduction of
	      \class{application}.  The principal is still valid, but
	      this particular problem would now be solved using an
	      \class{application} object.}

\begin{pcecode}
:- pce_begin_class(main, frame, "Applications main window").

variable(slaves, sheet, get, "Name --> slave window relations").

initialise(F) :->
	send(F, send_super, initialise, 'Main Window'),
	send(F, slot, slaves, new(sheet)),
	...


unlink(F) :->
	"Destroy all slave windows"::
	get(F, slaves, Slaves),
	send(Slaves, for_all, message(@arg1?value, destroy)).


slave(F, Name:name, Create:[bool], S:slave) :<-
	"Return existing slave or create new one"::
	get(F, slaves, Slaves),
	(   get(Slaves, value, Name, S)
	->  true
	;   (	Create == @off
	    ->	fail
	    ;	new(S, slave(Name, F))
	    )
	).

register_slave(F, Name:name, Slave:slave) :->
	send(F?slaves, value, Name, Slave).

unregister_slave(F, Slave:slave) :->
	get(F, slaves, Slaves),
	(   get(Slaves?members, find, @arg1?value == Slave, Att)
	->  send(Slaves, delete, Att)
	;   true
	).

:- pce_end_class.

:- pce_begin_class(slave, frame, "Applications slave frame").

variable(main,	main,	get,	"Reference to main frame").

initialise(S, Name:name, Main:main) :->
	"Create and register with main"::
	send(S, send_super, initialise, Name),
	send(S, slot, main, Main),
	send(Main, register_slave, Name, S),
	...

unlink(S) :->
	get(S, main, Main),
	send(Main, unregister_slave, Main).

:- pce_end_class.
\end{pcecode}

A similar schema to this is used by the \product{} manual tools
described in \secref{online}. Using hypers, the same relation can be
expressed much simpler and less error-prone.

\subsection{Programming existence dependencies}

The example of this section demonstrates a common existence
relationship. If the `main' object is destroyed, all related slave
objects should be destroyed too, but if a slave is destroyed, the main
should not be destroyed. This semantic is expressed using a refinement
of class \class{hyper}.

\begin{pcecode}
:- pce_begin_class(master_slave_hyper, hyper,
		   "Maintain a master-slave relationship").

initialise(H, F:object, T:object, FN:[name], TN:[name]) :->
	default(FN, slave, FromName),
	default(TN, master, ToName),
	send(H, send_super, initialise, F, T, FromName, ToName).

unlink_from(H) :->
	"From-side (master is destroyed)"::
	get(H, to, To),
	free(To),
	free(H).

:- pce_end_class.
\end{pcecode}

This hyper is demonstrated in the following application.  It defines a
frame holding a graphical window and a dialog with a {\sf Quit} button and
also a dialog frame for modifying the label of the first frame.  See
\figref{hyperdemo}.  If the main window is destroyed, the
label-editor will be destroyed automatically.

\postscriptfig[width=\textwidth]{hyperdemo}{Two frames related by a hyper-link}

\begin{pcecode}
hyperdemo :-
	new(F, frame('Main Window')),
	send(F, append, new(P, picture)),
	send(new(D, dialog), below, P),
	send(D, append, button(quit, message(F, destroy))),
	send(F, open),

	new(E, dialog('Edit label')),
	send(E, append, text_item(label, F?label,
				  message(F, label, @arg1))),
	send(E, append, button(cancel, message(E, destroy))),
	new(_, master_slave_hyper(F, E)),
	send(E, open).
\end{pcecode}

Using the \class{master_slave_hyper}, the frame-demo from above can be
rewritten using the code below:

\begin{code}
:- pce_begin_class(main, frame, "Applications main window").

slave(F, Name:name, Create:[bool], Slave:slave) :<-
	"Return existing slave or create new one"::
	(   get(F, hypered, slave, @arg3?name == Name, Slave)
	->  true
	;   (	Create == @off
	    ->	fail
	    ;	new(Slave, slave(Name, F))
	    )
	).

:- pce_end_class.

:- pce_begin_class(slave, frame, "Applications slave frame").

variable(name, name, get, "Slave name of this frame").

initialise(S, Name:name, M:main) :->
	"Create and register with main"::
	send(S, send_super, initialise, 'Slave frame'),
	send(S, slot, name, Name),
	new(_, master_slave_hyper(M, S)),
	...

:- pce_end_class.
\end{code}


\subsection{Methods for handling hyper objects}

\subsubsection{Methods on class hyper}

\begin{description}
    \sendmethod{hyper}{initialise}{F:object, T:object,
				   FName:name, TName:[name]}
Create a new hyper object.  Seen from {\em F}, this hyper is
called {\em FName}; seen from {\em T} it is called {\em TName}.
The default for {\em TName} is {\em FName}.
    \sendmethod{hyper}{unlink_from}{}
Called by the object-management system when the <-from side of the hyper
is being destroyed.  May be refined.
    \sendmethod{hyper}{unlink_to}{}
Called by the object-management system when the <-to side of the hyper
is being destroyed.  May be refined.
\end{description}


\subsubsection{Methods on class object}

Below are the two most commonly used methods dealing with hypers and
defined on class \class{object}.  \product{} defines various other methods
for deleting and inspecting the hyper structure.  Use the online manual
for details.

\begin{description}
    \sendmethod{object}{send_hyper}{Name:[name], Selector:name,
				    Arg:unchecked ...}
Broadcast a send-operation to all (named) <-hypered objects.
Similar to <-get_hyper, but does not stop if the method is received
successfully. Succeeds if  at least one hypered object accepted the message.
    \getmethod{object}{hypered}{Name:[name], Test:[code]}{object}
Find a hyper-related object. Name is the name of the hyper (seen from
the side of the receiver). Test is an optional additional test. If
present, this test is executed using the arguments given below.
The first matching object is returned.  See also <-all_hypers.
	
\begin{center}
\begin{tabular}{ll}
@arg1	& This object \\
@arg2	& The hyper object \\
@arg3	& The object at the other end of the hyper \\
\end{tabular}
\end{center}
\end{description}
