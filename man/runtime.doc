\chapter{Deploying applications}	\label{sec:runtime}

This chapter describes the features of SWI-Prolog for delivering
applications using \jargon{saved states}.

\section{Deployment options}
\label{sec:deployment-options}

There are several ways to make a Prolog application available to your
users. By far the easiest way is to require the user to install
SWI-Prolog and deliver the application as a directory holding source
files, other resources the application may need and a \jargon{Prolog
Script} file that provides the executable. See \secref{plscript}. The
two-step installation may be slightly less convenient for the end user,
but enables the end-user to conveneintly run your program on a different
operating system or architecture. This mechanism is obviously not
suitable if you want to keep the source of your program secret.

Another solution is to use \jargon{saved states}, the main topic of this
chapter, together with the installed development system and disable
\jargon{autoloading} requirements into the state using
\cmdlineoption{--autoload=false} or the \term{autoload}{false} option of
qsave_program/2. This allows creating the application as a single file,
while avoiding most of the complications associated with saved states.
This mechanism is particuarly suitable for in-house and cloud
deployment. It provides some protection against inspecting the source as
layout, variable names and comments are not available from the state.
Prolog code without meaningful variable names and comments is generally
hard to follow.

The final solution is to make sure all required resources are present in
the saved state. In this case the state may be added to the
\jargon{emulator} and the application consists of the emulator with
state and the shared objects/DLLs required to make the emulator work. If
the emulator can be statically linked for the target platform this
creates a truely single file executable.

\section{Understanding saved states}
\label{sec:saved-states}

A SWI-Prolog \jargon{saved state} is the \jargon{resource archive}, that
contains the compiled program in a machine-independent format, startup
options optionally shared objects/DLLs and possibly user-defined
\jargon{resources}. As of version 7.7.3, the resource archive format is
ZIP. A resource file is normally \textbf{created} using the commandline
option \cmdlineoption{-c}:

\begin{code}
swipl -o mystate option ... -c file.pl ...
\end{code}

The above causes SWI-Prolog to load the given Prolog files and call
qsave_program/2 using options created from the \textit{option \ldots} in
the command above.

A saved state may be \textbf{executed} in several ways. The basic
mechanism is to use the \cmdlineoption{-x}:

\begin{code}
swipl -x mystate app-arg ...
\end{code}

Saved states may have an arbitrary payload at the \emph{start}. This
allows combining a (shell) script or the emulator with the state to turn
the state into a single file executable. By default a state starts with
a shell script (Unix) or the emulator (Windows)\footnote{As the default
emulator is a short program while the true emulator is in a DLL this
keeps the state short.}. The options \term{emulator}{File} and
\term{stand_alone}{Bool} control what is added at the start of the
state.

\subsection{Creating a saved state}
\label{sec:create-saved-state}

The predicates in this section support creating a saved state. Note that
states are commonly created from the commandline using the
\cmdlineoption{-c}, for example:

\begin{code}
swipl -o mystate --foreign=save -c load.pl
\end{code}

\begin{description}
    \predicate{qsave_program}{2}{+File, +Options}
Saves the current state of the program to the file \arg{File}.  The
result is a resource archive containing a saved state that expresses
all Prolog data from the running program and all user-defined resources.
Depending on the \const{stand_alone} option, the resource is headed by
the emulator, a Unix shell script or nothing.  \arg{Options} is a list
of additional options:

    \begin{description}
	\termitem{local}{+KBytes}
Limit for the local stack.  See \secref{stacksizes}.
	\termitem{global}{+KBytes}
Limit for the global stack.  See \secref{stacksizes}.
	\termitem{trail}{+KBytes}
Limit for the trail stack.  See \secref{stacksizes}.
	\termitem{goal}{:Callable}
Initialization goal for the new executable (see \cmdlineoption{-g}).
	\termitem{toplevel}{:Callable}
Top-level goal for the new executable (see \cmdlineoption{-t}).
	\termitem{init_file}{+Atom}
Default initialization file for the new executable. See
\cmdlineoption{-f}.
	\termitem{class}{+Class}
If \const{runtime}, only read resources from the state (default). If
\const{kernel}, lock all predicates as system predicates. If
\const{development}, save the predicates in their current state and keep
reading resources from their source (if present). See also resource/3.
	\termitem{autoload}{+Boolean}
If \const{true} (default), run autoload/0 first.
	\termitem{map}{+File}
Dump a human-readable trace of what has been saved in \arg{File}.
	\termitem{op}{+Action}
One of \const{save} (default) to save the current operator table
or \const{standard} to use the initial table of the emulator.
	\termitem{stand_alone}{+Boolean}
If \const{true}, the emulator is the first part of the state. If the
emulator is started it will test whether a boot file (state) is attached
to the emulator itself and load this state. Provided the application has
all libraries loaded, the resulting executable is completely independent
of the runtime environment or location where it was built. See also
\secref{cmdlinecomp}.
	\termitem{emulator}{+File}
File to use for the emulator.  Default is the running Prolog image.
	\termitem{foreign}{+Action}
If \const{save}, include shared objects (DLLs) into the saved state. See
current_foreign_library/2. If the program \program{strip} is available,
this is first used to reduce the size of the shared object. If a state
is started, use_foreign_library/1 first tries to locate the foreign
resource in the executable. When found it copies the content of the
resource to a temporary file and loads it.  If possible (Unix), the
temporary object is deleted immediately after opening.\footnote{This
option is experimental and currently disabled by default.  It will
become the default if it proves robust.}
    \end{description}

    \predicate{qsave_program}{1}{+File}
Equivalent to \exam{qsave_program(File, [])}.

    \predicate{autoload}{0}{}
Check the current Prolog program for predicates that are referred to,
are undefined and have a definition in the Prolog library.  Load the
appropriate libraries.

This predicate is used by qsave_program/[1,2] to ensure the saved state
does not depend on availability of the libraries. The predicate
autoload/0 examines all clauses of the loaded program (obtained with
clause/2) and analyzes the body for referenced goals. Such an analysis
cannot be complete in Prolog, which allows for the creation of arbitrary terms at
runtime and the use of them as a goal. The current analysis is limited to the
following:

    \begin{itemize}
        \item Direct goals appearing in the body
	\item Arguments of declared meta-predicates that are marked
	      with an integer (0..9).  See meta_predicate/1.
    \end{itemize}

The analysis of meta-predicate arguments is limited to cases where the
argument appears literally in the clause or is assigned using =/2 before
the meta-call.  That is, the following fragment is processed correctly:

\begin{code}
	...,
	Goal = prove(Theory),
	forall(current_theory(Theory),
	       Goal)),
\end{code}

But, the calls to \nopredref{prove_simple}{1} and
\nopredref{prove_complex}{1} in the example below are \emph{not}
discovered by the analysis and therefore the modules that define these
predicates must be loaded explicitly using use_module/1,2.

\begin{code}
	...,
	member(Goal, [ prove_simple(Theory),
		       prove_complex(Theory)
		     ]),
	forall(current_theory(Theory),
	       Goal)),
\end{code}

It is good practice to use gxref/0 to make sure that the program has
sufficient declarations such that the analaysis tools can verify that
all required predicates can be resolved and that all code is called.
See meta_predicate/1, dynamic/1, public/1 and prolog:called_by/2.

    \prefixop{volatile}{+Name/Arity, \ldots}
Declare that the clauses of specified predicates should \strong{not} be
saved to the program.  The volatile declaration is normally used to
prevent the clauses of dynamic predicates that represent data for
the current session from being saved in the state file.
\end{description}


\section{Limitations of qsave_program}
\label{sec:qsavelimits}

There are three areas that require special attention when using
qsave_program/[1,2].

\begin{itemize}
    \item
If the program is an embedded Prolog application or uses the foreign
language interface, care has to be taken to restore the appropriate
foreign context. See \secref{qforeign} for details.

    \item
If the program uses directives (\exam{:- goal.} lines) that perform
other actions than setting predicate attributes (dynamic/1, volatile/1,
etc.) or loading files (use_module/1, etc.). Goals that need to be
executed when the state is started must use initialization/1 (ISO
standard) or initialization/2 (SWI extension that provides more control
over when the goal is executed). For example, initialization/2 can be
used to start the application:

\begin{code}
:- initialization(go, main).
\end{code}

    \item
Database references as returned by clause/3, recorded/3, etc., are not
preserved and may thus not be part of the database when saved. Attempts
to do so result in a warning.
\end{itemize}


\section{Runtimes and Foreign Code}	\label{sec:qsaveforeign}
\label{sec:qforeign}

Many applications use packages that include foreign language components
compiled to shared objects or DLLs. This code is normally loaded using
use_foreign_library/1 and the \const{foreign} file search path.  Below
is an example from the \file{socket} library.

\begin{code}
:- use_foreign_library(foreign(socket)).
\end{code}

There are two options to handle shared objects in runtime applications.
The first is to use the \term{foreign}{save} option of qsave_program/2
or the \cmdlineoption{--foreign=save} commandline option. This causes
the dependent shared objects to be included into the resource archive.
The use_foreign_library/1 directive first attempts to find the foreign
file in the resource archive. Alternatively, the shared objects may be
placed in a directory that is distributed with the application. In this
cases the file search path \const{foreign} must be setup to point at
this directory. For example, we can place the shared objects in the same
directory as the executable using the definition below. This may be
refined further by adding subdirectories depending on the architecture
as available from the Prolog flag \prologflag{arch}.

\begin{code}
:- multifile user:file_search_path/2.

user:file_search_path(foreign, Dir) :-
    current_prolog_flag(executable, Exe),
    file_directory_name(Exe, Dir).
\end{code}


\section{Using program resources}	\label{sec:useresource}

A \jargon{resource} is very similar to a file.  Resources, however, can
be represented in two different formats: on files, as well as part of
the resource \jargon{archive} of a saved state (see qsave_program/2).

A resource has a \jargon{name}. The \jargon{source} data of the resource
is a file. Resources are declared by adding clauses to the predicate
resource/3. They are accessed using the predicate open_resource/2 and
open_resource/3.

Before going into details, let us start with an example.  Short texts
can easily be expressed in Prolog source code, but long texts are
cumbersome.  Assume our application defines a command `help' that
prints a helptext to the screen.  We put the content of the helptext
into a file called \file{help.txt}.  The following code implements
our help command such that \file{help.txt} is incorporated into the
runtime executable.

\begin{code}
resource(help, text, 'help.txt').

help :-
    setup_call_cleanup(
	open_resource(help, text, In),
	copy_stream_data(In, user_output),
	close(In)).
\end{code}

The predicate help/0 opens the resource as a Prolog stream. If we are
executing this from the development environment, this returns a stream
to the file \file{help.txt} itself. When executed from the saved state,
the stream is a stream opened on the program resource archive.

\subsection{Resource manipulation predicates}
\label{sec:runtime-predicates}

\begin{description}
    \predicate{resource}{2}{:Name, +FileSpec}
This predicate is defined as a dynamic predicate in the module
\const{user}. Clauses for it may be defined in any module, including the
user module. \arg{Name} is the name of the resource (an atom). A
resource name may contain any character, except for \$ and :, which are
reserved for internal usage by the resource library. \arg{FileSpec} is a
file specification that may exploit file_search_path/2 (see
absolute_file_name/2).

Often, resources are defined as unit clauses (facts), but the
definition of this predicate also allows for rules. For proper
generation of the saved state, it must be possible to enumerate the
available resources by calling this predicate with all its arguments
unbound.

Dynamic rules can be used to turn all files in a certain directory
into resources, without specifying a resource for each file.  For
example, assume the file_search_path/2 \const{icons} refers to the
resource directory containing icon files.  The following definition
makes all these images available as resources:

\begin{code}
resource(Name, icons(XpmName)) :-
	atom(Name), !,
	file_name_extension(Name, xpm, XpmName).
resource(Name, XpmFile) :-
	var(Name),
	absolute_file_name(icons(.), [type(directory)], Dir)
	concat(Dir, '/*.xpm', Pattern),
	expand_file_name(Pattern, XpmFiles),
	member(XpmFile, XpmFiles).
\end{code}

    \predicate{open_resource}{2}{+Name, -Stream}
\nodescription
    \predicate{open_resource}{3}{+Name, -Stream, +Options}
Opens the resource specified by \arg{Name}. If successful, \arg{Stream}
is unified with an input stream that provides access to the resource.
The stream can be tuned using the \arg{Options}, which is a subset of
the options provided by open/4.

    \begin{description}
    \termitem{type}{Type}
    \nodescription
    \termitem{encoding}{Encoding}
    \nodescription
    \termitem{bom}{Bool}
Options that determine the binary/text type, encoding for text streams
and whether or not the content should be checked for a BOM marker.  The
options have the same meaning as the corresponding options for open/4.
    \end{description}

The predicate open_resource/3 first checks resource/2.  When successful
it will open the returned resource source file.  Otherwise it will look
in the program's resource database.  When creating a saved state, the
system normally saves the resource contents into the resource archive,
but does not save the resource clauses.

This way, the development environment uses the files (and modifications)
to the resource/3 declarations and/or files containing resource info,
thus immediately affecting the running environment, while the runtime
system quickly accesses the system resources.
\end{description}


\subsection{Managing resource files}
\label{sec:swiplrc}

As of version 7.7.13, SWI-Prolog resource files are zip(1) files. Prolog
creates and accesses its resource files using the \HREF{minizip}{}
project. The resource files may be examined and modified using any tool
that can process zip files.

\section{Finding Application files}	\label{sec:findappfile}

If your application uses files that are not part of the saved program
such as database files, configuration files, etc., the runtime version
has to be able to locate these files. The file_search_path/2 mechanism
in combination with the \cmdlineoption{-p}{alias} command line argument
provides a flexible mechanism for locating runtime files.

\subsection{Specifying a file search path from the command line}
\label{sec:runtime-file-search-path}

Suppose the system administrator has installed the SWI-Prolog runtime
environment in \file{/usr/local/lib/rt-pl-3.2.0}. A user wants to
install \file{gnat}, but \file{gnat} will look for its configuration in
\file{/usr/local/lib/rt-pl-3.2.0/gnat} where the user cannot write.

The user decides to install the \file{gnat} runtime files in
\file{/users/bob/lib/gnat}.  For one-time usage, the user may decide
to start \file{gnat} using the command:

\begin{code}
% gnat -p gnatdir=/users/bob/lib/gnat
\end{code}

% do not remove
