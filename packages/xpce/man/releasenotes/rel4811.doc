\documentstyle[local,twoside,pce,psfig,logo,11pt]{article}

%\psdraft

%\makeindex

%\includeonly{intro}

\begin{document}

\begin{titlepage}
\titlepageheader

\vfil\vfil\vfil
\begin{center}
	{\Huge \bf XPCE/Prolog\\Release notes version 4.8.11}	\\[1.5cm]
	{\large \it Jan Wielemaker}			\\
	{\large jan@swi.psy.uva.nl}
\end{center}
\vfil
\begin{quote}
This document describes the most important changes to release 4.8.11 of
XPCE.
\end{quote}
\vfil
\vfil
\begin{quote}
Copyright \copyright\ 1995 University of Amsterdam
\end{quote}
\end{titlepage}

\begin{titlepage}
\noindent
Release notes for XPCE 4.8.11 or ProWindows 3 version 1.3.
\vfil

\noindent
Typeset using LaTeX.  LaTeX files created using perl preprocessors from
a LaTeX extended notation for PCE documentation and raw XPCE/Prolog
code.  Diagrams are psfig.sty included PostScript generated by PceDraw,
the XPCE/Prolog drawing tool.
\vfil

\noindent
An electronic version of this manual is available using anonymous ftp
to swi.psy.uva.nl (145.18.124.17), directory /pub/xpce/doc/releasenotes
\vfil
\noindent
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
\end{titlepage}

{\parskip 0pt
\tableofcontents
}

\section{Introduction}

These release-notes provide programmers information to XPCE and
ProWindows programmers for XPCE release 4.8.11, Prowindows 3 version
1.3.  Distributions of the academic XPCE version is irregular and
mostly demand-driven.  Therefore this document takes Prowindows 2
version 1.2 (XPCE 4.8.1) as its basis.

The 4.8.11 release provides better colour handling, including reading
and writing coloured images, graceful handling of colour when the
server is out of colours and generation of coloured PostScript.  It
also provides a completely rewritten class-compiler aiming at better
runtime and loading performance as well as a reduced claim on memory
and the symbol tables of both the host-language as XPCE itself.

The XPCE/Prolog interface and the message-passing engine have been
optimised.

This release fixes a lot of bugs as well as some obviously lacking
behaviour reported from users.

Luca Passani (E-mail: passani@idt.unit.no) has started the maintenance
of a programmers FAQ for XPCE. This FAQ is available on the internet
using the following URL:

\begin{code}
http://www.stud.unit.no:80/~passani/FAQ.html
\end{code}

The file <xpce-home>/ChangeLog contains a full description of the
changes.  You can read this file using the `File/ChangeLog' menu-entry
of the online manual tools.  Many of the notes will be hard to read if
you are not involved in the development of XPCE.  Don't be alarmed by
the huge number of items tagged `FIXED:', most of them refer to bugs
resulting from changes and never reached public releases.


\section{Summary of Changes}

This section contains a summary of important additions or modifications
of behaviour.

\subsection{New features}

\begin{itemize}
    \tick{`key_binding->typed' split}
This method has been split into various parts to allow for complicated
reprogramming of keyboard-handling in XPCE.  These new features are 
exploited by PceEmacs to add `M-x command' history.
    \tick{Class template library available for public usage}
Programming using template classes was already used for the realisation
of the Dialog Editor.  This feature has now been made public using the
library(pce_template).
    \tick{Better checking for some common errors}
The predicates new/2 and friends warn if the first argument is not
unbound, for the form @<atom> or @<unbound>.  This traps the common
programmer errors where a bound variable (bound earlier in the clause)
is used and unification causes new/2 to fail silently.  The class
compiler warns on clauses inside a class definition that look
very much like a method definition, but use the \verb$:-$ operator.
    \tick{Popups use `stay-up' interface style}
Activating a popup with a `click' (up short after down and not too
much movement) will open the popup window and wait for the user to
select an entry.
    \tick{Online manual improvements}
Display of inheritance and delegation hierarchy in the ClassBrowser
and many other improvements.
    \tick{Support for `hidden' text in Editors}
Class style now supports ->hidden, resulting in (temporary) invisible
text in editors.
    \tick{PostScript improvements}
Postscript may now be generated for all graphical objects.  Objects
that cannot produce `real PostScript' produce an image representation.
PostScript generation now includes colour.
    \tick{Colour pixmap support}
Based on the public `PNM' package, providing read and write of
full-colour images.
\end{itemize}

\subsection{Bugs fixed}

Many small and annoying bugs have been fixed.  The list is too long for
literal inclusion in this document.  If you encountered any bugs and
wonder whether they have been fixed, please scan the ChangeLog file
or test the code on the new version.  Note that some bugs may be fixed
as a side-effect from fixing low-level problems.

\begin{itemize}
    \tick{Incremental garbage collector}
The 4.8.1 implementation missed an important category of garbage.
    \tick{Editor/TextBuffer}
Various problems handling 16-bit characters and a memory management
problem in <-contents.
    \tick{Visual Hierarchy Tool destruction}
\end{itemize}


\subsection{Incompatible changes}

Anything incompatibility in 4.8.11 with regard to 4.8.1 that is not
mentioned below should be treated as a bug.

\begin{itemize}
    \tick{Class \class{regex}}
Upgraded to version 0.12 of the GNU regex library.  The only
incompatibility notes is handling of expressions
\begin{code}
prefix\(repeat\)+postfix
\end{code}
This used to return as register 1 the entire span from the first to the
last matched `repeat'.  Now only returns the last.  Please use
\verb$prefix\(\(repeat\)+\)postfix$ to get the desired behaviour.
    \tick{Text objects now have ZERO WIDTH if they contain no text}
Non-zero width was used in old versions to ensure the caret was inside
the redraw-area.  All versions 4.8.x adopt a different changes schema
that takes care of the caret without extending the area.  The current
approach generally improves alignment and allows for texts to be
displayed immediately adjecent.
    \tick{Class compiler}
See section~\ref{sec:classcompiler} for details.
\end{itemize}


\section{The new class compiler} \label{sec:classcompiler}

The Prolog front-end for creating user-defined classes has been changed
in various ways.  These changes are intended to improve runtime
performance as well as for reducing loading time and memory
requirements.  The new class compiler has been designed to be as closely
as possible compatible to the old one.

`Ordinary' classes will in general not require any modification to work
with the new compiler.  Directives that modify the class-structure under
construction may need to be changed and application-wrappers around the
pce_begin_class/[2,3] and pce_end_class/0 should always be changed.  We
beleive few people will have to make modifications to their source-code
and the performance improvements outweight this disadvantage.


\subsection{Fast method calling}

The old class-compiler created methods of the form shown below.

\begin{code}
send_method(<Selector>, <Types>,
	    message(@prolog, call,
		    '<module>:<pred>', @arg1, @arg2, ...)).
\end{code}

This mechanism is expensive because the interface has to analyse
the \verb$<module>:<pred>$ atom, and combine it with the arity to
obtain a reference to the Prolog predicate implementing this method.

The message objects used in methods are always of the same form and
contain mostly redundant information.

The new compiler creates method objects of the form:

\begin{code}
send_method(<Selector>, <Types>,
	    c_pointer(<reference to predicate>)).
\end{code}

If a method is executed with a c_pointer object as its message, XPCE
will call the CallHostProc() interface hook with predefined arguments.
This hook may be used to realise an efficient call to the implementation
of the method.


\subsection{Fast loading}

Another problem associated with the old interface was that loading
precompiled Prolog did not show a significant performance improvement
over loading plain Prolog source.  This was caused by costly
directives and large number of predicates created by the old class
compiler.

The new class compiler does not immediately build the class.  Instead it
creates a number of clauses that provide the implementation of the
predicates and describe the class.  Finally it will create the directive
pce_register_class/1.  This predicate checks whether the class already
exists.  If this is the case, pce_register_class/1 will modify the existing
class.  Otherwise it will create a declation for exception based loading
of the class, much like pce_autoload/2 does.

This implies that loading a Prolog sourcefile containing class-definitions
does not cause these classes to be defined.  Actual definition will happen
only after the class is referenced from XPCE.


\subsubsection{Lazy binding of methods}

A further reduction of loading time and memory usage has been realised
by implementing a hook into the XPCE method-resolver (see
`class->resolve_method_message').  This hook will be called whenever the
XPCE method resolver has determined the method is defined at the
class-level and there is no entry in the cache.

Using this mechanism, the undefined_class exception just has to create
the class and define its instance variables.  Binding of the methods
will happen on exception basis.

If a class is reloaded, the system will invoke `class ->clear_cache'
to ensure methods will be rebound using the new definitions when called.


\subsection{Directives in class-definitions}

As classes are no longer translated in sequences of directives, but to
clauses that are used by an exception handler to build the class when
refferred to, directives that refer to the class under construction
cannot be used without special precautions.  Instead, such directives
must be registered with the class compiler.  The exception handler will
call these directives after the class has been created and all variables
and resources are attached to the class.

In general, class directives must be wrapped in pce_class_directive/1:

\begin{description}
\directive{pce_class_directive}{1}{Goal}
    The class compiler will add {\em Goal} to the list of goals to be
    run after the class has been created and the variables and resources
    have been attached to the class.  The exception handlers for the
    methods are present, which implies the directive may use methods
    of the class.  The XPCE variable @class refers to the class under
    construction.
\end{description}

Some directives are known to the class-compiler and will automatically
be wrapped with the pce_class_directive/1 term:

\begin{description}
\directive{send}{2-12}{@class, ...}
    Any method directed to @class will automatically be added to the
    class directives.
\directive{use_class_template}{1}{Template}
    This directive is defined by library(pce_template).  See also
    section~\ref{sec:template}
\end{description}


\subsection{Wrappers around pce_begin_class/[2,3] ... pce_end_class/0}

Sometimes, applications wish to define a wrapper around XPCE's class
definition system.  Examples from the XPCE library are
emacs_begin_mode/5 ...  emacs_end_mode/0 and draw_begin_shape/3 ...
draw_end_shape/0.  These wrappers encapsulate details of the definition
of PceEmacs modes and PceDraw shapes.

In the old version, emacs_begin_mode/5 was a predicate calling
pce_begin_class/3.  The new compiler is exclusively defined using
term_expansion/2.  The new compiler defines a hook for user-defined
expansion:

\begin{description}
\predicate{user:pce_pre_expansion_hook}{2}{+TermIn, -Expanded}
    Called by the class-compiler as its first step.  If this predicate
    fails, {\em TermIn} is processed by the class compiler.  Otherwise
    {\em Expanded} is processed.  {\em Expanded} may be a list, in which
    case each element of the list is further processed by the class
    compiler.
\end{description}


\subsection{Meta-class extension to pce_begin_class/[2,3]}

Some application choose to extend class \class{class} and make the
application classes instances of this class.  Class \class{class}
serves as a meta-class and this technique may be used to modify
and/or extend XPCE's notion of meta-classes.  To simplify this
type of definition, the syntax for pce_begin_class/[2,3] has been
extended:

\begin{description}
\directive{pce_begin_class}{3}{[<Meta-class>:]<Class>[(<Term-arg>, ...)], Super, Summary}
    Start the definition of a subclass of class {\em Super} named {\em
    Class} that is an instance of class {\em Meta-class}.  If {\em
    Meta-class} is omitted, {\em Class} will be an instance of the same
    class as {\em Super}.  All built-in classes of XPCE are instances of
    class \class{class}.

    The optional {\em Term-arg} arguments are atoms defining the
    0-argument get-method used to fetch the corresponding argument of
    the term-description as returned by object/2 and get_object/[3-13].
\end{description}


\section{Class templates}		\label{sec:template}

The library(pce_template) provides a simple mechanism to attach the same
behaviour to various classes at different parts of the XPCE class
hierarchy.  Suppose your application is built on top of a library that
requires graphical objects to respond to some predefined methods.  One
could implement this by making subclasses of all the graphical classes
of XPCE one wishes to use, basically writing the same code many times.
This is clearly inappropriate.  An alternative is to attach the methods
to class \class{graphical}.  This is better regarding maintenance, but
potentionally leads to conflicts with other libraries loaded in the
same XPCE instance. The library(pce_template) provides a better
solution.

A class template is a normal XPCE class that is a (indirect) subclass of
class \class{template} defined by the library. The directive
use_class_template/1 may be used in the context of class definition to
import all variables and methods defined on the template into the
current class. It will behave as if the source of the methods is copied
into the current class.	 The implementing predicate will be shared by
all users of the template.

In the following example we want to establish a relation between a
graphical object and its `model' (related `database' object) using
a hyper.

\begin{code}
:- use_module(library(pce_template)).

:- pce_begin_class(visualiser, template).

model(V, M:object*) :->
	"Relate the visualiser to its model"::
	(   get(V, find_hyper, model, H)
	->  send(H, free)
	;   true
	),
	(   M \== @nil
	->  new(_, hyper(M, V, visualiser, model))
	;   true
	).


model(V, M:object) :<-
	"Get related model object"::
	get(V, hypered, model, M).


m_send(V, Selector:name, Args:unchecked ...) :->
	"Send a message to my related model"::
	(   get(V, model, M)
	->  send(M, send_vector, Selector, Args)
	;   send(V, report, warning, '%N: No related model', V)
	).

:- pce_end_class.
\end{code}

The following example uses this template to define a text-object
that satisfies this infra-structure:

\begin{code}
:- use_module(library(pce_template)).

:- pce_begin_class(vis_text, text).
:- use_class_template(visualiser).

:- pce_end_class.
\end{code}

The following queries demontrate the result:

\begin{code}
?- new(@t, vis_text(hello)).
?- send(@t, model, @prolog).
?- send(@t, m_send, write, hello).
hello
\end{code}

%\bibliographystyle{name}
%\bibliography{pce}

%\printindex

\end{document}
