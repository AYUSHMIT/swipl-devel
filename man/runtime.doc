\chapter{Deploying applications}	\label{sec:runtime}

This chapter describes the features of SWI-Prolog for delivering
applications using \jargon{saved states}.

\section{Deployment options}
\label{sec:deployment-options}

There are several ways to make a Prolog application available to your
users. By far the easiest way is to require the user to install
SWI-Prolog and deliver the application as a directory holding source
files, other resources the application may need and a \jargon{Prolog
Script} file that provides the executable. See \secref{plscript}. The
two-step installation may be slightly less convenient for the end user,
but enables the end-user to conveneintly run your program on a different
operating system or architecture. This mechanism is obviously not
suitable if you want to keep the source of your program secret.

Another solution is to use \jargon{saved states}, the main topic of this
chapter, together with the installed development system and disable
\jargon{autoloading} requirements into the state using
\cmdlineoption{--autoload=false} or the \term{autoload}{false} option of
qsave_program/2. This allows creating the application as a single file,
while avoiding most of the complications associated with saved states.
This mechanism is particuarly suitable for in-house and cloud
deployment. It provides some protection against inspecting the source.
See \secref{protect-code} for details.

The final solution is to make sure all required resources are present in
the saved state. In this case the state may be added to the
\jargon{emulator} and the application consists of the emulator with
state and the shared objects/DLLs required to make the emulator work. If
the emulator can be statically linked for the target platform this
creates a truely single file executable.

\section{Understanding saved states}
\label{sec:saved-states}

A SWI-Prolog \jargon{saved state} is a \jargon{resource archive} that
contains the compiled program in a machine-independent
format,\footnote{Although the compiled code is independent from the CPU
and operating system, 32-bit compiled code does not run on the 64-bit
emulator, nor the other way around. Conditionally compiled code (see
if/1) may also reduce platform independence.} startup options optionally
shared objects/DLLs and possibly user-defined \jargon{resources}. As of
version 7.7.3, the resource archive format is ZIP. A resource file is
normally \textbf{created} using the commandline option
\cmdlineoption{-c}:

\begin{code}
swipl -o mystate option ... -c file.pl ...
\end{code}

The above causes SWI-Prolog to load the given Prolog files and call
qsave_program/2 using options created from the \textit{option \ldots} in
the command above.

A saved state may be \textbf{executed} in several ways. The basic
mechanism is to use the \cmdlineoption{-x}:

\begin{code}
swipl -x mystate app-arg ...
\end{code}

Saved states may have an arbitrary payload at the \emph{start}. This
allows combining a (shell) script or the emulator with the state to turn
the state into a single file executable. By default a state starts with
a shell script (Unix) or the emulator (Windows).\footnote{As the default
emulator is a short program while the true emulator is in a DLL this
keeps the state short.} The options \term{emulator}{File} and
\term{stand_alone}{Bool} control what is added at the start of the
state.

\subsection{Creating a saved state}
\label{sec:create-saved-state}

The predicates in this section support creating a saved state. Note that
states are commonly created from the commandline using the
\cmdlineoption{-c}, for example:

\begin{code}
swipl -o mystate --foreign=save -c load.pl
\end{code}

The description of qsave_program/2 provides background information and
the options available to control saved state creation.

\begin{description}
    \predicate{qsave_program}{2}{+File, +Options}
Saves the current state of the program to the file \arg{File}. The
result is a resource archive \arg{File} containing expresses all Prolog
data from the running program, all user-defined resources (see
resource/2 and open_resource/2) and optionally all shared objects/DLLs
required by the program for the current architecture. Depending on the
\const{stand_alone} option, the resource is headed by the emulator, a
Unix shell script or nothing. \arg{Options} is a list of additional
options:

    \begin{description}
	\termitem{local}{+KBytes}
Limit for the local stack.  See \secref{stacksizes}.
	\termitem{global}{+KBytes}
Limit for the global stack.  See \secref{stacksizes}.
	\termitem{trail}{+KBytes}
Limit for the trail stack.  See \secref{stacksizes}.
	\termitem{goal}{:Callable}
Initialization goal for the new executable (see \cmdlineoption{-g}).
	\termitem{toplevel}{:Callable}
Top-level goal for the new executable (see \cmdlineoption{-t}).
	\termitem{init_file}{+Atom}
Default initialization file for the new executable. See
\cmdlineoption{-f}.
	\termitem{class}{+Class}
If \const{runtime} (default), only read resources from the state.  If
\const{development}, save the predicates in their current state and keep
reading resources from their source (if present). See also resource/2.
	\termitem{autoload}{+Boolean}
If \const{true} (default), run autoload/0 first.
	\termitem{map}{+File}
Dump a human-readable trace of what has been saved in \arg{File}.
	\termitem{op}{+Action}
One of \const{save} (default) to save the current operator table
or \const{standard} to use the initial table of the emulator.
	\termitem{stand_alone}{+Boolean}
If \const{true}, the emulator is the first part of the state. If the
emulator is started it tests whether a saved state is attached
to itself and load this state. Provided the application has
all libraries loaded, the resulting executable is completely independent
from the runtime environment or location where it was built. See also
\secref{cmdlinecomp}.
	\termitem{emulator}{+File}
File to use for the emulator.  Default is the running Prolog image.
	\termitem{foreign}{+Action}
If \const{save}, include shared objects (DLLs) into the saved state. See
current_foreign_library/2. If the program \program{strip} is available,
this is first used to reduce the size of the shared object. If a state
is started, use_foreign_library/1 first tries to locate the foreign
resource in the executable. When found it copies the content of the
resource to a temporary file and loads it.  If possible (Unix), the
temporary object is deleted immediately after opening.\footnote{This
option is experimental and currently disabled by default.  It will
become the default if it proves robust.}
	\termitem{undefined}{+Value}
Defines what happens if an undefined predicate is found during the
code analysis.  Values are \const{ignore} (default) or \const{error}.
In the latter case creating the state is aborted with a message that
indicates the undefines predicates and from where they are called.
	\termitem{obfuscate}{+Boolean}
If \const{true} (default \const{false}), replace predicate names
with generated symbols to make the code harder to assess for
reverse engineering.  See \secref{obfuscate}.
	\termitem{verbose}{+Boolean}
If \const{true} (default \const{false}), report progress and status,
notably regarding auto loading.
    \end{description}

    \predicate{qsave_program}{1}{+File}
Equivalent to \exam{qsave_program(File, [])}.

    \predicate{autoload}{0}{}
Check the current Prolog program for predicates that are referred to,
are undefined and have a definition in the Prolog library.  Load the
appropriate libraries.

This predicate is used by qsave_program/[1,2] to ensure the saved state
does not depend on availability of the libraries. The predicate
autoload/0 examines all clauses of the loaded program (obtained with
clause/2) and analyzes the body for referenced goals. Such an analysis
cannot be complete in Prolog, which allows for the creation of arbitrary terms at
runtime and the use of them as a goal. The current analysis is limited to the
following:

    \begin{itemize}
        \item Direct goals appearing in the body
	\item Arguments of declared meta-predicates that are marked
	      with an integer (0..9).  See meta_predicate/1.
    \end{itemize}

The analysis of meta-predicate arguments is limited to cases where the
argument appears literally in the clause or is assigned using =/2 before
the meta-call.  That is, the following fragment is processed correctly:

\begin{code}
	...,
	Goal = prove(Theory),
	forall(current_theory(Theory),
	       Goal)),
\end{code}

But, the calls to \nopredref{prove_simple}{1} and
\nopredref{prove_complex}{1} in the example below are \emph{not}
discovered by the analysis and therefore the modules that define these
predicates must be loaded explicitly using use_module/1,2.

\begin{code}
	...,
	member(Goal, [ prove_simple(Theory),
		       prove_complex(Theory)
		     ]),
	forall(current_theory(Theory),
	       Goal)),
\end{code}

It is good practice to use gxref/0 to make sure that the program has
sufficient declarations such that the analaysis tools can verify that
all required predicates can be resolved and that all code is called.
See meta_predicate/1, dynamic/1, public/1 and prolog:called_by/2.

    \prefixop{volatile}{+Name/Arity, \ldots}
Declare that the clauses of specified predicates should \strong{not} be
saved to the program.  The volatile declaration is normally used to
prevent the clauses of dynamic predicates that represent data for
the current session from being saved in the state file.
\end{description}


\subsection{Limitations of qsave_program}
\label{sec:qsavelimits}

There are three areas that require special attention when using
qsave_program/[1,2].

\begin{itemize}
    \item
If the program is an embedded Prolog application or uses the foreign
language interface, care has to be taken to restore the appropriate
foreign context. See \secref{qforeign} for details.

    \item
If the program uses directives (\exam{:- goal.} lines) that perform
other actions than setting predicate attributes (dynamic/1, volatile/1,
etc.) or loading files (use_module/1, etc.). Goals that need to be
executed when the state is started must use initialization/1 (ISO
standard) or initialization/2 (SWI extension that provides more control
over when the goal is executed). For example, initialization/2 can be
used to start the application:

\begin{code}
:- initialization(go, main).
\end{code}

    \item
Database references as returned by clause/3, recorded/3, etc., are not
preserved and may thus not be part of the database when saved. Attempts
to do so result in a warning.
\end{itemize}


\subsection{Runtimes and Foreign Code}	\label{sec:qsaveforeign}
\label{sec:qforeign}

Many applications use packages that include foreign language components
compiled to shared objects or DLLs. This code is normally loaded using
use_foreign_library/1 and the \const{foreign} file search path.  Below
is an example from the \file{socket} library.

\begin{code}
:- use_foreign_library(foreign(socket)).
\end{code}

There are two options to handle shared objects in runtime applications.
The first is to use the \term{foreign}{save} option of qsave_program/2
or the \cmdlineoption{--foreign=save} commandline option. This causes
the dependent shared objects to be included into the resource archive.
The use_foreign_library/1 directive first attempts to find the foreign
file in the resource archive. Alternatively, the shared objects may be
placed in a directory that is distributed with the application. In this
cases the file search path \const{foreign} must be setup to point at
this directory. For example, we can place the shared objects in the same
directory as the executable using the definition below. This may be
refined further by adding subdirectories depending on the architecture
as available from the Prolog flag \prologflag{arch}.

\begin{code}
:- multifile user:file_search_path/2.

user:file_search_path(foreign, Dir) :-
    current_prolog_flag(executable, Exe),
    file_directory_name(Exe, Dir).
\end{code}


\section{Using program resources}	\label{sec:useresource}

A \jargon{resource} is very similar to a file.  Resources, however, can
be represented in two different formats: on files, as well as part of
the resource \jargon{archive} of a saved state (see qsave_program/2).

A resource has a \jargon{name}. The \jargon{source} data of the resource
is a file. Resources are declared by adding clauses to the predicate
resource/3. They are accessed using the predicate open_resource/2 and
open_resource/3.

Before going into details, let us start with an example.  Short texts
can easily be expressed in Prolog source code, but long texts are
cumbersome.  Assume our application defines a command `help' that
prints a helptext to the screen.  We put the content of the helptext
into a file called \file{help.txt}.  The following code implements
our help command such that \file{help.txt} is incorporated into the
runtime executable.

\begin{code}
resource(help, text, 'help.txt').

help :-
    setup_call_cleanup(
	open_resource(help, text, In),
	copy_stream_data(In, user_output),
	close(In)).
\end{code}

The predicate help/0 opens the resource as a Prolog stream. If we are
executing this from the development environment, this returns a stream
to the file \file{help.txt} itself. When executed from the saved state,
the stream is a stream opened on the program resource archive.

\subsection{Resource manipulation predicates}
\label{sec:runtime-predicates}

\begin{description}
    \predicate{resource}{2}{:Name, +FileSpec}
This predicate is defined as a dynamic predicate in the module
\const{user}. Clauses for it may be defined in any module, including the
user module. \arg{Name} is the name of the resource (an atom). A
resource name may contain any character, except for \$ and :, which are
reserved for internal usage by the resource library. \arg{FileSpec} is a
file specification that may exploit file_search_path/2 (see
absolute_file_name/2).

Often, resources are defined as unit clauses (facts), but the
definition of this predicate also allows for rules. For proper
generation of the saved state, it must be possible to enumerate the
available resources by calling this predicate with all its arguments
unbound.

Dynamic rules can be used to turn all files in a certain directory
into resources, without specifying a resource for each file.  For
example, assume the file_search_path/2 \const{icons} refers to the
resource directory containing icon files.  The following definition
makes all these images available as resources:

\begin{code}
resource(Name, icons(XpmName)) :-
	atom(Name), !,
	file_name_extension(Name, xpm, XpmName).
resource(Name, XpmFile) :-
	var(Name),
	absolute_file_name(icons(.), [type(directory)], Dir)
	concat(Dir, '/*.xpm', Pattern),
	expand_file_name(Pattern, XpmFiles),
	member(XpmFile, XpmFiles).
\end{code}

    \predicate{open_resource}{2}{+Name, -Stream}
\nodescription
    \predicate{open_resource}{3}{+Name, -Stream, +Options}
Opens the resource specified by \arg{Name}. If successful, \arg{Stream}
is unified with an input stream that provides access to the resource.
The stream can be tuned using the \arg{Options}, which is a subset of
the options provided by open/4.

    \begin{description}
    \termitem{type}{Type}
    \nodescription
    \termitem{encoding}{Encoding}
    \nodescription
    \termitem{bom}{Bool}
Options that determine the binary/text type, encoding for text streams
and whether or not the content should be checked for a BOM marker.  The
options have the same meaning as the corresponding options for open/4.
    \end{description}

The predicate open_resource/3 first checks resource/2.  When successful
it will open the returned resource source file.  Otherwise it will look
in the program's resource database.  When creating a saved state, the
system normally saves the resource contents into the resource archive,
but does not save the resource clauses.

This way, the development environment uses the files (and modifications)
to the resource/3 declarations and/or files containing resource info,
thus immediately affecting the running environment, while the runtime
system quickly accesses the system resources.
\end{description}

\subsection{Managing resource files}
\label{sec:swiplrc}

As of version 7.7.13, SWI-Prolog resource files are zip(1) files. Prolog
creates and accesses its resource files using the
\href{http://www.winimage.com/zLibDll/minizip.html}{minizip} project.
The resource files may be examined and modified using any tool that can
process zip files.

\section{Debugging and updating deployed systems}
\label{sec:debug-deployed-systems}

SWI-Prolog provides several facilities to debug and update running
(server) applications.  The core to these facilities are:

\begin{itemize}
    \item Hot-swap recompilation (\secref{loadrunningcode} and the library
\pllib{hotswap}) allow, with some limitation, making modifications to
running services. This includes adding debugging and logging statements.

    \item To make this useful some form of interaction is required. This
can be implemented using signal handlers (Unix), specific HTTP services,
generic HTTP services (e.g., \href{https://swish.swi-prolog.org}{SWISH})
or networked interaction using the library \pllib{prolog_server} that
allow interaction using netcat (\program{nc}) or \program{telnet}.
\end{itemize}


\section{Protecting your code}
\label{sec:protect-code}

Prolog in general, but SWI-Prolog in particular is an transparent
environment. Prolog's ``code is data'' point of view makes this natural
as it simplifies development and debugging.  Some users though want or
need to protect their code against copying or reverse engineering.

There are three ways to distribute code: as source, as \fileext{qlf}
file and in a saved state.  Both QLF files and saved states contain the
code as \jargon{virtual machine code}. QLF files capture the predicates
and directives, while saved state capture the current state of the
program. From the viewpoint of protecting code there is no significant
difference.

There are two aspects to protection. One is to make sure the attacker
has no access to the code in any format and the other is to provide
access to a non-human-readable version of the code. The second approach
is known as code obfuscation. Code obfuscation typically remove layout
and comments and rename all internal identifiers. If an attacker gets
access to the SWI-Prolog virtual machine code this can be
\jargon{decompiled}. The decompiled code does not include layout
information variable names and comments. Other identifiers, notably
predicate and module names are maintained. This provides some protection
against understanding the source as Prolog code without meaningful
variable names and comments is generally hard to follow.

For further protecting the code, there are several scenarios.

\begin{itemize}
    \item If the user has unrestricted access to the file system on
which the application is installed the user can always
access the state or QLF file. This data can be loaded into a
compatible emulator and be \jargon{decompiled}.

    \item If the user can run arbitrary Prolog code or shell commands
the state can be protected by embedding it as a string in the
executable deny read access to the executable.  This requires a
small C~program that includes the string and uses
PL_set_resource_db_mem() to register the string as the resource
database.  See PL_set_resource_db_mem() for details.  This protection
should be combined with the \prologflag{protect_static_code} described
below.

    \item Some extra protection can be provided using the Prolog
flag \prologflag{protect_static_code}, which disables decompilation of
\jargon{static} predicates. Note that most Prolog implementations cannot
decompile static code. Various SWI-Prolog tools depend on this
ability though. Examples are list_undefined/0, autoload/0,
show_coverage/1, etc.
\end{itemize}

\subsection{Obfuscating code in saved states}
\label{sec:obfuscate}

If the option \term{obfuscate}{true} is used with qsave_program/2,
certain atoms in the saved state are renamed. The renaming is performed
by library \pllib{obfuscate}. The current implementation is rather
conservative, renaming atoms that are used only to define the functor
that names a predicate. This is a safe operation, provided the
application does not create new references to renamed predicates by
reading additional source code or constructing the atom that names the
predicate dynamically in some other way such as using atom_concat/3.
Predicates that are called this way must be declared using public/1.

Note that more aggressive renaming is possible, but this requires more
detailed analysis of the various roles played by some atom.  Helpful
and descriptive predicate names tend to be unique and are thus subject
to this transformation.  More general names tend to collide with other
roles of the same atom and thus prevent renaming.

\section{Finding Application files}	\label{sec:findappfile}

If your application uses files that are not part of the saved program
such as database files, configuration files, etc., the runtime version
has to be able to locate these files. The file_search_path/2 mechanism
in combination with the \cmdlineoption{-p} \arg{alias} command line
argument provides a flexible mechanism for locating runtime files.
