\chapter{Development and debugging tools}	\label{sec:debugging}

This section describes various tools and techniques to help finding bugs
in XPCE/Prolog code.  XPCE/Prolog provides an interactive program development
environment: a dynamic object-oriented environment that may be
inspected, traced and modified during execution.  Unlike Prolog, XPCE
almost exclusively manipulates global information.  This limits the
possibilities for interactive manipulation of the environment.  For
example, you cannot {\em undo} operations in XPCE, change the program and
redo the goal as you can in Prolog.

\section{Object-base consistency}

Unlike Prolog, XPCE is not {\em secure}: if a Prolog environment traps
a fatal error there is almost always a bug in the Prolog system.
Except for violating system limits there is no Prolog program that can
make the Prolog environment crash.  For XPCE this is different.
Consider the following example:

\begin{code}
1 ?- new(@p, picture),
     send(@p, display, new(B, box(100,100))),
     get(B, area, Area),
     free(Area).

Area = @ 803438, B = @803419/box
\end{code}

After these calls, the <-area attribute of the box has been destroyed,
but the box is not aware of this fact.  The utility predicate
checkpce/0 scans the XPCE object-base for various inconsistencies and
will report that the box contains a slot referring to a freed object.

\begin{code}
2 ?- checkpce.

[WARNING: Freed object in slot area of @803419/box: @803438/area]
[PCE: Checked 13173 objects]
\end{code}

XPCE uses heuristics trying to avoid that such problems actually
crash the system (in the example above execution continues
normally).

We advice using checkpce/0 regularly during program development to
verify your application is not violating object consistency.  Please
see section~\ref{sec:whoiswho} and~\ref{sec:hyper} for techniques
to avoid `dangling' object references.


\section{The XPCE tracer}

The XPCE tracer allows both for interactive execution as for printing the
entry and/or completion of operations. This section first introduces
some common ways to exploit the tracer. Section~\ref{sec:tracemodel}
discusses the underlying concepts. The end of this section provides
examples of advanced queries to the tracer such as conditional trace-
and break-points.

\subsection{XPCE in trace mode}

The execution of the virtual-machine instructions may be inspected
using:%
    \footnote{Implemented as {\tt send(class(vmi), trace, @on).}}

\begin{code}
1 ?- tracepce.
[ 1] exit: send(@vmi_class/class, trace, @on/bool)

2 ?- new(@v, view).
[ 1] enter: new(view)
[ 1] exit: new(view) --> @v/view
\end{code}

The tracer is switched off using notracepce/0.

Full trace mode often gives an enormous amount of unreadable output and
should be avoided.  Below we present predicates that allow for more
fine-tuned tracing of XPCE's actions.


\subsection{Tracing specific methods}

It is often useful to inspect the execution of a particular method.
Suppose we want to monitor geometry-changes of graphical objects.  The
utility predicate tracepce/1 (see also \secref{interface}) may be used:

\begin{code}
1 ?- tracepce((graphical->geometry)).
Trace method: graphical ->geometry
\end{code}

As \verb$->$ is a standard Prolog operator with priority over 1000,
tracepce/1 requires two brackets.  Get-methods may be specified in
a similar way.  \verb$<-$ is not an operator.  It is suggested to
define \verb$<-$ as an infix operator in the XPCE initialisation
file, so this operator is available during program development:

\begin{code}
:- op(100, xfx, <-).
\end{code}

Instance variables may be specified as <class>-<variable>. A trace-point
on an instance variable makes both reading and writing the variable
visible.

The predicate notracepce/1 disables a tracepoint.


\subsubsection{Breaking on certain operations}.

An XPCE {\em break-point} is similar to a Prolog spy-point.  Execution
is broken and the debugger waits for further instructions. The available
instructions are given in \secref{inspecterrors}.  The predicates to
manipulate breakpoints are breakpce/1 and nobreakpce/1. These predicates
use the same syntax as tracepce/1 and notracepce/1.


\subsection{Inspecting the context of errors} \label{sec:inspecterrors}

Whenever an error is detected of <-kind `error' and the <-feedback
equals `print' the error will be printed, after which an {\em exception}
flag is placed on the current goal and the tracer is switched on in
`user' mode. This will cause the tracer to `break' at the `fail' port of
the operation that generated the error.

The tracer may now be used to examine the execution context of the
error.  The following example illustrates this

\begin{code}
bug :-
	new(P, picture),
	new(B, list_browser),
	send(P, below, B),
	send(B, open).

1 ?- bug.
[PCE error: window ->below: Argument 1 should be a window
        in: M @922496/picture(window) ->below: @922729/list_browser]
[ 2] fail: M @922496/picture(window) ->below: @922729/list_browser ? 
\end{code}

The error indicates a method has been invoked whose first argument
should be a window object. The ``in:'' line shows the top of the
goal-stack. The line starting ``[2]'' is the XPCE tracer. The following
tracer options are useful to find the context of the error:

\begin{itemize}
    \tick{{\bf g[a][h] [depth]:} Goals}
Print the stack.  By default it prints the `user' goals of XPCE's stack
of active messages.  With the `{\bf a}lways' modifier it also prints
the internal (system) messages.  With the `{\bf h}ost' modifier it will
print the Prolog stack. The optional `depth' argument specifies the
number of frames printed.
    \tick{{\bf b}: Break}
Start a recursive interactive Prolog top level (as the Prolog predicate
break/0).  This may be used to get information on the status of the
object base, Prolog program, etc.
    \tick{{\bf t}: Trace}
Disable the XPCE tracer and start the Prolog tracer.  This will cause
execution to continue until control reaches Prolog again, after which
the Prolog tracer may be used to examine the Prolog context of the
error.
    \tick{{\bf e[i][w][e][f] [id]}: Error Kind}
Change the `kind' of the current error or the error with identifier {\em
id}:  `i' is ignore; `w' is warning (print, but do not break); `e' is
error (print and break), `f' is fatal (print stack and abort).
    \tick{{\bf a}: Abort}
Abort execution and restart the Prolog top level.  Be careful with this
option as it sometimes leaves either the X11 library or XPCE in an
inconsistent state.
    \tick{{\bf n}: Nodebug}
Continue execution.  Note that the current message will fail.  Note that
some methods do not anticipate failure of sending a message.  In these
cases the system will behave in an unpredictable manner.
\end{itemize}


\subsection{The trace model}			\label{sec:tracemodel}

All objects of XPCE's program-world (classes, methods, messages, etc.)
are subclasses of class \class{program_object} which defines the
manipulation of the tracer.  Except for classes, whose role is
explained later, all program objects represent an `operation'.  For
example, a method may be invoked and an instance variable may be
assigned to.


\subsubsection{Goals}

When a program-object is executed, we distinguish three `ports': {\em
enter} when the operation is started; {\em exit} when the execution is
terminated successfully and {\em fail} when the execution is
terminated with failure.

The tracer associates a {\em goal} with the execution of a
program-object.  A new goal is created and pushed on the {\em
goal-stack} when the execution of a program-object is started
(entered).  After completion of the execution this goal is popped from
the goal-stack again.  A frame of the goal-stack stores the following
information to facilitate the XPCE tracer:

\begin{itemize}
    \tick{object}
The `object' of a goal is the program-object currently executed.
    \tick{receiver}
The `receiver' of a goal is the object manipulated.  This concept
is not clear for all program-objects.  See table~\ref{tab:goalargs}.
    \tick{selector}
The `selector' is the name of the operation performed.  This too
is not evident for all program-objects.  See table~\ref{tab:goalargs}.
    \tick{argument vector}
The context arguments used to execute the program-object.
\end{itemize}


\subsubsection{Trace- and break-points}

Each program-object (except for classes, which cannot be executed) may
be assigned either a trace- or a break-point as well as a trace- or
break-condition.  If the program-object is executed and it has a
trace-point set a message will be printed to indicate entry and
completion of the execution.  If it has a break-point set the
tracer will, after printing the message, stop (`break') the execution.
The user is prompted on how execution is to be continued.

By default, a program-object {\em inherits} its trace- and break-point
from its {\em class}.  Thus, if a trace-point is associated with class
\class{send_method} it is active on all send_method instances, except
for those for which it has been explicitly disabled.  Program-object
classes inherit their trace- and break-points from their super-class.
Thus, associating a trace-point with class \class{program_object}
associates it as a default for all traceable objects.

Both trace- and break-points may be associated with a {\em condition}.
This is a \class{code}-object that is evaluated before the trace- or
break-point is activated.  If the code object fails the goal is not
printed (or execution is not `broken').  The parameters passed
to the code are listed in table~\ref{tab:goalargs}.

\begin{table}
\begin{center}
\begin{tabular}{|lll|}
\hline
@vmi_send	& @receiver	& Receiver of the message \\
@vmi_get	& @selector	& Selector of the message \\
		& @arg1 ...	& arguments to the message \\
\hline
@vmi_new	& @receiver	& Class to be instantiated \\
		& @selector	& `new' \\
		& @arg1 ...	& arguments to new \\
\hline
@vmi_free	& @receiver	& Object to be freed \\
		& @selector	& `free' \\
\hline
Class code	& @receiver	& Code object executed \\
		& @selector	& `execute' \\
\hline
Class send_method& @receiver	& Receiver of the message \\
Class get_method& @selector	& Selector of the message \\
		& @arg1 ...	& arguments to the message \\
\hline
Class type	& @receiver	& Object to be converted \\
		& @selector	& `convert' \\
\hline
\end{tabular}
\end{center}
	\caption{Context arguments for trace- and break-conditions}
	\label{tab:goalargs}
\end{table}

\subsubsection{The virtual machine operations}	\label{sec:vmi}

The basic operations of XPCE (new, send, get and free) are added to
this model by introducing class \class{vmi} with instances @vmi_new,
@vmi_send, @vmi_get and @vmi_free.


\subsubsection{System and user mode of operation}

XPCE distinguishes between two modes of operating a goal: system- and
user-mode.  This distinction allows the system to only display goals
that have been specified by the user and to hide goals invoked by the
system itself.   All goals are executed in system-mode with the
exception of new-, send-, get- and free-operations started from
Prolog and the execution of program-objects created by the user.

The tracer may be used at three levels: {\em never} implies that
the tracer is not active; {\em user} implies that the tracer is
active on goals executed in user-mode {\em and} goals executed
in system-mode for which there is an explicit trace- or break-point
(i.e. {\em not} an inherited one).  Finally, mode {\em always}
implies that both system- and user-level goals are traced.  The
level of tracing is determined by `@pce ->trace'.


\subsection{Advanced examples}

At the start of this chapter we have introduced some simple ways to
operate the tracer.  In this section we will give more advanced
examples to help finding common problems.


\subsubsection{Tracing event-processing}

A commonly encountered problem is that your application simply
does not respond to a specific mouse and/or keyboard operation.
For example you programmed an object to be movable with the
middle-mouse-button; but it does not respond.

The first thing to verify is whether the events arrive where you expect
them.  When operating the mouse many events are generated which requires
selective printing of goals.  Breaking is not advised as the mouse is
necessary to carry-out the move-gesture and thus cannot be used to
select the trace-window.  To debug event-processing it is first of all
useful to know who processes the events and with what result.  The
following query will print the execution of any send-operation with
selector `event' that is caused by the mouse-middle-down event.

\begin{code}
1 ?- send(@vmi_send, trace, @on, full,
	  and(@selector == event,
	      message(@event, is_a, ms_middle_down))).
\end{code}


\subsubsection{Why does this goal fail?}

Another common problem is that an application that once worked now
suddenly simply fails without any warning.  What may be wrong?
Without any problem-specific hints the most useful start is to
print failing virtual machine instructions:

\begin{code}
1 ?- send(class(vmi), trace, @on, fail).
\end{code}

Now, unfortunately this may result in lots of messages because some
operations are designed to test status and succeed or fail according
to the result of the test.  The following will ignore all failing
send-operations whose method summary-string starts with ``Test''.

\begin{code}
2 ?- new(@no_test_method,
	 not(message(?(@receiver, send_method,
	               @selector)?second?summary,
	             prefix, 'Test'))).

3 ?- send(@vmi_send, trace, @on, fail, @no_test_method).
\end{code}

\section{Visual hierarchy tool}		\label{sec:vishierarchy}

\index{hierarchy,of UI components}
The ``Visual Hierarchy'' tool provides an overview of the consists-of
relations between the various UI components in a tool.  It is part of
the online manual tools and may be started from the ``Tool'' entry in
the main dialog.  Figure~\ref{fig:vishierarchy} shows this tool examining
the structure of the ``Ispell'' demo program.

\postscriptfig[width=\textwidth]{vishierarchy}{Visual Hierarchy Tool showing ``Ispell''}

\index{postscript}
This tool is very useful to examine the structure of existing
applications (for example the various demo programs).  It may also
be used to find object-references and to launch the inspector
(\secref{inspector}) on a particular object.

There are three ways to expand the tree of the visual hierarchy
tool.  The first is to expand the tree from the initially displayed
root object.  The second is to type the reference in the ``Visual''
text_item and press {\sc return}.  The most comfortable way is to position
the mouse in the target object and type {\sc meta-shift-control-V}.%
    \footnote{To remember this sequence: {\bf V} for Visual and all
              defined modifiers to avoid a conflict with application
	      defined key-bindings.}
	      

\section{Inspector tool}		\label{sec:inspector}

The inspector provides a visual representation of all attributes of an
object.  It is a visual form of the debugging predicate show_slots/1
which dumps the class and slot value of the argument reference in
the Prolog window.  The inspector is started from the ``Tools'' entry
of the manual tools.

\postscriptfig[width=\textwidth]{inspector}{Inspector Tool}
\index{object,inspecting}\index{inspector}

