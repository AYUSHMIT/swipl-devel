\libdoc{clpfd}{CLP(FD): Constraint Logic Programming over Finite Domains}

\label{sec:clpfd}

\begin{tags}
    \tag{author}
\url[Markus Triska]{https://www.metalevel.at}
\end{tags}

\subsection{Introduction}

\label{sec:clpfd-intro}

This library provides CLP(FD): Constraint Logic Programming over
Finite Domains.

CLP(FD) is an instance of the general CLP(.) scheme, extending logic
programming with reasoning over specialised domains. CLP(FD) lets us
reason about \textbf{integers} in a way that fits the relational
nature of~Prolog.

There are two major use cases of CLP(FD) constraints:

\begin{enumerate}
    \item \textbf{declarative integer arithmetic} (\secref{clpfd-integer-arith})
    \item solving \textbf{combinatorial problems} such as planning, scheduling
and allocation tasks.
\end{enumerate}

\noindent
The predicates of this library can be classified as:

\begin{itemize}
    \item \textit{arithmetic} constraints like \predref{\Sceq}{2}, \predref{\Scgt}{2} and \predref{\Scne}{2} (\secref{clpfd-arithmetic})
    \item the \textit{membership} constraints \predref{in}{2} and \predref{ins}{2} (\secref{clpfd-membership})
    \item the \textit{enumeration} predicates \predref{indomain}{1}, \predref{label}{1} and \predref{labeling}{2} (\secref{clpfd-enumeration})
    \item \textit{combinatorial} constraints like \predref{all_distinct}{1} and \predref{global_cardinality}{2} (\secref{clpfd-global})
    \item \textit{reification} predicates such as
      \predref{\Scequal}{2} (\secref{clpfd-reification-predicates})
    \item \textit{reflection} predicates such as \predref{fd_dom}{2}
      (\secref{clpfd-reflection-predicates})
\end{itemize}

In most cases, \textit{arithmetic constraints}
(\secref{clpfd-arith-constraints}) are the only predicates you will
ever need from this library. When reasoning over integers, simply
replace low-level arithmetic predicates like \verb$(is)/2$ and
\verb$(>)/2$ by the corresponding CLP(FD) constraints like
\predref{\Sceq}{2} and \predref{\Scgt}{2} to honor and preserve
declarative properties of your programs. For satisfactory performance,
arithmetic constraints are implicitly rewritten at compilation time so
that low-level fallback predicates are automatically used whenever
possible.

Almost all Prolog programs also reason about integers. Therefore, it
is highly advisable that you make CLP(FD) constraints available in all
your programs. One way to do this is to put the following directive in
your \verb$~/.swiplrc$ initialisation file:

\begin{code}
:- use_module(library(clpfd)).
\end{code}

All example programs that appear in the CLP(FD) documentation assume
that you have done this.

Important concepts and principles of this library are illustrated by
means of usage examples that are available in a public git repository:
\url[\textbf{github.com/triska/clpfd}]{https://github.com/triska/clpfd}

If you are used to the complicated operational considerations that
low-level arithmetic primitives necessitate, then moving to CLP(FD)
constraints may, due to their power and convenience, at first feel to
you excessive and almost like cheating. It \textit{isn't}. Constraints are an
integral part of all popular Prolog systems, and they are designed
to help you eliminate and avoid the use of low-level and less general
primitives by providing declarative alternatives that are meant to be
used instead.

When teaching Prolog, CLP(FD) constraints should be introduced
\textit{before} explaining low-level arithmetic predicates and their
procedural idiosyncrasies. This is because constraints are easy to
explain, understand and use due to their purely relational nature. In
contrast, the modedness and directionality of low-level arithmetic
primitives are impure limitations that are better deferred to more
advanced lectures.

We recommend the following reference (PDF:
\url[metalevel.at/swiclpfd.pdf]{https://www.metalevel.at/swiclpfd.pdf}) for
citing this library in scientific publications:

\begin{code}
@inproceedings{Triska12,
  author    = {Markus Triska},
  title     = {The Finite Domain Constraint Solver of {SWI-Prolog}},
  booktitle = {FLOPS},
  series    = {LNCS},
  volume    = {7294},
  year      = {2012},
  pages     = {307-316}
}
\end{code}

More information about CLP(FD) constraints and their implementation is
contained in: \url[\textbf{metalevel.at/drt.pdf}]{https://www.metalevel.at/drt.pdf}

The best way to discuss applying, improving and extending CLP(FD)
constraints is to use the dedicated \const{clpfd} tag on
\url[stackoverflow.com]{http://stackoverflow.com}. Several of the world's
foremost CLP(FD) experts regularly participate in these discussions
and will help you for free on this platform.

\subsection{Arithmetic constraints}

\label{sec:clpfd-arith-constraints}

In modern Prolog systems, \textbf{arithmetic constraints} subsume and
supersede low-level predicates over integers. The main advantage of
arithmetic constraints is that they are true \textit{relations} and can be
used in all directions. For most programs, arithmetic constraints are
the only predicates you will ever need from this library.

The most important arithmetic constraint is \predref{\Sceq}{2}, which
subsumes both \verb$(is)/2$ and \verb$(=:=)/2$ over integers.

In total, the arithmetic constraints are:

\begin{quote}
\begin{tabular}{|l|l|}
\hline
Expr1 \verb$#=$ Expr2 & Expr1 equals Expr2 \\
Expr1 \verb$#\=$ Expr2 & Expr1 is not equal to Expr2 \\
Expr1 \verb$#>=$ Expr2 & Expr1 is greater than or equal to Expr2 \\
Expr1 \verb$#=<$ Expr2 & Expr1 is less than or equal to Expr2 \\
Expr1 \verb$#>$ Expr2 & Expr1 is greater than Expr2 \\
Expr1 \verb$#<$ Expr2 & Expr1 is less than Expr2 \\
\hline
\end{tabular}
\end{quote}

\arg{Expr1} and \arg{Expr2} denote \textbf{arithmetic expressions}, which are:

\begin{quote}
\begin{tabular}{|l|l|}
\hline
\textit{integer} & Given value \\
\textit{variable} & Unknown integer \\
?(\textit{variable}) & Unknown integer \\
-Expr & Unary minus \\
Expr + Expr & Addition \\
Expr * Expr & Multiplication \\
Expr - Expr & Subtraction \\
Expr \Shat{} Expr & Exponentiation \\
\verb$min(Expr,Expr)$ & Minimum of two expressions \\
\verb$max(Expr,Expr)$ & Maximum of two expressions \\
Expr \const{mod} Expr & Modulo induced by floored division \\
Expr \const{rem} Expr & Modulo induced by truncated division \\
\verb$abs(Expr)$ & Absolute value \\
Expr \Sidiv{} Expr & Truncated integer division \\
\hline
\end{tabular}
\end{quote}

where \arg{Expr} again denotes an arithmetic expression.

The bitwise operations \verb$(\)/1$, \verb$(/\)/2$, \verb$(\/)/2$, \verb$(>>)/2$,
\verb$(<<)/2$, \verb$lsb/1$, \verb$msb/1$, \verb$popcount/1$ and \verb$(xor)/2$ are also
supported.

\subsection{Declarative integer arithmetic}

\label{sec:clpfd-integer-arith}

The \textit{arithmetic constraints} \predref{\Sceq}{2},
\predref{\Scgt}{2} etc. (\secref{clpfd-arith-constraints}) are meant
to be used \textit{instead} of the primitives \verb$(is)/2$,
\verb$(=:=)/2$, \verb$(>)/2$ etc. over integers. Almost all Prolog
programs also reason about integers. Therefore, it is recommended that
you put the following directive in your \verb$~/.swiplrc$
initialisation file to make CLP(FD) constraints available in all your
programs:

\begin{code}
:- use_module(library(clpfd)).
\end{code}

Throughout the following, it is assumed that you have done this.

The most basic use of CLP(FD) constraints is \textit{evaluation} of
arithmetic expressions involving integers. For example:

\begin{code}
?- X #= 1+2.
X = 3.
\end{code}

This could in principle also be achieved with the lower-level
predicate \verb$(is)/2$. However, an important advantage of arithmetic
constraints is their purely relational nature: Constraints can be used
in \textit{all directions}, also if one or more of their arguments are only
partially instantiated. For example:

\begin{code}
?- 3 #= Y+2.
Y = 1.
\end{code}

This relational nature makes CLP(FD) constraints easy to explain and
use, and well suited for beginners and experienced Prolog programmers
alike. In contrast, when using low-level integer arithmetic, we get:

\begin{code}
?- 3 is Y+2.
ERROR: is/2: Arguments are not sufficiently instantiated

?- 3 =:= Y+2.
ERROR: =:=/2: Arguments are not sufficiently instantiated
\end{code}

Due to the necessary operational considerations, the use of these
low-level arithmetic predicates is considerably harder to understand
and should therefore be deferred to more advanced lectures.

For supported expressions, CLP(FD) constraints are drop-in
replacements of these low-level arithmetic predicates, often yielding
more general programs. See \secref{clpfd-factorial} for an example.

This library uses \predref{goal_expansion}{2} to automatically rewrite
constraints at compilation time so that low-level arithmetic
predicates are \textit{automatically} used whenever possible. For example,
the predicate:

\begin{code}
positive_integer(N) :- N #>= 1.
\end{code}

is executed as if it were written as:

\begin{code}
positive_integer(N) :-
        (   integer(N)
        ->  N >= 1
        ;   N #>= 1
        ).
\end{code}

This illustrates why the performance of CLP(FD) constraints is almost
always completely satisfactory when they are used in modes that can be
handled by low-level arithmetic. To disable the automatic rewriting,
set the Prolog flag \verb$clpfd_goal_expansion$ to \const{false}.

If you are used to the complicated operational considerations that
low-level arithmetic primitives necessitate, then moving to CLP(FD)
constraints may, due to their power and convenience, at first feel to
you excessive and almost like cheating. It \textit{isn't}. Constraints are an
integral part of all popular Prolog systems, and they are designed
to help you eliminate and avoid the use of low-level and less general
primitives by providing declarative alternatives that are meant to be
used instead.

\subsection{Combinatorial constraints}

\label{sec:clpfd-combinatorial}

In addition to subsuming and replacing low-level arithmetic
predicates, CLP(FD) constraints are often used to solve combinatorial
problems such as planning, scheduling and allocation tasks. Among the
most frequently used \textbf{combinatorial constraints} are \predref{all_distinct}{1},
\predref{global_cardinality}{2} and \predref{cumulative}{2}. This library also provides
several other constraints like \predref{disjoint2}{1} and \predref{automaton}{8}, which are
useful in more specialized applications.

\subsection{Domains}

\label{sec:clpfd-domains}

Each CLP(FD) variable has an associated set of admissible integers,
which we call the variable's \textbf{domain}. Initially, the domain of
each CLP(FD) variable is the set of \textit{all} integers. CLP(FD)
constraints like \predref{\Sceq}{2}, \predref{\Scgt}{2} and
\predref{\Scne}{2} can at most reduce, and never extend, the domains
of their arguments. The constraints \predref{in}{2} and
\predref{ins}{2} let us explicitly state domains of CLP(FD)
variables. The process of determining and adjusting domains of
variables is called constraint \textbf{propagation}, and it is
performed automatically by this library. When the domain of a variable
contains only one element, then the variable is automatically unified
to that element.

Domains are taken into account when further constraints are stated,
and by enumeration predicates like \predref{labeling}{2}.

\subsection{Residual goals}

\label{sec:clpfd-residual-goals}

Here is an example session with a few queries and their answers:

\begin{code}
?- X #> 3.
X in 4..sup.

?- X #\= 20.
X in inf..19\/21..sup.

?- 2*X #= 10.
X = 5.

?- X*X #= 144.
X in -12\/12.

?- 4*X + 2*Y #= 24, X + Y #= 9, [X,Y] ins 0..sup.
X = 3,
Y = 6.

?- X #= Y #<==> B, X in 0..3, Y in 4..5.
B = 0,
X in 0..3,
Y in 4..5.
\end{code}

The answers emitted by the toplevel are called \textit{residual programs},
and the goals that comprise each answer are called \textbf{residual goals}.
In each case above, and as for all pure programs, the residual program
is declaratively equivalent to the original query. From the residual
goals, it is clear that the constraint solver has deduced additional
domain restrictions in many cases.

To inspect residual goals, it is best to let the toplevel display them
for you. Wrap the call of your predicate into \predref{call_residue_vars}{2} to
make sure that all constrained variables are displayed. To make the
constraints a variable is involved in available as a Prolog term for
further reasoning within your program, use \predref{copy_term}{3}. For example:

\begin{code}
?- X #= Y + Z, X in 0..5, copy_term([X,Y,Z], [X,Y,Z], Gs).
Gs = [clpfd: (X in 0..5), clpfd: (Y+Z#=X)],
X in 0..5,
Y+Z#=X.
\end{code}

This library also provides \textit{reflection} predicates (like \predref{fd_dom}{2},
\predref{fd_size}{2} etc.) with which we can inspect a variable's current
domain. These predicates can be useful if you want to implement your
own labeling strategies.

\subsection{Core relations and search}

\label{sec:clpfd-search}

Using CLP(FD) constraints to solve combinatorial tasks typically
consists of two phases:

\begin{enumerate}
    \item First, all relevant constraints are stated.
    \item Second, if the domain of each involved variable is \textit{finite},
then \textit{enumeration predicates} can be used to search for
concrete solutions.
\end{enumerate}

It is good practice to keep the modeling part, via a dedicated
predicate called the \textbf{core relation}, separate from the actual
search for solutions. This lets us observe termination and
determinism properties of the core relation in isolation from the
search, and more easily try different search strategies.

As an example of a constraint satisfaction problem, consider the
cryptoarithmetic puzzle SEND + MORE = MONEY, where different letters
denote distinct integers between 0 and 9. It can be modeled in CLP(FD)
as follows:

\begin{code}
puzzle([S,E,N,D] + [M,O,R,E] = [M,O,N,E,Y]) :-
        Vars = [S,E,N,D,M,O,R,Y],
        Vars ins 0..9,
        all_different(Vars),
                  S*1000 + E*100 + N*10 + D +
                  M*1000 + O*100 + R*10 + E #=
        M*10000 + O*1000 + N*100 + E*10 + Y,
        M #\= 0, S #\= 0.
\end{code}

Notice that we are \textit{not} using \predref{labeling}{2} in this predicate, so that
we can first execute and observe the modeling part in isolation.
Sample query and its result (actual variables replaced for
readability):

\begin{code}
?- puzzle(As+Bs=Cs).
As = [9, A2, A3, A4],
Bs = [1, 0, B3, A2],
Cs = [1, 0, A3, A2, C5],
A2 in 4..7,
all_different([9, A2, A3, A4, 1, 0, B3, C5]),
91*A2+A4+10*B3#=90*A3+C5,
A3 in 5..8,
A4 in 2..8,
B3 in 2..8,
C5 in 2..8.
\end{code}

From this answer, we see that this core relation \textit{terminates} and is in
fact \textit{deterministic}. Moreover, we see from the residual goals that
the constraint solver has deduced more stringent bounds for all
variables. Such observations are only possible if modeling and search
parts are cleanly separated.

Labeling can then be used to search for solutions in a separate
predicate or goal:

\begin{code}
?- puzzle(As+Bs=Cs), label(As).
As = [9, 5, 6, 7],
Bs = [1, 0, 8, 5],
Cs = [1, 0, 6, 5, 2] ;
false.
\end{code}

In this case, it suffices to label a subset of variables to find the
puzzle's unique solution, since the constraint solver is strong enough
to reduce the domains of remaining variables to singleton sets. In
general though, it is necessary to label all variables to obtain
ground solutions.

\subsection{Optimisation}

\label{sec:clpfd-optimisation}

We can use \predref{labeling}{2} to minimize or maximize the value of
a CLP(FD) expression, and generate solutions in increasing or
decreasing order of the value. See the labeling options
\verb$min(Expr)$ and \verb$max(Expr)$, respectively.

Again, to easily try different labeling options in connection with
optimisation, we recommend to introduce a dedicated predicate for
posting constraints, and to use \verb$labeling/2$ in a separate goal. This
way, we can observe properties of the core relation in isolation,
and try different labeling options without recompiling our code.

If necessary, we can use \verb$once/1$ to commit to the first optimal
solution. However, it is often very valuable to see alternative
solutions that are \textit{also} optimal, so that we can choose among
optimal solutions by other criteria. For the sake of purity and
completeness, we recommend to avoid \verb$once/1$ and other constructs
that lead to impurities in CLP(FD) programs.

Related to optimisation with CLP(FD) constraints is the
\url[\textbf{simplex
  library}]{http://eu.swi-prolog.org/man/simplex.html} and
\textbf{CLP(Q)} which reason about \textit{linear} constraints over
rational numbers.

\subsection{Reification}

\label{sec:clpfd-reification}

The constraints \predref{in}{2}, \predref{\Sceq}{2}, \predref{\Scne}{2}, \predref{\Sclt}{2}, \predref{\Scgt}{2}, \predref{\Scle}{2}, and \predref{\Scge}{2} can be
\textit{reified}, which means reflecting their truth values into Boolean
values represented by the integers 0 and 1. Let P and Q denote
reifiable constraints or Boolean variables, then:

\begin{quote}
\begin{tabular}{|l|l|}
\hline
\Scnot{} Q & True iff Q is false \\
P \Scor{} Q & True iff either P or Q \\
P \Scand{} Q & True iff both P and Q \\
P \Scnot{} Q & True iff either P or Q, but not both \\
P \Scequal{} Q & True iff P and Q are equivalent \\
P \Srimplies{} Q & True iff P implies Q \\
P \Slimplies{} Q & True iff Q implies P \\
\hline
\end{tabular}
\end{quote}

The constraints of this table are reifiable as well.

When reasoning over Boolean variables, also consider using
CLP(B)~constraints as provided by
\url[\textbf{library(clpb)}]{http://eu.swi-prolog.org/man/clpb.html}.

\subsection{Enabling monotonic CLP(FD)}

\label{sec:clpfd-monotonicity}

In the default execution mode, CLP(FD) constraints still exhibit some
non-relational properties. For example, \textit{adding} constraints can yield
new solutions:

\begin{code}
?-          X #= 2, X = 1+1.
false.

?- X = 1+1, X #= 2, X = 1+1.
X = 1+1.
\end{code}

This behaviour is highly problematic from a logical point of view, and
it may render declarative debugging techniques inapplicable.

Set the Prolog flag \verb$clpfd_monotonic$ to \const{true} to make CLP(FD)
\textbf{monotonic}: This means that \textit{adding} new constraints \textit{cannot} yield
new solutions. When this flag is \const{true}, we must wrap variables that
occur in arithmetic expressions with the functor \verb$(?)/1$ or \verb$(#)/1$. For
example:

\begin{code}
?- set_prolog_flag(clpfd_monotonic, true).
true.

?- #(X) #= #(Y) + #(Z).
#(Y)+ #(Z)#= #(X).

?-          X #= 2, X = 1+1.
ERROR: Arguments are not sufficiently instantiated
\end{code}

The wrapper can be omitted for variables that are already constrained
to integers.

\subsection{Custom constraints}

\label{sec:clpfd-custom-constraints}

We can define custom constraints. The mechanism to do this is not yet
finalised, and we welcome suggestions and descriptions of use cases
that are important to you.

As an example of how it can be done currently, let us define a new
custom constraint \verb$oneground(X,Y,Z)$, where Z shall be 1 if at least
one of X and Y is instantiated:

\begin{code}
:- multifile clpfd:run_propagator/2.

oneground(X, Y, Z) :-
        clpfd:make_propagator(oneground(X, Y, Z), Prop),
        clpfd:init_propagator(X, Prop),
        clpfd:init_propagator(Y, Prop),
        clpfd:trigger_once(Prop).

clpfd:run_propagator(oneground(X, Y, Z), MState) :-
        (   integer(X) -> clpfd:kill(MState), Z = 1
        ;   integer(Y) -> clpfd:kill(MState), Z = 1
        ;   true
        ).
\end{code}

First, \qpredref{clpfd}{make_propagator}{2} is used to transform a user-defined
representation of the new constraint to an internal form. With
\qpredref{clpfd}{init_propagator}{2}, this internal form is then attached to X and
Y. From now on, the propagator will be invoked whenever the domains of
X or Y are changed. Then, \qpredref{clpfd}{trigger_once}{1} is used to give the
propagator its first chance for propagation even though the variables'
domains have not yet changed. Finally, \qpredref{clpfd}{run_propagator}{2} is
extended to define the actual propagator. As explained, this predicate
is automatically called by the constraint solver. The first argument
is the user-defined representation of the constraint as used in
\qpredref{clpfd}{make_propagator}{2}, and the second argument is a mutable state
that can be used to prevent further invocations of the propagator when
the constraint has become entailed, by using \qpredref{clpfd}{kill}{1}. An example
of using the new constraint:

\begin{code}
?- oneground(X, Y, Z), Y = 5.
Y = 5,
Z = 1,
X in inf..sup.
\end{code}


\subsection{Example: Factorial relation}

\label{sec:clpfd-factorial}

We illustrate the benefit of using \predref{\Sceq}{2} for more
generality with a simple example. The following Prolog program relates
each natural number~$N$ to its factorial~$F$:

\begin{code}
n_factorial(0, 1).
n_factorial(N, F) :-
        N #> 0,
        N1 #= N - 1,
        F #= N * F1,
        n_factorial(N1, F1).
\end{code}

This relation can be used in all directions. For example:

\begin{code}
?- n_factorial(47, F).
F = 258623241511168180642964355153611979969197632389120000000000 ;
false.

?- n_factorial(N, 1).
N = 0 ;
N = 1 ;
false.

?- n_factorial(N, 3).
false.
\end{code}

To make the predicate terminate if any argument is instantiated, add
the (implied) constraint \verb$F #\= 0$ before the recursive call.
Otherwise, the query \verb$n_factorial(N, 0)$ is the only non-terminating
case of this kind.

\subsection{Example: Sudoku}
\label{sec:clpfd-sudoku}

As another example, consider \textit{Sudoku}: It is a popular puzzle
over integers that can be easily solved with CLP(FD) constraints.

\begin{code}
sudoku(Rows) :-
        length(Rows, 9), maplist(same_length(Rows), Rows),
        append(Rows, Vs), Vs ins 1..9,
        maplist(all_distinct, Rows),
        transpose(Rows, Columns),
        maplist(all_distinct, Columns),
        Rows = [As,Bs,Cs,Ds,Es,Fs,Gs,Hs,Is],
        blocks(As, Bs, Cs),
        blocks(Ds, Es, Fs),
        blocks(Gs, Hs, Is).

blocks([], [], []).
blocks([N1,N2,N3|Ns1], [N4,N5,N6|Ns2], [N7,N8,N9|Ns3]) :-
        all_distinct([N1,N2,N3,N4,N5,N6,N7,N8,N9]),
        blocks(Ns1, Ns2, Ns3).

problem(1, [[_,_,_,_,_,_,_,_,_],
            [_,_,_,_,_,3,_,8,5],
            [_,_,1,_,2,_,_,_,_],
            [_,_,_,5,_,7,_,_,_],
            [_,_,4,_,_,_,1,_,_],
            [_,9,_,_,_,_,_,_,_],
            [5,_,_,_,_,_,_,7,3],
            [_,_,2,_,1,_,_,_,_],
            [_,_,_,_,4,_,_,_,9]]).
\end{code}

Sample query:

\begin{code}
?- problem(1, Rows), sudoku(Rows), maplist(writeln, Rows).
[9,8,7,6,5,4,3,2,1]
[2,4,6,1,7,3,9,8,5]
[3,5,1,9,2,8,7,4,6]
[1,2,8,5,3,7,6,9,4]
[6,3,4,8,9,2,1,5,7]
[7,9,5,4,6,1,8,3,2]
[5,1,9,2,8,6,4,7,3]
[4,7,2,3,1,9,5,6,8]
[8,6,3,7,4,5,2,1,9]
Rows = [[9, 8, 7, 6, 5, 4, 3, 2|...], ... , [...|...]].
\end{code}

In this concrete case, the constraint solver is strong enough to find
the unique solution without any search.

\subsection{Example: Eight queens puzzle}

\label{sec:clpfd-n-queens}

We illustrate further important concepts of this library by means of
the so-called \textit{eight queens puzzle}. The task is to place 8 queens on
an 8x8 chessboard such that none of the queens is under attack. This
means that no two queens share the same row, column or diagonal.

To express this puzzle via CLP(FD) constraints, we must first pick a
suitable representation. Since CLP(FD) constraints reason over
\textit{integers}, we must find a way to map the positions of queens to
integers. Several such mappings are conceivable, and it is not
immediately obvious which we should use. For this reason, \textit{modeling}
combinatorial problems via CLP(FD) constraints often necessitates some
creativity and has been described as more of an art than a science.

In our concrete case, we observe that there must be exactly one queen
per column. The following representation therefore suggests itself: We
are looking for 8 integers, one for each column, where each integer
denotes the \textit{row} of the queen that is placed in the respective
column, and which are subject to certain constraints.

In fact, let us now generalize the task to the so-called \textit{N queens
puzzle}, which is obtained by replacing 8 by \textit{N} everywhere it occurs
in the above description. We implement the above considerations in the
\textbf{core relation} \verb$n_queens/2$, where the first argument is the number
of queens (which is identical to the number of rows and columns of the
generalized chessboard), and the second argument is a list of \textit{N}
integers that represents a solution in the form described above.

\begin{code}
n_queens(N, Qs) :-
        length(Qs, N),
        Qs ins 1..N,
        safe_queens(Qs).

safe_queens([]).
safe_queens([Q|Qs]) :- safe_queens(Qs, Q, 1), safe_queens(Qs).

safe_queens([], _, _).
safe_queens([Q|Qs], Q0, D0) :-
        Q0 #\= Q,
        abs(Q0 - Q) #\= D0,
        D1 #= D0 + 1,
        safe_queens(Qs, Q0, D1).
\end{code}

Note that all these predicates can be used in \textit{all directions}: We
can use them to \textit{find} solutions, \textit{test} solutions and \textit{complete}
partially instantiated solutions.

The original task can be readily solved with the following query:

\begin{code}
?- n_queens(8, Qs), label(Qs).
Qs = [1, 5, 8, 6, 3, 7, 2, 4] .
\end{code}

Using suitable labeling strategies, we can easily find solutions with
80 queens and more:

\begin{code}
?- n_queens(80, Qs), labeling([ff], Qs).
Qs = [1, 3, 5, 44, 42, 4, 50, 7, 68|...] .

?- time((n_queens(90, Qs), labeling([ff], Qs))).
% 5,904,401 inferences, 0.722 CPU in 0.737 seconds (98% CPU)
Qs = [1, 3, 5, 50, 42, 4, 49, 7, 59|...] .
\end{code}

Experimenting with different search strategies is easy because we have
separated the core relation from the actual search.

\subsection{Applications}

\label{sec:clpfd-applications}

CLP(FD) applications that we find particularly impressive and worth
studying include:

\begin{itemize}
    \item Michael Hendricks uses CLP(FD) constraints for flexible reasoning
about \textit{dates} and \textit{times} in the
\url[\const{julian}]{http://www.swi-prolog.org/pack/list?p=julian} package.
    \item Julien Cumin uses CLP(FD) constraints for integer arithmetic in
\url[\const{Brachylog}]{https://github.com/JCumin/Brachylog}.
\end{itemize}

\subsection{Acknowledgments}

\label{sec:clpfd-acknowledgments}

This library gives you a glimpse of what \url[\textbf{SICStus
Prolog}]{https://sicstus.sics.se/} can do. The API is intentionally
mostly compatible with that of SICStus Prolog, so that you can easily
switch to a much more feature-rich and much faster CLP(FD) system when
you need it. I thank \url[Mats Carlsson]{https://www.sics.se/\Stilde{}matsc/}, the
designer and main implementor of SICStus Prolog, for his elegant
example. I first encountered his system as part of the excellent
\url[\textbf{GUPU}]{http://www.complang.tuwien.ac.at/ulrich/gupu/} teaching
environment by \url[Ulrich
Neumerkel]{http://www.complang.tuwien.ac.at/ulrich/}. Ulrich was also
the first and most determined tester of the present system, filing
hundreds of comments and suggestions for improvement. \url[Tom
Schrijvers]{https://people.cs.kuleuven.be/\Stilde{}tom.schrijvers/} has
contributed several constraint libraries to SWI-Prolog, and I learned
a lot from his coding style and implementation examples. \url[Bart
Demoen]{https://people.cs.kuleuven.be/\Stilde{}bart.demoen/} was a driving
force behind the implementation of attributed variables in SWI-Prolog,
and this library could not even have started without his prior work
and contributions. Thank you all!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{CLP(FD) predicate index}

\label{sec:clpfd-predicate-index}

In the following, each CLP(FD) predicate is described in more detail.

We recommend the following link to refer to this manual:

\url{http://eu.swi-prolog.org/man/clpfd.html}\vspace{0.7cm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% CLP(FD) predicate overview, generated from Markdown and PlDoc
\input{clpfdlib.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Closing and opening words about CLP(FD)}
\label{sec:clpfd-closing-opening}

CLP(FD) constraints have been described as the \textit{killer
  application} of logic programming. This means that they are one of
the main reasons why logic programming approaches are picked over
other paradigms for solving many tasks of high practical
relevance. The usefulness of CLP(FD) constraints for scheduling,
allocation and combinatorial optimization tasks is well-known both in
academia and industry.

With this library, we take the applicability of CLP(FD) constraints
one step further, following the road that visionary systems like
SICStus Prolog have already clearly outlined: This library is designed
to completely subsume and \textit{replace} low-level predicates over
integers, which were in the past repeatedly found to be a major
stumbling block when introducing logic programming to beginners.

Embrace the change and new opportunities that this paradigm allows!
Use CLP(FD) constraints in your programs. The use of CLP(FD)
constraints instead of low-level arithmetic is also a good indicator
to judge the quality of any introductory Prolog text.
