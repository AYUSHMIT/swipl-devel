\chapter{\product{} and Prolog} \label{sec:pceprolog}

\product{} and Prolog are very different systems based on a very different
programming paradigm.  \product{} objects have global state and use
destructive assignment.  \product{} programming constructs use both
procedures (code objects and send-methods) and functions (function
objects and get-methods).  \product{} has no notion of non-determinism as
Prolog has.

The hybrid \productpl{} environment allows the user to express
functionality both in Prolog and in \product{}.  This chapter discusses
representation of data and dealing with object-references in
\productpl{}.


\section{\product{} is not Prolog!}		\label{sec:notprolog}

Data managed by Prolog consists of logical variables, atoms, integers,
floats and compound terms (including lists).  \product{} has natural
counterparts for atoms (a \class{name} object), integers (a \product{} int) and
floating point numbers (a \class{real} object).  Prolog logical variables and
compound terms however have no direct counterpart in the \product{}
environment.  \product{} has variables (class \class{var}), but these obey
totally different scoping and binding rules.

Where Prolog uses a compound term to represent data that belongs
together (e.g.\ person(Name, Age, Address)), \product{} uses objects for this
purpose:%
    \footnote{This example uses \product{} user-defined classes.  The details
	      of this mechanism do not matter for the argument in this
	      section. User-defined classes are described in
	      \chapref{udc}.}

\begin{code}
:- pce_begin_class(person(name, age, address), object).

variable(name,    name,	  both, "Name of the person").
variable(age,     int,	  both, "Age in years").
variable(address, string, both, "Full address").

initialise(P, Name:name, Age:int, Address:string) :->
	"Create from name, age and address"::
	send(P, name, Name),
	send(P, age, Age),
	send(P, address, Address).

:- pce_end_class.

1 ?- new(P, person(fred, 30, 'Long Street 45')).
P = @3664437/person
\end{code}

These two representations have very different properties:

\begin{itemize}
    \tick{Equality}
Prolog cannot distinguish between `{\tt person('Fred', 30, 'Long Street
45')}' and a second instance of the same term. In \product{} two instances of
the same class having the same state are different entities.
    \tick{Attributes}
Whereas an attribute (argument) of a Prolog term is either a logical
variable or instantiated to a Prolog data object, an attribute of
an object may be assigned to.  The assignment is destructive.
    \tick{Types}
\product{} is a partially dynamically typed language and \product{} object attributes
may have types. Prolog is untyped.
\end{itemize}

Because there is no straight-forward translation from Prolog data
structures into \product{} objects it is not possible to pass Prolog data
through \product{} control structures.  We will illustrate this using the
code object declared below:

\begin{code}
1 ?- new(@m, and(message(@prolog, write, @arg1),
		 message(@prolog, nl))).
\end{code}

This code object will print the provided argument in the Prolog window
followed by a newline:

\begin{code}
2 ?- send(@m, forward, hello).
hello
\end{code}

From this example one might expect that \product{} is transparent to
Prolog data.  This is true for integers, floats and atoms as these
have a natural representation in both languages.  However:

\begin{code}
3 ?- send(@m, forward, chain(hello)).
@774516
4 ?- send(@m, forward, 3 + 4).
7
5 ?- send(@m, forward, [hello, world]).
[\product{} warning: new: Unknown class: .
        in: new(.(world, [])) ]
\end{code}

In all these examples the argument is a Prolog compound term which
---according to the definition of send/3--- is translated into a \product{}
instance of the class of the principal functor.  In 3) this is an
instance of class \class{chain}.  In 4) this is an instance of class
\class{+}.  Class \class{+} however is a subclass of the \product{} class
\class{function} and \idx{function} objects are evaluated when given
to a method that does not accept a function-type argument.  In 5) this
Prolog list actually is the term .(hello,.(world,[])) (see the
Prolog predicate display/2).  As \product{} does not define a class `.'
an error message results.

Below is a very realistic example of this misconception.

\begin{pcecode}
?- new(D, dialog('Bug')),
   send(D, append, button(verbose,
			  message(@prolog, assert,
				  verbose(on)))),
   send(D, open).
[PCE warning: new: Unknown class: verbose
        in: new(verbose(on)) ]
\end{pcecode}

A correct solution for this task is.

\begin{pcecode}
make_verbose_dialog :-
	new(D, dialog('Correct')),
	send(D, append,
	     button(verbose,
		    message(@prolog, set_verbose, on))),
	send(D, open).

set_verbose(Value) :-
	retractall(verbose(_)),
	assert(verbose(Value)).
\end{pcecode}

\mbox{}
