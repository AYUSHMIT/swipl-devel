\chapter{SWI-Prolog extensions}
\label{sec:extensions}

This chapter describes extensions to the Prolog language introduced with
SWI-Prolog version~7.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reserved constants}
\label{sec:ext-constants}

SWI-Prolog introduces constants that are distinct from the usual Prolog
atoms and numbers. These are introduced because text is commonly
represented using atoms. For example, a natural language parser
typically represents the input text as a list of words and punctuation
characters, where each of these is represented as an atom. At the same
time, Prolog is a dynamically typed language. This feature allows for
heterogeneous data representations that can be tested and acted on at
runtime. In particular, various predicates accept both a single item or
a list of items, e.g., load_files/2. As a result, the call
\exam{load_files([], [])} is \emph{ambiguous}, as it may mean `load no
files' or `load the file named \verb$"[]"$. Similar problems arise with
predicates that overload input text as either an atom or a list of
character codes, where \exam{[]} can both refer to the text \verb$"[]"$
(processed as an atom) or the empty string (processed as a list of
character codes).

The \textbf{syntax} for such constants is a string between \emph{back
quotes}. Backquoted constants are considered \emph{atomic} (see
atomic/1) but not atoms (see atom/1).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Lists are special}
\label{sec:ext-lists}

SWI-Prolog lists can be distinquished unambiguously at runtime from
both ordinary compound terms and the atom \const{'[]'} using the
reserved constants introduced in \secref{ext-constants}.  The
list \exam{[a,b]} is represented as the term below.

\begin{code}
`.`(a, `.`(b, `[]`))
\end{code}

This modification has minimal impact on typical Prolog code. It does
affect foreign code (see \secref{foreign}) that uses the normal atom and
compound term interface for manipulation lists. In most cases this can
be avoided by using the dedicated list functions. For convenience, the
macros \const{ATOM_nil} and \const{ATOM_dot} are provided by
\file{SWI-Prolog.h}.

Another place that is affected is write_canonical/1. Impact is minimized
by using the list syntax for lists.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax changes}
\label{sec:ext-syntax}

\subsection{Operators and quoted atoms}
\label{sec:ext-syntax-op}

As of SWI-Prolog version~7, quoted atoms loose their operator property.

\subsection{Compound terms with zero arguments}
\label{sec:ext-compound-zero}

As of SWI-Prolog version~7, the system supports compound terms that have
no arguments. This implies that e.g., \exam{name()} is valid syntax.
This extension aims at functions on maps (see \secref{maps}) as well as
the implementation of domain specific languages (DSLs). To minimise the
consequences, the classical predicates functor/3 and =../2 have not been
modified. The predicates compound_name_arity/3 and
compound_name_arguments/3 have been added. These predicates operate only
on compound terms and behave consistently for compounds with zero
arguments.  Code that \jargon{generalises} a term using the sequence
below should generally be changed to use compound_name_arity/3.

\begin{code}
    ...,
    functor(Specific, Name, Arity),
    functor(General, Name, Arity),
    ...,
\end{code}

Replacement of =../2 by compound_name_arguments/3 is typically needed
to deal with code that follow the skeleton below.

\begin{code}
    ...,
    Term0 =.. [Name|Args0],
    maplist(convert, Args0, Args),
    Term =.. [Name|Args],
    ...,
\end{code}

For predicates, goals and arithmetic functions (evaluable terms), <name>
and <name>() are \emph{equivalent}. Below are some examples that
illustrate this behaviour.

\begin{code}
go() :- format('Hello world~n').

?- go().
Hello world

?- go.
Hello world

?- Pi is pi().
Pi = 3.141592653589793.

?- Pi is pi.
Pi = 3.141592653589793.
\end{code}
