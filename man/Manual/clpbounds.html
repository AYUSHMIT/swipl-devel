<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog 5.6.17 Reference Manual: Section A.13</TITLE><LINK REL=home HREF="index.html">
<LINK REL=contents HREF="Contents.html">
<LINK REL=index HREF="DocIndex.html">
<LINK REL=previous HREF="url.html">
<LINK REL=next HREF="clpqr.html">
<style type="text/css"> 
dd.defbody 
{ margin-bottom: 1em; 
}

dt.pubdef 
{ background-color: #c5e1ff; 
}

pre.code 
{ margin-left: 1.5em; 
margin-right: 1.5em; 
border: 1px dotted; 
padding-top: 5px; 
padding-left: 5px; 
padding-bottom: 5px; 
background-color: #f8f8f8; 
}

div.navigate
{ text-align: center; 
background-color: #f0f0f0; 
border: 1px dotted; 
padding: 5px;
}
</style>
</HEAD>
<BODY BGCOLOR="white"><DIV class="navigate"><A HREF="index.html"><IMG SRC="home.gif" BORDER=0 ALT="Home"></A>
<A HREF="Contents.html"><IMG SRC="index.gif" BORDER=0 ALT="Contents"></A>
<A HREF="DocIndex.html"><IMG SRC="yellow_pages.gif" BORDER=0 ALT="Index"></A>
<A HREF="url.html"><IMG SRC="prev.gif" BORDER=0 ALT="Previous"></A>
<A HREF="clpqr.html"><IMG SRC="next.gif" BORDER=0 ALT="Next"></A>
</DIV>

<H2><A NAME="sec:A.13">A.13 library( clp/bounds ): Integer Bounds 
Constraint Solver</A></H2>

<A NAME="clp/bounds"></A>

<P>Author: <EM>Tom Schrijvers</EM>, K.U.Leuven

<P>The bounds solver is a rather simple integer constraint solver, 
implemented with attributed variables. Its syntax is a subset of the 
SICStus clp(FD) syntax. Please note that the <CODE>library(clp/bounds)</CODE> 
library is <EM>not</EM> an
<EM>autoload</EM> library and therefore this library must be loaded 
explicitely before using it using:

<PRE class="code">
:- use_module(library('clp/bounds')).
</PRE>

<H3><A NAME="sec:A.13.1">A.13.1 Constraints</A></H3>

The following constraints are supported:

<DL>
<DT class="pubdef"><A NAME="in/2"><VAR>-Var</VAR> <STRONG>in</STRONG> <VAR>+Range</VAR></A></DT>
<DD class="defbody">
Varibale <VAR>Var</VAR> is restricted to be in range <VAR>Range</VAR>. A 
range is denoted by <TT>L..U</TT> where both <VAR>L</VAR> and <VAR>U</VAR> 
are integers.
</DD>
<DT class="pubdef"><A NAME="in/2"><VAR>-Vars</VAR> <STRONG>in</STRONG> <VAR>+Range</VAR></A></DT>
<DD class="defbody">
A list of variables <VAR>Vars</VAR> are restriced to be in range
<VAR>Range</VAR>.
</DD>
<DT class="pubdef"><A NAME="tuples_in/2"><STRONG>tuples_in</STRONG>(<VAR>+Tuples, 
+Extension</VAR>)</A></DT>
<DD class="defbody">
Where <VAR>Tuples</VAR> is a list of tuples (lists) of variables and 
integers, each of length&nbsp;<VAR>N</VAR>, and <VAR>Extension</VAR> is 
a list of tuples of integers, each of length&nbsp;<VAR>N</VAR>. Each 
tuple of
<VAR>Tuples</VAR> is constrained to be in the relation defined by <VAR>Extension</VAR>. 
See <A HREF="clpbounds.html">section A.13.4</A> for an example.
</DD>
<DT class="pubdef"><A NAME="#>/2"><VAR>?Expr</VAR> <STRONG>#&gt;</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The left-hand expression is constrained to be greater than the 
right-hand expressions.
</DD>
<DT class="pubdef"><A NAME="#</2"><VAR>?Expr</VAR> <STRONG>#&lt;</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The left-hand expression is constrained to be smaller than the 
right-hand expressions.
</DD>
<DT class="pubdef"><A NAME="#>=/2"><VAR>?Expr</VAR> <STRONG>#&gt;=</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The left-hand expression is constrained to be greater than or equal to 
the right-hand expressions.
</DD>
<DT class="pubdef"><A NAME="#=</2"><VAR>?Expr</VAR> <STRONG>#=&lt;</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The left-hand expression is constrained to be smaller than or equal to 
the right-hand expressions.
</DD>
<DT class="pubdef"><A NAME="#=/2"><VAR>?Expr</VAR> <STRONG>#=</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The left-hand expression is constrained to be equal to the right-hand 
expressions.
</DD>
<DT class="pubdef"><A NAME="#\=/2"><VAR>?Expr</VAR> <STRONG>#\=</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The left-hand expression is constrained to be not equal to the 
right-hand expressions.
</DD>
<DT class="pubdef"><A NAME="sum/3"><STRONG>sum</STRONG>(<VAR>+Vars,+Op,?Value</VAR>)</A></DT>
<DD class="defbody">
Here <VAR>Vars</VAR> is a list of variables and integers,
<VAR>Op</VAR> is one of the binary constraint relation symbols above and <VAR>Value</VAR> 
is an integer or variable. It represents the constraint (<VAR>&Sigma;</VAR><VAR>Vars</VAR>) <VAR>Op</VAR> <VAR>Value</VAR>.
</DD>
<DT class="pubdef"><A NAME="lex_chain/1"><STRONG>lex_chain</STRONG>(<VAR>+VarsLists</VAR>)</A></DT>
<DD class="defbody">
The constraint enforces lexicographic ordering on the lists in the 
argument. The argument <VAR>Vars</VAR> is a list of lists of variables 
and integers. The current implementation was contributed by Markus 
Triska.
</DD>
<DT class="pubdef"><A NAME="all_different/1"><STRONG>all_different</STRONG>(<VAR>+Vars</VAR>)</A></DT>
<DD class="defbody">
Constrains all variabls in the list <VAR>Vars</VAR> to be pairwise not 
equal.
</DD>
<DT class="pubdef"><A NAME="indomain/1"><STRONG>indomain</STRONG>(<VAR>+Var</VAR>)</A></DT>
<DD class="defbody">
Assigns a value in its domain to variable <VAR>Var</VAR>. Backtracks 
over all possible values from lowest to greatest. Contributed by Markus 
Triska.
</DD>
<DT class="pubdef"><A NAME="label/1"><STRONG>label</STRONG>(<VAR>+Vars</VAR>)</A></DT>
<DD class="defbody">
All variables are assigned a variable that does not violate the 
constraint on them.
</DD>
</DL>

<P>Here <VAR>Expr</VAR> can be one of

<DL>
<DT><B>integer</B></DT>
<DD>
Any integer.
</DD>
<DT><B>variable</B></DT>
<DD>
A variable.
</DD>
<DT class="pubdef"><A NAME="+/2"><VAR>?Expr</VAR> <STRONG>+</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The sum of two expressions.
</DD>
<DT class="pubdef"><A NAME="*/2"><VAR>?Expr</VAR> <STRONG>*</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The product of two expressions.
</DD>
<DT class="pubdef"><A NAME="-/2"><VAR>?Expr</VAR> <STRONG>-</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The difference of two expressions.
</DD>
<DT class="pubdef"><A NAME="max/2"><STRONG>max</STRONG>(<VAR>?Expr,?Expr</VAR>)</A></DT>
<DD class="defbody">
The maximum of two expressions.
</DD>
<DT class="pubdef"><A NAME="min/2"><STRONG>min</STRONG>(<VAR>?Expr,?Expr</VAR>)</A></DT>
<DD class="defbody">
The minimum of two expressions.
</DD>
<DT class="pubdef"><A NAME="mod/2"><VAR>?Expr</VAR> <STRONG>mod</STRONG> <VAR>?Expr</VAR></A></DT>
<DD class="defbody">
The first expression modulo the second expression.
</DD>
<DT class="pubdef"><A NAME="abs/1"><STRONG>abs</STRONG>(<VAR>?Expr</VAR>)</A></DT>
<DD class="defbody">
The absolute value of an expression.
</DD>
</DL>

<H3><A NAME="sec:A.13.2">A.13.2 Constraint Implication and Reified 
Constraints</A></H3>

The following constraint implication predicates are available:

<DL>
<DT class="pubdef"><A NAME="#=>/2"><VAR>+P</VAR> <STRONG>#=&gt;</STRONG> <VAR>+Q</VAR></A></DT>
<DD class="defbody">
<VAR>P</VAR> implies <VAR>Q</VAR>, where <VAR>P</VAR> and <VAR>Q</VAR> 
are reifyable constraints.
</DD>
<DT class="pubdef"><A NAME="#<=/2"><VAR>+Q</VAR> <STRONG>#&lt;=</STRONG> <VAR>+P</VAR></A></DT>
<DD class="defbody">
<VAR>P</VAR> implies <VAR>Q</VAR>, where <VAR>P</VAR> and <VAR>Q</VAR> 
are reifyable constraints.
</DD>
<DT class="pubdef"><A NAME="#<=>/2"><VAR>+P</VAR> <STRONG>#&lt;=&gt;</STRONG> <VAR>+Q</VAR></A></DT>
<DD class="defbody">
<VAR>P</VAR> and <VAR>Q</VAR> are equivalent, where <VAR>P</VAR> and <VAR>Q</VAR> 
are reifyable constraints.
</DD>
</DL>

<P>In addition, instead of being a reifyable constraint, either <VAR>P</VAR> 
or
<VAR>Q</VAR> can be a boolean variable that is the truth value of the 
corresponding constraint.

<P>The following constraints are reifyable: <A HREF="clpbounds.html##=/2">#=/2</A>,
<A HREF="clpbounds.html##\=/2">#\=/2</A>, <A HREF="clpbounds.html##</2">#&lt;/2</A>, <A HREF="clpbounds.html##>/2">#&gt;/2</A>, <A HREF="clpbounds.html##=</2">#=&lt;/2</A>,
<A HREF="clpbounds.html##>/2">#&gt;/2</A>.

<P>For example, to count the number of occurrences of a particular value 
in a list of constraint variables:
<UL>
<LI><I>Using constraint implication</I><BR>

<PRE class="code">
occurrences(List,Value,Count) :-
        occurrences(List,Value,0,Count).

occurrences([],_,Count,Count).
occurrences([X|Xs],Value,Acc,Count) :-
        X #= Value  #=&gt; NAcc #= Acc + 1,
        X #\= Value #=&gt; NAcc #= Acc,
        occurrences(Xs,Value,NAcc,Count).
</PRE>

<P>
<LI><I>Using reified constraints</I><BR>

<PRE class="code">
occurrences(List,Value,Count) :-
        occurrences(List,Value,0,Count).

occurrences([],_,Count,Count).
occurrences([X|Xs],Value,Acc,Count) :-
        X #= Value #=&gt; B,
        NAcc #= Acc + B,
        occurrences(Xs,Value,NAcc,Count).
</PRE>

<P>
</UL>

<H3><A NAME="sec:A.13.3">A.13.3 Example 1: Send+More=Money</A></H3>

The following is an implementation of the classic alphametics puzzle 
SEND + MORE = MONEY:

<PRE class="code">
:- use_module(library('clp/bounds')).

send([[S,E,N,D], [M,O,R,E], [M,O,N,E,Y]])  :-
              Digits   =  [S,E,N,D,M,O,R,Y],
              Carries  =  [C1,C2,C3,C4],
              Digits  in  0..9,
              Carries in  0..1,

              M                #=              C4,
              O  +  10  *  C4  #=  M  +  S  +  C3,
              N  +  10  *  C3  #=  O  +  E  +  C2,
              E  +  10  *  C2  #=  R  +  N  +  C1,
              Y  +  10  *  C1  #=  E  +  D,

              M  #&gt;=  1,
              S  #&gt;=  1,
              all_different(Digits),
              label(Digits).
</PRE>

<H3><A NAME="sec:A.13.4">A.13.4 Example 2: Using tuples_in for a train 
schedule</A></H3>

<A NAME="sec:ex:tuplesin"></A>

<P>This example demonstrates <A NAME="idx:tuplesin2:1397"></A><A HREF="clpbounds.html#tuples_in/2">tuples_in/2</A>. 
A train schedule is represented as a list&nbsp;<VAR>Ts</VAR> of 
quadruples, denoting departure and arrival places and times for each 
train. The <EM>path/3</EM> predicate given below constrains&nbsp;<VAR>Ps</VAR> 
to a feasible journey from&nbsp;<VAR>A</VAR> to&nbsp;<VAR>D</VAR> via 3&nbsp;trains 
that are part of the given schedule.

<PRE class="code">
:- use_module(library(bounds)).

schedule(Ts) :-
        Ts = [[1,2,0,1],[2,3,4,5],[2,3,0,1],[3,4,5,6],[3,4,2,3],[3,4,8,9]].

path(A, D, Ps) :-
        schedule(Ts),
        Ps = [[A,B,_T0,T1],[B,C,T2,T3],[C,D,T4,_T5]],
        tuples_in(Ps, Ts),
        T2 #&gt; T1,
        T4 #&gt; T3.
</PRE>

<P>An example query:

<PRE class="code">
?- path(1, 4, Ps), flatten(Ps, Vars), label(Vars).

Ps = [[1, 2, 0, 1], [2, 3, 4, 5], [3, 4, 8, 9]]
</PRE>

<H3><A NAME="sec:A.13.5">A.13.5 SICStus clp(FD) compatibility</A></H3>

Apart from the limited syntax, the bounds solver differs in the 
following ways from the SICStus clp(FD) solver:

<P>
<UL>
<LI><I><TT>inf</TT> and <TT>sup</TT></I><BR>
The smallest lowerbound and greatest upperbound in bounds are
<TT>max_integer</TT> and <TT>min_integer + 1</TT>.
</UL>
</BODY></HTML>