\chapter{SWI-Prolog extensions}
\label{sec:extensions}

This chapter describes extensions to the Prolog language introduced with
SWI-Prolog version~7. The changes bring more modern syntactical
conventions to Prolog such as key-value maps as primary citizens and a
restricted form of \jargon{functional notation}. They also extend Prolog
basic types with strings and reserved constants, which allows
distinguishing terms generated by \jargon{syntaxtic sugar} from ordinary
terms.  In particular lists and strings can be detected unambiguously at
runtime.

These extensions make the syntax more intuitive to new users, simplify
the integration of domain specific languages (DSLs) and facilitate a
more natural Prolog representation for popular exchange languages such
as XML and JSON.

While many programs run unmodified in SWI-Prolog version~7, especially
those that pass double quoted strings to general purpose list processing
predicates require modifications. We provide a tool (list_strings/0)
that we used to port a huge code base in half a day.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reserved constants}
\label{sec:ext-constants}

SWI-Prolog introduces constants that are distinct from the usual Prolog
atoms and numbers. These are introduced because text is commonly
represented using atoms. For example, a natural language parser
typically represents the input text as a list of words and punctuation
characters, where each of these is represented as an atom. At the same
time, Prolog is a dynamically typed language. This feature allows for
heterogeneous data representations that can be tested and acted on at
runtime. In particular, various predicates accept both a single item or
a list of items, e.g., load_files/2. As a result, the call
\exam{load_files([], [])} is \emph{ambiguous}, as it may mean `load no
files' or `load the file named \verb$"[]"$. Similar problems arise with
predicates that overload input text as either an atom or a list of
character codes, where \exam{[]} can both refer to the text \verb$"[]"$
(processed as an atom) or the empty string (processed as a list of
character codes).

The \textbf{syntax} for such constants is a string between \emph{back
quotes}. Backquoted constants are considered \emph{atomic} (see
atomic/1) but not atoms (see atom/1).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Lists are special}
\label{sec:ext-lists}

SWI-Prolog lists can be distinguished unambiguously at runtime from
both ordinary compound terms and the atom \const{'[]'} using the
reserved constants introduced in \secref{ext-constants}.  The
list \exam{[a,b]} is represented as the term below.

\begin{code}
`.`(a, `.`(b, `[]`))
\end{code}

This modification has minimal impact on typical Prolog code. It does
affect foreign code (see \secref{foreign}) that uses the normal atom and
compound term interface for manipulation lists. In most cases this can
be avoided by using the dedicated list functions. For convenience, the
macros \const{ATOM_nil} and \const{ATOM_dot} are provided by
\file{SWI-Prolog.h}.

Another place that is affected is write_canonical/1. Impact is minimized
by using the list syntax for lists.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax changes}
\label{sec:ext-syntax}

\subsection{Operators and quoted atoms}
\label{sec:ext-syntax-op}

As of SWI-Prolog version~7, quoted atoms loose their operator property.

\subsection{Compound terms with zero arguments}
\label{sec:ext-compound-zero}

As of SWI-Prolog version~7, the system supports compound terms that have
no arguments. This implies that e.g., \exam{name()} is valid syntax.
This extension aims at functions on maps (see \secref{maps}) as well as
the implementation of domain specific languages (DSLs). To minimise the
consequences, the classical predicates functor/3 and =../2 have not been
modified. The predicates compound_name_arity/3 and
compound_name_arguments/3 have been added. These predicates operate only
on compound terms and behave consistently for compounds with zero
arguments.  Code that \jargon{generalises} a term using the sequence
below should generally be changed to use compound_name_arity/3.

\begin{code}
    ...,
    functor(Specific, Name, Arity),
    functor(General, Name, Arity),
    ...,
\end{code}

Replacement of =../2 by compound_name_arguments/3 is typically needed
to deal with code that follow the skeleton below.

\begin{code}
    ...,
    Term0 =.. [Name|Args0],
    maplist(convert, Args0, Args),
    Term =.. [Name|Args],
    ...,
\end{code}

For predicates, goals and arithmetic functions (evaluable terms), <name>
and <name>() are \emph{equivalent}. Below are some examples that
illustrate this behaviour.

\begin{code}
go() :- format('Hello world~n').

?- go().
Hello world

?- go.
Hello world

?- Pi is pi().
Pi = 3.141592653589793.

?- Pi is pi.
Pi = 3.141592653589793.
\end{code}


\subsection{Double quoted strings}
\label{sec:ext-dquotes}

As of SWI-Prolog version~7, text encloses in double quotes (e.g.,
\verb$"Hello world"$) is read as a string object as defined in
\secref{strings}.  \Secref{ext-dquotes-motivation} motivates this
choice.  The predicates below can help adapting your program to
this new convention. We have adapted a huge code base with which
we were not familiar in about half a day.

\begin{description}
    \predicate{list_strings}{0}{}
This predicate may be used to make your program compatible with the
representation of double quoted text as string objects. See
\secref{sec:ext-dquotes} and \secref{ext-dquotes-motivation}.  To
use it, load your program into Prolog and run list_strings/0.  The
predicate lists source locations of string objects encountered in
the program that are not considered safe.  Such string need to be
examined manually, after which one of the actions below may be
appropriate:

\begin{itemize}
    \item Rewrite the code.  For example, change  \verb$[X] = "a"$
          into \verb$X = 0'a$.
    \item If a particular module relies on heavily on representing
          strings as lists of character code, consider adding the
	  following directive to the module.  Note that this flag
	  only applies to the module in which it appears.

	  \begin{code}
	  :- set_prolog_flag(double_quotes, codes).
	  \end{code}
    \item If the strings appear in facts and this is safe, add a
          clause to the multifile predicate check:string_predicate/1.
    \item If the strings appear as an argument to a predicate that
          can deal with them, add a
          clause to the multifile predicate check:valid_string_goal/1.
\end{itemize}

    \predicate{check:string_predicate}{1}{:PredicateIndicator}
Declare that \arg{PredicateIndicator} has clauses that contain strings,
but that this is safe.  Fo example:

\begin{code}
:- multifile check:string_predicate/1.

string_predicate(user:help_info/2).
\end{code}

    \predicate{check:valid_string_goal}{1}{:Goal}
Declare that calls to \arg{Goal} are safe.  The module qualification
is the actual module in which \arg{Goal} is defined.  For example, a
call to format/3 is resolved by the predicate system:format/3. and
the code below specifies that the second argument may be a string
(system predicates that accept strings are defined in the library).

\begin{code}
:- multifile check:valid_string_goal/1.

check:valid_string_goal(system:format(_,S,_)) :- string(S).
\end{code}
\end{description}


\subsubsection{Why has the representation of double quoted text changed?}
\label{sec:ext-dquotes-motivation}

Prolog defines two forms of quoted text. Traditionally, single quoted
text is mapped to atoms while double quoted text is mapped to a list of
\jargon{character codes} (integers) or characters represented as
1-character atoms. Representing text in atoms is often considered
inadequate for several reasons:

\begin{itemize}
    \item It hides the conceptual difference between a text and a
          program symbol.  Where content of text often matters because
	  it is used in I/O, program symbols are merely identifiers
	  that match with the same symbol elsewhere. Program symbols
	  can often be consistently replaced, for example to obfuscate
	  or compact a program.

    \item Atoms are globally unique identifiers.  They are stored
          in a shared table.  Volatile strings represented as atoms
	  come at a significant price due to the required cooperation
	  between threads. Getting rid of temporary atoms
	  using \jargon{Atom garbage collection} is a costly process
	  that requires significant synchronisation.

    \item Many Prolog systems (not SWI-Prolog) put severe restrictions
          on the length of atoms or the maximum number of atoms.
\end{itemize}

Representing text as a list of character codes or 1-character atoms
also comes at a price:

\begin{itemize}
    \item It is not possible to distinguish (at runtime) a list of
          integers or atoms from a string.  Sometimes this information
	  can be derived from (implicit) typing.  In other cases the
	  list must be embedded in a compound term to distinguish
	  the two types.  For example, \verb$s("hello world")$ could
	  be used to indicate that we are dealing with a string.

	  Lacking runtime information, debuggers and the toplevel can
	  only use heuristics to decide whether to print a list of
	  integers as such or as a string (see portray_text/1).

	  While experienced Prolog programmers have learned to cope
	  with this, we still consider this an unfortunate situation.

    \item Lists are expensive structures, taking 2 words per character
          (3 for SWI-Prolog in its current form).  This stresses memory
	  consumption on the stacks while pushing them on the stack and
	  dealing with them during garbage collection is expensive.
\end{itemize}

We observed that in many programs, most strings are only handled as a
single unit during their lifetime. Examining real code tells us that
double quoted strings typically appear in one of the following roles:

\begin{description}
    \item [ A DCG literal ]  The DCG translator can recognise the
literal and convert it to the proper representation. Such code need not
be modified.

    \item [ A format string ]  This is a typical example of text that
is conceptually not a program identifier.  Format is designed to deal
with alternative representations of the format string.  Such code
need not be modified.

    \item [ Getting a character code ] The construct \verb$[X] = "a"$
is a commonly used template for getting the character code of the
letter 'a'.  ISO Prolog defines the syntax \verb$0'a$ for this purpose.
Code using this must be modified.  The modified code will run on any
ISO compliant processor.

    \item [ As argument to list predicates to operate on strings ]
Here, we see code such as \verb$append("name:", Rest, Codes)$.  Such
code needs to be modified.  In this particular example, the
following is a good portable alternative: \verb$phrase("name:", Codes, Rest)$
\end{description}

We offer the predicate list_strings/0 to help porting your program.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Maps: structures with named arguments}
\label{sec:ext-maps}

SWI-Prolog version~7 introduces maps as an abstract object with a
concrete modern syntax and functional notation for accessing members.
The syntax for a map is illustrated below. \arg{Class} is either a
variable or an atom. As with compound terms, there is \textbf{no} space
between the class and the opening brace. The keys are either atoms or
small integers (up to \prologflag{max_tagged_integer}). The values are
arbitrary Prolog terms which are parsed using the same rules as used for
arguments in compound terms.

\begin{quote}
Class{Key1:Value1, Key2:Value2, ...}
\end{quote}

A map cannot hold duplicate keys. The map is transformed into an opaque
internal representation that does \emph{not} respect the order in which
the key value pairs appear in the input text. If a map is written, the
keys are written according to the standard order of terms (see
\secref{standardorder}). Here are some examples, where the second
example illustrates that the order is not maintained and the third
illustrates an anonymous map.

\begin{code}
?- A = point{x:1, y:2}.
A = point{x:1, y:2}.

?- A = point{y:2, x:1}.
A = point{x:1, y:2}.

?- A = _{first_name:"Mel", last_name:"Smith"}.
A = _G1476{first_name:"Mel", last_name:"Smith"}.
\end{code}

Maps can be unified following the standard symmetric Prolog unification
rules. As maps use an internal canonical form, the order in which the
named keys are represented is not relevant. This behaviour is
illustrated by the following example.

\begin{code}
?- point{x:1, y:2} = Class{y:2, x:X}.
Class = point,
X = 1.
\end{code}


\subsection{Functions on maps}
\label{sec:ext-map-functions}

The infix operator dot (.) is used to extract values and evaluate
functions on maps. Functions are recognised if they appear in the
argument of a \jargon{goal} in the source text.  The keys act as
field selector, which is illustrated in this example.

\begin{code}
?- X = point{x:1,y:2}.x.
X = 1.

?- X = point{x:1,y:2}.C.
X = 1,
C = x ;
X = 2,
C = y.
\end{code}

The class of a map associates the map to a module.  If the dot
notation uses a compound term, this calls the goal below.

\begin{quote}
<module>:<name>(Arg1, ..., +Map, -Value)
\end{quote}

Functions are normal Prolog predicates. The map infrastructure provides
a more convenient syntax for representing the head of such predicates
comfortably. The code below defines a function \term{multiply}{Times} on
a point that creates a new point by multiplying both coordinates. and
\term{len}{}\footnote{as \term{length}{} would result in a predicate
length/2, this name cannot be used. This might change in future
versions} to compute the length from the origin. The . and \verb$=>$
operators are used to abstract the location of the predicate arguments.
It is allowed to define multiple a function with multiple clauses,
providing overloading and non-determinism.

\begin{code}
:- module(point, []).

M.multiply(F) => point{x:X, y:Y} :-
	X is M.x*F,
	Y is M.y*F.

M.len() => Len :-
	Len is sqrt(M.x**2 + M.y**2).
\end{code}

After these definitions, we can evaluate the following functions:

\begin{code}
?- X = point{x:1, y:2}.multiply(2).
X = point{x:2, y:4}.

?- X = point{x:1, y:2}.multiply(2).len().
X = 4.47213595499958.
\end{code}

\subsubsection{Reserved functions on maps}
\label{sec:ext-maps-reserved}

Maps currently define the following reserved functions:

\begin{description}
    \mapfunction{put}{1}{+New}
Evaluates to a new map where the key-values in \arg{New} replace
or extend the key-values in the original map.  See put_map/3.

    \mapfunction{put}{2}{+Key, +Value}
Evaluates to a new map where the \arg{Key}-\arg{Value} replaces
or extends the key-values in the original map.  See put_map/4.
\end{description}


\subsection{Predicates for managing maps}
\label{ext-map-predicates}

\begin{description}
    \predicate{is_map}{2}{@Term, -Class}
True if \arg{Term} is a map of \arg{Class}.

    \predicate{get_map}{3}{?Key, +Map, -Value}
Unify the value associated with \arg{Key} in map with \arg{Value}.  If
\arg{Key} is unbound, all associations in \arg{Map} are returned on
backtracking.  The order in which the associations are returned is
undefined.  This predicate is normally accessed using the functional
notation \exam{Map.Key}.  See \secref{ext-map-functions}.

    \predicate{map_create}{3}{-Map, +Class, +Data}
Create a map in \arg{Class} from \arg{Data}. \arg{Data} is a list of
attribute-value pairs using the syntax \exam{Key:Value},
\exam{Key=Value}, \exam{Key-Value} or \exam{Key(Value)}. An exception is
raised if \arg{Data} is not a proper list, one of the elements is not of
the shape above, a key is neither an atom nor a small integer or there
is a duplicate key.

    \predicate{put_map}{3}{+New, +MapIn, -MapOut}
\arg{MapOut} is a new map created by replacing or adding key-value pairs
from \arg{New} to \arg{Map}. \arg{New} is either a map or a valid input
for map_create/3. This predicate is normally accessed using the
functional notation. Below are some examples:

\begin{code}
?- A = point{x:1, y:2}.put(_{x:3}).
A = point{x:3, y:2}.

?- A = point{x:1, y:2}.put([x=3]).
A = point{x:3, y:2}.

?- A = point{x:1, y:2}.put([x=3,z=0]).
A = point{x:3, y:2, z:0}.
\end{code}

    \predicate{put_map}{4}{+Key, +MapIn, +Value, -MapOut}
\arg{MapOut} is a new map created by replacing or adding
\arg{Key}-\arg{Value} to \arg{MapIn}. This predicate is normally
accessed using the functional notation. Below is an example:

\begin{code}
?- A = point{x:1, y:2}.put(x, 3).
A = point{x:3, y:2}.
\end{code}
\end{description}


\subsection{A motivation for maps as primary citizens}
\label{sec:ext-maps-motivation}

Maps, or key-value associations, are a common data structure. A good old
example are \jargon{property lists} as found in Lisp, while a good
recent example is formed by JavaScript \jargon{objects}. Traditional
Prolog does not offer native properly lists. As a result, people are
using a wide range of data structures for key-value associations:

\begin{itemize}
    \item Using compound terms and positional arguments.
    \item Using compound terms with library \pllib{record}.
    \item Using lists of terms \exam{Name=Value}, \exam{Name-Value},
          \exam{Name:Value} or \exam{Name(Value)}.
    \item Using library \pllib{assoc} which represents the
          associations as a balanced binary tree.
\end{itemize}

This situation is unfortunate. Each of these have their advantages and
disadvantages. E.g., compound terms are compact and fast, but inflexible
and using positional arguments quickly breaks down. Library
\pllib{record} fixes this, but the syntax is considered hard to use.
Lists are flexible, but expensive and the alternative key-value
representation complicate the matter even more. Library \pllib{assoc}
allows for efficient manipulation of changing associations, but the
syntactical representation of an assoc is complex, which makes them
unsuitable for e.g., \jargon{options lists} as seen in predicates such
as write_term/3.
