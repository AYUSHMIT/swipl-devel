\chapter{Development and debugging tools}	\label{sec:debugging}

This section describes various tools and techniques to help finding
bugs in PCE/Prolog code.  Prolog provides an interactive program
development environment.  PCE provides a dynamic object-oriented
environment that may be inspected, traced and modified during
execution.  Unlike Prolog, PCE almost exclusively manipulates
static information.  This limits the possibilities for interactive
manipulation of the environment.  For example, you cannot {\em undo}
operations in PCE, change the program and redo the goal as you can
in Prolog.

Unlike Prolog, PCE is not {\em secure}: if a Prolog environment traps
a fatal error there is almost always a bug in the Prolog system.
Except for violating system limits there is no Prolog program that can
make the Prolog environment crash.  For PCE this is different.
Consider the following example:

\begin{code}
1 ?- new(@p, picture),
     send(@p, display, new(B, box(100,100))),
     get(B, area, Area),
     free(Area).

Area = @ 803438, B = @803419/box
\end{code}

After this action the area attribute of the box has been destroyed,
but the box is not aware of this fact.  The utility predicate
checkpce/0 scans the PCE object-base for various inconsistencies and
will report that the box contains a slot referring to a freed object.

\begin{code}
2 ?- checkpce.

WARNING: Freed object in slot area of @803419/box: @803438/area
PCE: Checked 13173 objects
\end{code}

PCE uses heuristics trying to avoid that such problems actually
crash the system (in the example above execution continues
normally).

\section{The PCE tracer}

The PCE tracer allows both for interactive execution as for printing
the entry and/or completion of operations.  This section first
introduces some common ways the exploit the tracer.
Section~\ref{sec:tracemodel} discusses the underlying concepts.
The end of this section provides examples of advanced queries to the
tracer such as conditional trace- and break-points.

\subsection{Simple examples}

\subsubsection{Inspection execution}

The execution of the virtual-machine instructions may be inspected
using:

\begin{code}
1 ?- send(class(vmi), trace, @on).
[ 1] exit: send(@vmi_class/class, trace, @on/bool)

2 ?- new(@v, view).
[ 1] enter: new(view)
[ 1] exit: new(view) --> @v/view
\end{code}


\subsubsection{Tracing behaviour execution}

It is often useful to inspect the execution of a particular method.
Suppose we'd like to monitor geometry-changes of graphical objects.
The utility predicate tracepce/1 (see also section~\ref{sec:interface})
may be used:

\begin{code}
1 ?- tracepce(graphical->geometry).
Trace method: graphical ->geometry
\end{code}

\subsubsection{Breaking on certain operations}.

According to PCE's model the {\em new} operation is allowed to fail
silently.  In many cases however, failing new operations is an error.
Suppose you want the system to trap failing new operations and break
execution.

\begin{code}
1 ?- send(@vmi_new, break, @on, fail).
\end{code}

The object @vmi_new represents the virtual machine operation new.  See
section~\ref{sec:vmi}.


\subsection{Inspecting the context of errors}

Whenever an error is detected of <-kind `warning' and the <-feedback
equals `print' the error will be printed, after which an {\em
exception} flag is placed on the current goal and the tracer is
switched on in `user' mode.  This will cause the tracer to `break'
at the `fail' port of the operation that generated the error.

The tracer may now be used to examine the execution context of the
error.  The following example illustrates this

\begin{code}
bug :-
	new(P, picture),
	new(B, list_browser),
	send(P, below, B),
	send(B, open).

1 ?- bug.
[PCE warning: window ->below: Argument 1 should be a window
        in: M @922496/picture(window) ->below: @922729/list_browser]
[ 2] fail: M @922496/picture(window) ->below: @922729/list_browser ? 
\end{code}

The warning indicates a method has been invoked whose first argument
should be a window object.  The ``in:'' line shows the top of the
goal-stack.  The line starting ``[2]'' is the PCE tracer.  In such
a situation the following tracer options are useful to find the
context of the error:

\begin{itemize}
    \tick{{\bf g[ahC] [depth]}: Goals}
Print the stack.  By default it prints the `user' goals of PCE's stack
of active messages.  With the `{\bf a}lways' modifier it also prints
the internal (system) messages.  With the `{\bf h}ost' modifier it will
print the Prolog stack.  Finally, with the `{\bf C}' modifier it will
print PCE's C-function stack.%
    \footnote{Printing the C-stack is only supported for the SPARC
	      and MC680x0 processors.  Interpretation of the C-stack
	      is generally hard for normal users.}
The optional `depth' argument specifies the number of frames printed.
    \tick{{\bf b}: Break}
Start a recursive interactive Prolog toplevel (as the Prolog predicate
break/0).  This may be used to get information on the status of the
object base, Prolog program, etc.
    \tick{{\bf t}: Trace}
Disable the PCE tracer and start the Prolog tracer.  This will cause
execution to continue until control reaches Prolog again, after which
the Prolog tracer may be used to examine the Prolog context of the
error.
    \tick{{\bf n}: Nodebug}
Continue execution.  Note that the current message will fail.  Note that
some methods do not anticipate failure of sending a message.  In these
cases the system will behave unpredictably.
\end{itemize}


\subsection{The trace model}			\label{sec:tracemodel}

All objects of PCE's program-world (classes, methods, messages, etc.)
are subclasses of class \class{program_object} which defines the
manipulation of the tracer.  Except for classes, whose role is
explained later, all program objects represent an `operation'.  For
example, a method may be invokes and an instance variable may be
assigned to.


\subsubsection{Goals}

When a program-object is executed, we distinguish three `ports': {\em
enter} when the operation is started; {\em exit} when the execution is
terminated successfully and {\em fail} when the execution is
terminated with failure.

The tracer associates a {\em goal} with the execution of a
program-object.  A new goal is created and pushed on the {\em
goal-stack} when the execution of a program-object is started
(entered).  After completion of the execution this goal is popped from
the goal-stack again.  A frame of the goal-stack stores the following
information to facilitate the PCE tracer:

\begin{itemize}
    \tick{object}
The `object' of a goal is the program-object currently executed.
    \tick{receiver}
The `receiver' of a goal is the object manipulated.  This concept
is not clear for all program-objects.  See table~\ref{tab:goalargs}.
    \tick{selector}
The `selector' is the name of the operation performed.  This too
is not evident for all program-objects.  See table~\ref{tab:goalargs}.
    \tick{argument vector}
The context arguments used to execute the program-object.
\end{itemize}


\subsubsection{Trace- and break-points}

Each program-object (except for classes, which cannot be executed) may
be assigned either a trace- or a break-point as well as a trace- or
break-condition.  If the program-object is executed and it has a
trace-point set a message will be printed to indicate entry and
completion of the execution.  If it has a break-point set the
tracer will, after printing the message, stop (`break') the execution.
The user is prompted on how execution is to be continued.

By default, a program-object {\em inherits} its trace- and break-point
from its {\em class}.  Thus, if a trace-point is associated with class
\class{send_method} it is active on all send_method instances, except
for those for which it has been explicitly disabled.  Program-object
classes inherit their trace- and break-points from their super-class.
Thus, associating a trace-point with class \class{program_object}
associates it as a default for all traceable objects.

Both trace- and break-points may be associated a {\em condition}.
This is a code object that is evaluated before the trace- or
break-point is activated.  If the code object fails the goal is not
printed (or execution is not `broken').  The parameters passed
to the code ar listed in table~\ref{tab:goalargs}.

\begin{table}
\begin{center}
\begin{tabular}{|lll|}
\hline
@vmi_send	& @receiver	& Receiver of the message \\
@vmi_get	& @selector	& Selector of the message \\
		& @arg1 ...	& arguments to the message \\
\hline
@vmi_new	& @receiver	& Class to be instantiated \\
		& @selector	& `new' \\
		& @arg1 ...	& arguments to new \\
\hline
@vmi_free	& @receiver	& Object to be freed \\
		& @selector	& `free' \\
\hline
Class code	& @receiver	& Code object executed \\
		& @selector	& `execute' \\
\hline
Class send_method& @receiver	& Receiver of the message \\
Class get_method& @selector	& Selector of the message \\
		& @arg1 ...	& arguments to the message \\
\hline
Class type	& @receiver	& Object to be converted \\
		& @selector	& `convert' \\
\hline
\end{tabular}
\end{center}
	\caption{Context arguments for trace- and break-conditions}
	\label{tab:goalargs}
\end{table}

\subsubsection{The virtual machine operations}	\label{sec:vmi}

The basic operations of PCE (new, send, get and free) are added to
this model by introducing class \class{vmi} with instances @vmi_new,
@vmi_send, @vmi_get and @vmi_free.


\subsubsection{System and user mode of operation}

PCE distinguishes between two modes of operating a goal: system- and
user-mode.  This distinction allows the system to only display goals
that have been specified by the user and hide goals invoked by the
system itself.   All goals are executed in system-mode with the
exception of new-, send-, get- and free-operations started from
Prolog and the execution of program-objects created by the user.

The tracer may be used at three levels: {\em never} implies that
the tracer is not active; {\em user} implies that the tracer is
active on goals executed in user-mode {\em and} goals executed
in system-mode for which there is an explicit trace- or break-point
(i.e. {\em not} an inherited one).  Finally, mode {\em always}
implies that both system- and user-level goals are traced.  The
level of tracing is determined by `@pce ->trace'.


\subsection{Advanced examples}

At the start of this chapter we have introduced some simple ways to
operate the tracer.  In this section we will give more advanced
examples to help finding common problems.


\subsubsection{Tracing event-processing}

A commonly encountered problem is that your application simply
doesn't respond to a specific mouse and/or keyboard operation.
For example you programmed an object to be movable with the
middle-mouse-button; but it does not respond.

The first to verify is whether or not the events arrive there where
you expect them.  When operating the mouse many events are generated
which requires selective printing of goals.  Breaking is not advised
as the mouse is necessary to carry-out the move-gesture and thus
cannot be used to select the trace-window.  To debug event-processing
it is first of all useful to know who processes the events and with
what result.  The following query will print the execution of any
send-operation which selector `event' that is caused by the
middle-down event.

\begin{code}
1 ?- send(@vmi_send, trace, @on, full,
	  and(@selector == event,
	      message(@event, is_a, ms_middle_down))).
\end{code}


\subsubsection{Why does this goal fail?}

Another common problem is that an application that once worked now
suddenly simply fails without any warning.  What may be wrong?
Without any problem-specific hints the most useful start is to
print failing virtual machine instructions:

\begin{code}
1 ?- send(class(vmi), trace, @on, fail).
\end{code}

Now unfortunately this may result is lots of messages because some
operations are designed to test status and succeed or fail according
to the result of the test.  The following will ignore all failing
send-operations whose method summary-string starts with ``Test''.

\begin{code}
2 ?- new(@no_test_method,
	 not(message(?(@receiver, send_method,
	               @selector)?second?summary,
	             prefix, 'Test'))).

3 ?- send(@vmi_send, trace, @on, fail, @no_test_method).
\end{code}

\subsubsection{Status}

The current implementation of the tracer is the result of a redesign
and merging of various tracing possibilities that existed in release
4.4.  Practice should indicate its suitability.  Comments are welcome!


\section{Visual hierarchy tool}		\label{sec:vishierarchy}

\index{hierarchy,of UI components}
The ``Visual Hierarchy'' tool provides an overview of the consists-of
relations between the various UI components in a tool.  It is part of
the online manual tools and may be started from the ``Tool'' entry in
the main dialog.  Figure~\ref{fig:vishierarchy} shows this tool examining
the structure of the ``Ispell'' demo program (see figure~\ref{fig:ispell}).

\postscriptfig{ispell}{The ``Ispell'' demo program}
\postscriptfig{vishierarchy}{Visual Hierarchy Tool}
\index{postscript}

This tool is very useful to examine the structure of existing
applications (for example the various demo programs).  It may also
be used to find object-references and to launch the inspector
(described below) on a particular object.

There are three ways to expand the tree of the visual hierarchy
tool.  The first is to expand the tree from the initially displayed
root object.  The second is to type the reference in the ``Visual''
text_item and press {\sc return}.  The most comfortable way is to position
the mouse in the target object and type {\sc meta-shift-control-V}.%
    \footnote{To remember this sequence: {\bf V} for Visual and all
              defined modifiers to avoid a conflict with application
	      defined key-bindings.}
	      

\section{Inspector tool}		\label{sec:inspector}

The inspector provides a visual representation of all attributes of an
object.  It is a visual form of the debugging predicate show_slots/1
which dumps the class and slot value of the argument reference in
the Prolog window.  The inspector is started from the ``Tools'' entry
of the manual tools.

\postscriptfig{inspector}{Inspector Tool}
\index{object,inspecting}\index{inspector}


\section{Errors}		\label{sec:errors}

Errors are abnormalities that are detected during a program's
execution.  Errors may be caused by internal bugs in PCE, bugs
in the application program and finally by the application user
making errors in operating the application (e.g. specifying
a protected file).

Errors may also be discriminated according to their `seriousness': If
a certain font cannot be found it can easily be substituted by
another.  If a method expects an integer argument but the actual
argument is a graphical object it is impossible to carry-out the
operation.  In such cases PCE will normally trap the tracer. If the
user decides to continue execution the method will return failure to
its caller.  Finally, some problems are categorised as `fatal'.  When
such a problem is encountered PCE does not know how execution may
be continued.

All errors (except for some that may result from PCE bugs during
the boot phase of PCE) are represented by an \class{error} object.
An error object has the following properties:

\begin{itemize}
    \tick{id}
Unique identifier name of the error.  It may be used to generate
errors; look-up error objects in the @errors database or catch
errors (see pce_catch_error/2).
    \tick{kind}
The kind describes how serious the error is considered to be.  Its
possible values are: {\em ignored} if the error is (currently) not
regarded an error at all; {\em message} if the error is to be
reported, but no further action is required; {\em warning} if the
error is to be fixed.  After printing the error the system will
start the tracer, allowing a programmer to examine the problem
context.  Finally, {\em fatal} errors do not allow execution to
be continued.  The system will print context information and
request Prolog to abort back to the Prolog interactive toplevel.
    \tick{feedback}
Determines how the error is to be reported.  If {\em print} the
error is printed in the Prolog window.  If {\em inform} the
error is reported using an informer box.  The latter is intended
for errors that may be caused by application users: file errors
certain types of X-window related errors, etc.
    \tick{format}
A format specification to construct a message text from the
context arguments provided by the generator of the error.
\end{itemize}

\index{error,description of}%
The online manual ``Errors Browser'' may be used to examine the
defined errors; change attributes of errors and get precise
description of errors.


\subsection{Handling errors in the application}

\index{errors,catching}\index{catch,errors}%
Sometimes the application wants to anticipate on certain errors.
Explicit testing of all conditions is a cumbersome solution to this
problem.  Therefore PCE allows catching of errors by the application.
This is supported by the Prolog predicate pce_catch_error/2:

\begin{code}
	...,
	pce_catch_error(backup_file, send(File, backup)),
	...
\end{code}

If the indicated error occurs while the goal of the second argument is
active the PCE goal that raised the error will silently fail and the
attribute `pce <-last_error' is filled with the id of the error
trapped.  This may be used to determine the cause of the error.


\subsection{Raising Errors}

The application programmer may define new (application specific)
errors.  The error object is a normal PCE object and may thus be
created using new/2.  An error is raised by invoking `object ->error'.
The example below illustrates this:

\begin{code}
:- new(_, error(no_user, '%N: Unknown user: %s', warning, inform)).

	...,
	(   get(UserDatabase, user, Name)
	->  ...
	;   send(UserDatabase, error, no_user, Name)
	),
	...
\end{code}

Note that the names of errors should be unique.  It is advised to
reuse existing error-id's when possible.


\subsection{Exceptions}

\idx{exception}
On trapping certain `repairable` errors, PCE will first raise an {\em
exception}.  Exceptions may be trapped by an {\em exception handler}
which may solve the problem.  If the exception-handler fails to solve
the problem, PCE will raise an {\em error}.  See section~
\ref{sec:errors}. 

Exceptions are raised by invoking `@pce ->exception: id, arg ...'.
Exception handlers are registered in the sheet `@pce ->exception_handlers',
which maps an exception-id onto a code object that handles the exception.
The following illustrates this:

\begin{code}
1 ?- [user].
|: add_user(Name) :- write(Name), nl.
^D

2 ?- send(@pce?exception_handlers, value,
          no_user,
	  message(@prolog, add_user, @arg1)).

3 ?- send(@pce, exception, no_user, fred).
fred
\end{code}

The {\em context arguments} passed with an exception are defined by the
code raising the exception.  The currently defined exceptions are
listed below.  See also the online manual: `pce->exception' and
`pce <-exception_handlers'.

\begin{itemize}
    \tick{undefined_class}
\index{class,undefined}\index{undefined,class}%
An attempt is made to reference an non-existing class while
doing one of the following: create an object; load an object from
file using `File <-object'; create a subclass.  The var @arg1
is bound to the class-name.
    \tick{undefined_assoc}
\index{assoc,undefined}\index{undefined,object reference}%
An attempt is made to resolve a symbolic reference (i.e. @pce),
but the reference is unknown.  The var @arg1 is bound to the missing
reference name.
    \tick{redefined_assoc}
\index{assoc,redefined}\index{redefined,object reference}%
An attempt is made to create an object with the same symbolic
reference as an already existing object.  The var @arg1 is bound to the
already existing reference name.
    \tick{initialisation_failed}
\index{new,failed}\index{initialisation,failed}%
The ->initialisation method for some instance failed.  The var @arg1
is bound to the (partial) instance; @arg2, ... are bound the arguments
given to the new-operation.
\end{itemize}

