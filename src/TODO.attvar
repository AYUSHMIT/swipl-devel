Realising attributed variables

Places dealt with:

	* Implemented attvar/1, get_attr/3, put_attr/3 and del_attr/2.
	* Adjusted write/1 to write AttVar{L,G}<N>{Attribute}.  Also deals with
	  looping.
	* Adjusted recorded database (recorda, recorded, findall, ...)
	* checkData to deal with recursive structures.
	* Adjusted the garbage collector
	* standard order of terms

Places to deal with them

	* se_record(): structural equivalence of records
	* shared variables in recorded?  May not be a problem?


		 /*******************************
		 *	      TESTING		*
		 *******************************/

	* Wakeup (I_ENTER, I_EXITFACT, exit_builtin)
	* Avoid copying attvar (always make a reference)
	* Test for attvar in assignment
	* Systematic pass to unify operations:
		unify()
		unifyAtomic()
		H_* instructions
		B_* instructions
		Check trailing?
	* Check undo


		 /*******************************
		 *	   THE WAKE LIST	*
		 *******************************/

	* Using a global variable containing pairs:

		Attribute, Value
		
	  Where Attribute is the format attribute value and Value is the
	  new value of the attributed variable, possibly another attributed
	  variable.

	  	wakeup(A, V, <Tail>)


		 /*******************************
		 *	   AVOID WAKEUP		*
		 *******************************/

	* Some callbacks should *not* do call the wakeup list as their
	  execution does not contribute to the truth result of the
	  computation.  There are two ways out:

		- Save/restore the wakeup list
		- Make sure the wakeup list is processed (i.e. empty).

	  Points requiring attention are:

		- Tracer
		- portray
		- interrupt (Control-C), signals in general
		- event hook.
