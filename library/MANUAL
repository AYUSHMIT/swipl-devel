
                     University of Amsterdam

                        Dept.  of Social
                       Science Informatics

                              (SWI)
                      Roeterstraat 15, 1018
                          WB  Amsterdam
                         The Netherlands
                     Tel.  (+31) 20 5256121

                          SSWWII--PPrroolloogg 33..33

                         RReeffeerreennccee MMaannuuaall
             _U_p_d_a_t_e_d _f_o_r _v_e_r_s_i_o_n _3_._3_._0_, _N_o_v_e_m_b_e_r _1_9_9_9

                          _J_a_n _W_i_e_l_e_m_a_k_e_r

jan@swi.psy.uva.nl  http://www.swi.psy.uva.nl/projects/SWI-Prolog/

 SWI-Prolog  is  a Prolog  implementation based  on a  subset of
 the  WAM (Warren Abstract  Machine).   SWI-Prolog was developed
 as  an  `open'  Prolog environment,  providing  a  powerful and
 bi-directional  interface  to  C in  an  era  this was  unknown
 to   other  Prolog  implementations.      This  environment  is
 required  to  deal  with XPCE,  an  object-oriented  GUI system
 developed  at SWI. XPCE is  used at SWI for  the development of
 knowledge-intensive graphical applications.

 As  SWI-Prolog  became  more  popular,  a large  user-community
 provided  requirements that  guided its  development.   Compat-
 ibility,  portability,   scalability,  stability and  providing
 a   powerful  development   environment  have  been   the  most
 important  requirements.    `Edinburgh',  Quintus,  SICStus and
 the  ISO-standard  guide  the  development  of  the  SWI-Prolog
 primitives.

 This  document gives an overview of the features, system limits
 and built-in predicates.

 Copyright Oc 1990{1999,University of Amsterdam


CChhaapptteerr 11..  IINNTTRROODDUUCCTTIIOONN


11..11 SSWWII--PPrroolloogg

SWI-Prolog  has   been  designed  and  implemented   to  get  a   Prolog
implementation which can be used for experiments  with logic programming
and  the  relation  to other  programming  paradigms.     The  intention
was  to  build  a Prolog  environment  which  offers  enough  power  and
flexibility to  write substantial applications,  but is  straightforward
enough to  be modified for experiments  with debugging, optimisation  or
the introduction of  non-standard data types.  Performance  optimisation
is  limited due  to the  main objectives:    portability (SWI-Prolog  is
entirely written in C and Prolog) and modifiability.

SWI-Prolog  is based  on  a very  restricted  form  of the  WAM  (Warren
Abstract Machine) described  in [Bowen & Byrd, 1983] which defines  only
7  instructions.   Prolog  can  easily be  compiled into  this  language
and the  abstract machine code  is easily  decompiled back into  Prolog.
As  it is  also  possible to  wire a  standard  4-port debugger  in  the
WAM interpreter  there is  no need  for a  distinction between  compiled
and interpreted  code.   Besides  simplifying the design  of the  Prolog
system  itself this  approach has  advantages  for program  development:
the  compiler is  simple and  fast, the  user  does not  have to  decide
in  advance whether  debugging  is required  and  the system  only  runs
slightly  slower when  in debug  mode.   The  price we  have  to pay  is
some  performance degradation  (taking  out the  debugger from  the  WAM
interpreter improves performance  by about 20%) and somewhat  additional
memory usage to help the decompiler and debugger.

SWI-Prolog  extends  the  minimal  set  of   instructions  described  in
[Bowen & Byrd, 1983]  to improve  performance.    While  extending  this
set care  has been  taken to  maintain the  advantages of  decompilation
and  tracing of  compiled  code.    The extensions  include  specialised
instructions  for unification,  predicate  invocation,  some  frequently
used built-in  predicates, arithmetic, and  control (;/2, |/2),  if-then
(->/2) and negation-by-failure (\+/1).


11..11..11 OOtthheerr bbooookkss aabboouutt PPrroolloogg

This manual does not  describe the full syntax and semantics  of Prolog,
nor how  one should  write a  program in Prolog.    These subjects  have
been  described extensively  in  the literature.    See  [Bratko, 1986],
[Sterling & Shapiro, 1986],   and   [Clocksin & Melish, 1987].       For
more  advanced  Prolog   material  see  [OKeefe, 1990].     Syntax   and
standard  operator declarations  confirm  to the  `Edinburgh  standard'.
Most  built  in  predicates  are  compatible  with  those  described  in
[Clocksin & Melish, 1987].      SWI-Prolog  also  offers  a  number   of
primitive  predicates compatible  with  Quintus Prolog  [Qui, 1997]  and
BIM_Prolog [BIM, 1989].

ISO  compliant  predicates  are based  on  ``Prolog:    The  Standard'',
[Deransart _e_t _a_l_., 1996].


11..22 SSttaattuuss

This manual describes  version 3.3 of SWI-Prolog.   SWI-Prolog has  been
used now for many  years.  The application range includes  Prolog course
material,  meta-interpreters, simulation  of parallel  Prolog,  learning
systems,  natural  language processing  and  two large  workbenches  for
knowledge  engineering.    Although we  experienced rather  obvious  and
critical bugs  can remain  unnoticed for  a remarkable  long period,  we
assume the basic Prolog  system is fairly stable.  Bugs can  be expected
in infrequently used built-in predicates.

Some bugs are known to  the author.  They are described as  footnotes in
this manual.


11..33 CCoommpplliiaannccee ttoo tthhee IISSOO ssttaannddaarrdd

SWI-Prolog 3.3.0 implements  all predicates described in ``Prolog:   The
Standard''  [Deransart _e_t _a_l_., 1996], except  for char_conversion/2  and
current_char_conversion/2.

Exceptions  and warning  are still  weak.    Some SWI-Prolog  predicates
silently  fail on  conditions where  the ISO  specification requires  an
exception  (functor/3 for  example).    Many predicates  print  warnings
rather than raising an  exception.  All predicates where  exceptions may
be  caused due  to a  correct program  operating in  an imperfect  world
(I/O, arithmetic,  resource overflows)  should behave  according to  the
ISO standard.   In other  words:  SWI-Prolog  should be able to  execute
any program  conforming to [Deransart _e_t _a_l_., 1996]  that does not  rely
on exceptions generated by errors in the program.


11..44 SShhoouulldd yyoouu bbee uussiinngg SSWWII--PPrroolloogg??

There are a number of reasons why you better  choose a commercial Prolog
system, or another academic product:

  o _S_W_I_-_P_r_o_l_o_g _i_s _n_o_t _s_u_p_p_o_r_t_e_d
    Although  I usually fix bugs shortly  after a bug report arrives,  I
    cannot  promise anything.   Now that the  sources are provided,  you
    can always dig into them yourself.

  o _M_e_m_o_r_y _r_e_q_u_i_r_e_m_e_n_t_s _a_n_d _p_e_r_f_o_r_m_a_n_c_e _a_r_e _y_o_u_r _f_i_r_s_t _c_o_n_c_e_r_n_s
    A  number  of  commercial compilers  are  more  keen on  memory  and
    performance  than SWI-Prolog.   I do not  wish to sacrifice some  of
    the  nice features of the system, nor its portability to  compete on
    raw performance.

  o _Y_o_u _n_e_e_d _f_e_a_t_u_r_e_s _n_o_t _o_f_f_e_r_e_d _b_y _S_W_I_-_P_r_o_l_o_g
    In  this case you  may wish to  give me suggestions for  extensions.
    If  you  have great  plans, please  contact me  (you  might have  to
    implement them yourself however).

On the other hand, SWI-Prolog offers some nice facilities:

  o _N_i_c_e _e_n_v_i_r_o_n_m_e_n_t
    This includes `Do  What I Mean', automatic completion of atom names,
    history mechanism and  a tracer that operates on single key-strokes.
    Interfaces  to  some  standard  editors are  provided  (and  can  be
    extended), as well as a facility to maintain programs (see make/0).

  o _V_e_r_y _f_a_s_t _c_o_m_p_i_l_e_r
    Even  very  large applications  can  be loaded  in seconds  on  most
    machines.  If  this is not enough, there is a Quick Load Format that
    is slightly more compact and loading is almost always I/O bound.

  o _T_r_a_n_s_p_a_r_e_n_t _c_o_m_p_i_l_e_d _c_o_d_e
    SWI-Prolog  compiled code can be  treated just as interpreted  code:
    you  can list it, trace  it, etc.  This  implies you do not have  to
    decide  beforehand whether a module  should be loaded for  debugging
    or  not.  Also, performance  is much better than the  performance of
    most interpreters.

  o _P_r_o_f_i_l_i_n_g
    SWI-Prolog offers tools  for performance analysis, which can be very
    useful  to optimise  programs.   Unless you  are very familiar  with
    Prolog  and Prolog  performance  considerations this  might be  more
    helpful than a better compiler without these facilities.

  o _F_l_e_x_i_b_i_l_i_t_y
    SWI-Prolog  can  easily   be  integrated  with  C,  supporting  non-
    determinism  in Prolog calling  C as well  as C calling Prolog  (see
    section  5.  It can  also be _e_m_b_e_d_d_e_d embedded in external  programs
    (see  section 5.7).  System  predicates can be redefined locally  to
    provide compatibility with other Prolog systems.

  o _I_n_t_e_g_r_a_t_i_o_n _w_i_t_h _X_P_C_E
    SWI-Prolog   offers  a   tight  integration  to   the  Object   Ori-
    ented   Package  for   User  Interface   Development,  called   XPCE
    [Anjewierden & Wielemaker, 1989].    XPCE  allows you  to  implement
    graphical  user  interfaces  that are  source-code  compatible  over
    Unix/X11 and Win32 (Windows 95 and NT).


11..55 TThhee XXPPCCEE GGUUII ssyysstteemm ffoorr PPrroolloogg

The  XPCE GUI  system  for dynamically  typed  languages has  been  with
SWI-Prolog for  a long time.   It is  developed by Anjo Anjewierden  and
Jan  Wielemaker from  the department  of SWI,  University of  Amsterdam.
It  aims at  a  high-productive  development environment  for  graphical
applications based on Prolog.

Object  oriented  technology has  proven  to  be a  suitable  model  for
implementing GUIs, which  typically deal with things Prolog is  not very
good  at:   event-driven  control  and global  state.    With  XPCE,  we
designed  a system  that has  similar characteristics  that make  Prolog
such  a powerful  tool:   dynamic typing,  meta-programming and  dynamic
modification of the running system.

XPCE is  an object-system written  in the C-language.   It provides  for
the implementation of methods  in multiple languages.  New  XPCE classes
may be defined from Prolog using a simple, natural syntax.   The body of
the method is executed  by Prolog itself, providing a  natural interface
between the two systems.  Below is a very simple class definition.

:- pce_begin_class(prolog_lister, frame,
                   "List Prolog predicates").

initialise(Self) :->
        "As the C++ constructor"::
        send(Self, send_super, initialise, 'Prolog Lister'),
        send(Self, append, new(D, dialog)),
        send(D, append,
             text_item(predicate, message(Self, list, @arg1))),
        send(new(view), below, D).

list(Self, From:name) :->
        "List predicates from specification"::
        (   catch(term_to_atom(Term, From), _, fail)
        ->  get(Self, member, view, V),
            pce_open(V, write, Fd),
            set_output(Fd),
            listing(Term),
            close(Fd)
        ;   send(Self, report, error, 'Syntax error')
        ).

:- pce_end_class.

test :- send(new(prolog_lister), open).

Its  165  built-in   classes  deal  with  the  meta-environment,   data-
representation  and---of  course---graphics.     The   graphics  classes
concentrate on direct-manipulation of diagrammatic representations.

AAvvaaiillaabbiilliittyy.. XPCE runs  on most  Unixtm platforms, Windows  95, 98  and
Windows NT. It has been connected to SWI-Prolog, SICStustm and Quintustm
Prolog as well  as some Lisp dialects and  C++.  The Quintus version  is
commercially distributed and supported as ProWindows-3tm.

IInnffoo.. further        information        is         available        from
http://www.swi.psy.uva.nl/projects/xpce/   or   by   E-mail   to   xpce-
request@swi.psy.uva.nl.  There are demo versions for Windows  95, 98, NT
and i386/Linux available from the XPCE download page.


11..66 RReelleeaassee NNootteess

Collected release-notes.   This section  only contains some  highlights.
Smaller changes to especially  older releases have been removed.   For a
complete log, see the file ChangeLog from the distribution.


11..66..11 VVeerrssiioonn 11..88 RReelleeaassee NNootteess

Version  1.8 offers  a stack-shifter  to  provide dynamically  expanding
stacks  on machines  that  do  not offer  operating-system  support  for
implementing dynamic stacks.


11..66..22 VVeerrssiioonn 11..99 RReelleeaassee NNootteess

Version  1.9  offers  better portability  including  an  MS-Windows  3.1
version.  Changes to the Prolog system include:

  o _R_e_d_e_f_i_n_i_t_i_o_n _o_f _s_y_s_t_e_m _p_r_e_d_i_c_a_t_e_s
    Redefinition  of system  predicates  was allowed  silently in  older
    versions.    Version 1.9  only allows it  if the  new definition  is
    headed by a :- redefine_system_predicate/1 directive.

  o _`_A_n_s_w_e_r_' _r_e_u_s_e
    The  toplevel maintains  a table  of bindings  returned by  toplevel
    goals  and  allows for  reuse  of these  bindings by  prefixing  the
    variables with the $ sign.  See section 2.8.

  o _B_e_t_t_e_r _s_o_u_r_c_e _c_o_d_e _a_d_m_i_n_i_s_t_r_a_t_i_o_n
    Allows  for proper updating of multifile predicates and  finding the
    sources of individual clauses.


11..66..33 VVeerrssiioonn 22..00 RReelleeaassee NNootteess

New features offered:

  o _3_2_-_b_i_t _V_i_r_t_u_a_l _M_a_c_h_i_n_e
    Removes various limits and improves performance.

  o _I_n_l_i_n_e _f_o_r_e_i_g_n _f_u_n_c_t_i_o_n_s
    `Simple'  foreign predicates no  longer build a Prolog  stack-frame,
    but are directly  called from the VM. Notably provides a speedup for
    the test predicates such as var/1, etc.

  o _V_a_r_i_o_u_s _c_o_m_p_a_t_i_b_i_l_i_t_y _i_m_p_r_o_v_e_m_e_n_t_s

  o _S_t_r_e_a_m _b_a_s_e_d _I_/_O _l_i_b_r_a_r_y
    All  SWI-Prolog's I/O is now  handled by the stream-package  defined
    in  the foreign include file SWI-Stream.h.   Physical I/O of  Prolog
    streams  may be  redefined through the  foreign language  interface,
    facilitating much simpler integration in window environments.


11..66..44 VVeerrssiioonn 22..55 RReelleeaassee NNootteess

Version  2.5  is  an  intermediate release  on  the  path  from  2.1  to
3.0.    All  changes are  to  the foreign-language  interface,  both  to
user- and system-predicates implemented  in the C-language.  The  aim is
twofold.   First of all  to make garbage-collection and  stack-expansion
(stack-shifts)  possible  while  foreign  code  is  active  without  the
C-programmer having  to worry  about locking  and unlocking  C-variables
pointing  to Prolog  terms.    The new  approach is  closely  compatible
to the  Quintus and  SICStus Prolog  foreign interface  using the  +term
argument specification (see their respective manuals).   This allows for
writing foreign  interfaces that  are easily portable  over these  three
Prolog platforms.

Apart from  various bug fixes  listed in the  Changelog file, these  are
the main changes since 2.1.0:

  o _I_S_O _c_o_m_p_a_t_i_b_i_l_i_t_y
    Many   ISO  compatibility  features   have  been  added:     open/4,
    arithmetic functions, syntax, etc.

  o _W_i_n_3_2
    Many  fixes for the Win32 (NT,  '95 and win32s) platforms.   Notably
    many  problems related  to pathnames  and a problem  in the  garbage
    collector.

  o _P_e_r_f_o_r_m_a_n_c_e
    Many  changes to  the clause  indexing system:   added  hash-tables,
    lazy computation of the index information, etc.

  o _P_o_r_t_a_b_l_e _s_a_v_e_d_-_s_t_a_t_e_s
    The   predicate  qsave_program/[1,2] allows  for   the  creating  of
    machine independent saved-states that load very quickly.


11..66..55 VVeerrssiioonn 22..66 RReelleeaassee NNootteess

Version 2.6  provides a stable implementation  of the features added  in
the 2.5.x  releases, but  at the same  time implements  a number of  new
features that may have impact on the system stability.

  o _3_2_-_b_i_t _i_n_t_e_g_e_r _a_n_d _d_o_u_b_l_e _f_l_o_a_t _a_r_i_t_h_m_e_t_i_c
    The  biggest change is the  support for full 32-bit signed  integers
    and  raw  machine-format  double precision  floats.    The  internal
    data  representation as well as  the arithmetic instruction set  and
    interface to the arithmetic functions has been changed for this.

  o _E_m_b_e_d_d_i_n_g _f_o_r _W_i_n_3_2 _a_p_p_l_i_c_a_t_i_o_n_s
    The  Win32 version has been reorganised.   The Prolog kernel is  now
    implemented  as Win32  DLL that may  be embedded in  C-applications.
    Two front ends  are provided, one for window-based operation and one
    to run as a Win32 console application.

  o _C_r_e_a_t_i_n_g _s_t_a_n_d_-_a_l_o_n_e _e_x_e_c_u_t_a_b_l_e_s
    Version  2.6.0 can create  stand-alone executables by attaching  the
    saved-state to the emulator.  See qsave_program/2.


11..66..66 VVeerrssiioonn 22..77 RReelleeaassee NNootteess

Version 2.7  reorganises the  entire data-representation  of the  Prolog
data  itself.   The  aim is  to remove  most of  the  assumption on  the
machine's memory  layout to  improve portability in  general and  enable
embedding on  systems where the memory  layout may depend on  invocation
or on how the executable is linked.  The latter  is notably a problem on
the Win32 platforms.  Porting to 64-bit architectures is feasible now.

Furthermore, 2.7 lifts the  limits on arity of predicates and  number of
variables in  a clause considerably and  allow for further expansion  at
minimal cost.


11..66..77 VVeerrssiioonn 22..88 RReelleeaassee NNootteess

With version  2.8, we declare  the data-representation changes of  2.7.x
stable.   Version  2.8 exploits  the changes  of 2.7  to support  64-bit
processors like the DEC Alpha.  As of  version 2.8.5, the representation
of  recorded  terms  has  changed,  and  terms   on  the  heap  are  now
represented  in a  compiled format.    SWI-Prolog no  longer limits  the
use of malloc()  or uses assumptions on  the addresses returned by  this
function.


11..66..88 VVeerrssiioonn 22..99 RReelleeaassee NNootteess

Version  2.9  is  the next  step  towards  version  3.0,  improving  ISO
compliance  and introducing  ISO  compliant  exception handling.     New
are catch/3, throw/1, abolish/1, write_term/[2,3], write_canonical/[1,2]
and  the C-functions  PL_exception() and  PL_throw().    The  predicates
display/[1,2] and displayq/[1,2]  have been moved to  library(backcomp),
so old code referring to them will autoload them.

The interface  to PL_open_query() has changed.    The _d_e_b_u_g argument  is
replaced  by a  bitwise or'ed  _f_l_a_g_s argument.    The  values FALSE  and
TRUE have their familiar meaning, making old code  using these constants
compatible.   Non-zero values  other than TRUE  (1) will be  interpreted
different.


11..66..99 VVeerrssiioonn 33..00 RReelleeaassee NNootteess

Complete  redesign   of  the   saved-state  mechanism,   providing   the
possibility of  `program resources'.   See  resource/3, open_resource/3,
and qsave_program/[1,2].


11..66..1100 VVeerrssiioonn 33..11 RReelleeaassee NNootteess

Improvements   on  exception-handling.       Allows  relating   software
interrupts (signals)  to exceptions,  handling signals in  Prolog and  C
(see on_signal/3  and PL_signal()).   Prolog stack  overflows now  raise
the resource_error  exception and thus  can be handled  in Prolog  using
catch/3.


11..66..1111 VVeerrssiioonn 33..33 RReelleeaassee NNootteess

Version 3.3  is a  major release,  changing many  things internally  and
externally.   The highlights are a  complete redesign of the  high-level
I/O system, which is  now based on explicit streams rather  then current
input/output.  The  old Edinburgh predicates (see/1, tell/1, etc.)   are
now defined on top of this layer instead of the other  way around.  This
fixes various internal problems and removes Prolog limits  on the number
of streams.

Much  progress  has been  made  to  improve ISO  compliance:    handling
strings  as  lists  of  one-character  atoms  is   now  supported  (next
to  character   codes  as  integers).      Many  more  exceptions   have
been  added   and  printing  of  exceptions   and  messages  is   ratio-
nalised  using Quintus  and SICStus  Prolog compatible  print_message/2,
message_hook/3  and   print_message_lines/3.       All   predicates   de-
scriped  in [Deransart _e_t _a_l_., 1996]  except  for char_conversion/2  and
current_char_conversion/2are now implemented.

As of version  3.3, SWI-Prolog adheres the  ISO _l_o_g_i_c_a_l _u_p_d_a_t_e _v_i_e_w  for
dynamic predicates.  See section 3.13.1 for details.

SWI-Prolog  3.3  includes garbage  collection  on  atoms,  removing  the
last serious memory  leak especially in text-manipulation  applications.
See  section 5.6.2.1.    In addition,  both the  user-level and  foreign
interface supports atoms holding _0_-_b_y_t_e_s.

Finally, an  alpha version of a  multi-threaded SWI-Prolog for Linux  is
added.    This version  is still  much slower  than the  single-threaded
version due  to frequent access to  `thread-local-data' as well as  some
too detailed  mutex locks.   The basic thread  API is ready for  serious
use and testing however.  See section 3.38.


11..66..1111..11 IInnccoommppaattiibbllee cchhaannggeess

A number  of incompatible changes  result from this upgrade.   They  are
all easily fixed however.

  o atom_chars/2
    This  predicate  is now  ISO  compliant and  thus generates  a  list
    of  one-character atoms.    The behaviour  of the  old predicate  is
    available  in the  ---also ISO compliant---  atom_codes/2 predicate.
    Safest  repair is a  replacement of all  atom_chars  into atom_codes.
    If you do not want to change any souce-code, you might want to use

    user:goal_expansion(atom_chars(A,B), atom_codes(A,B)).

  o number_chars/2
    Same applies for number_chars/2 and number_codes/2.

  o feature/2_, set_feature/2
    These  are  replaced  by  the  ISO  compliant  current_prolog_flag/2
    and  set_prolog_flag/2.    The  library  library(backcomp)  provides
    definitions for  feature/2 and set_feature/2, so no  source hhaass to be
    updated.

  o _A_c_c_e_s_s_i_n_g _c_o_m_m_a_n_d_-_l_i_n_e _a_r_g_u_m_e_n_t_s
    This  used  to   be  provided  by  the  undocumented  '$argv'/1  and
    Quintus  compatible library unix/1.   Now  there is also  documented
    current_prolog_flag(_a_r_g_v_, _A_r_g_v).

  o dup_stream/2
    Has  been deleted.   New  stream-aliases can deal  with most of  the
    problems  for which  dup_stream/2 was  designed and  dup/2 from  the
    _c_l_i_b package can with most others.

  o op/3
    Operators  are now llooccaall ttoo mmoodduulleess.  This implies  any modification
    of  the operator-table does  not influence other  modules.  This  is
    consistent  with the proposed ISO behaviour and a necessity  to have
    any usable handling of operators in a multi-threaded environment.

  o _s_e_t___p_r_o_l_o_g___f_l_a_g_(_c_h_a_r_a_c_t_e_r___e_s_c_a_p_e_s_, _B_o_o_l_)
    This  prolog flag is now an interface to changing attributes  on the
    current source-module,  effectively making this flag module-local as
    well.   This is required for consistent handling of  sources written
    with  ISO (obligatory) character-escape sequences together  with old
    Edinburgh code.

  o current_stream/3 _a_n_d _s_t_r_e_a_m___p_o_s_i_t_i_o_n
    These predicates have been moved to library(quintus).


11..77 AAcckknnoowwlleeddggeemmeennttss

Some  small  parts  of  the  Prolog  code  of  SWI-Prolog  are  modified
versions of  the corresponding  Edinburgh C-Prolog code:   grammar  rule
compilation  and writef/2.    Also some  of the  C-code originates  from
C-Prolog:  finding the path of the currently running  executable and the
code underlying  absolute_file_name/2.   Ideas  on programming style  and
techniques originate from  C-Prolog and Richard O'Keefe's _t_h_i_e_f  editor.
An  important  source  of inspiration  are  the  programming  techniques
introduced by Anjo Anjewierden in PCE version 1 and 2.

I also  would like to thank  those who had the  fade of using the  early
versions of this system,  suggested extensions or reported bugs.   Among
them are Anjo Anjewierden, Huub Knops, Bob  Wielinga, Wouter Jansweijer,
Luc Peerdeman, Eric Nombden, Frank van Harmelen, Bert Rengel.

Martin Jansche  (jansche@novell1.gs.uni-heidelberg.de) has been so  kind
to reorganise the sources for version 2.1.3 of this manual.

Horst  von Brand  has been  so  kind to  fix many  typos  in the  2.7.14
manual.  Thanks!


CChhaapptteerr 22..  OOVVEERRVVIIEEWW


22..11 GGeettttiinngg ssttaarrtteedd qquuiicckkllyy


22..11..11 SSttaarrttiinngg SSWWII--PPrroolloogg


22..11..11..11 SSttaarrttiinngg SSWWII--PPrroolloogg oonn UUnniixx

By default, SWI-Prolog is installed as `pl',  though some administrators
call  it  `swipl'  or  `swi-prolog'.     The  commandline  arguments  of
SWI-Prolog  itself  and  its  utility  programs   are  documented  using
standard  Unix  man pages.     SWI-Prolog  is normally  operated  as  an
interactive application simply by starting the program:

machine% pl
% /staff/jan/.plrc compiled, 0.00 sec, 1,016 bytes.
Welcome to SWI-Prolog (Version 3.2.9)
Copyright (c) 1993-1998 University of Amsterdam.  All rights reserved.

For help, use ?- help(Topic). or ?- apropos(Word).

?-

After  starting Prolog,  one  normally loads  a  program into  it  using
consult/1,  which---for  historical  reasons---may   be  abbreviated  by
putting the  name of  the program  file between  square brackets.    The
following  goal loads  the  file  likes.pl containing  clauses  for  the
predicates likes/2:

?- [likes].
% likes compiled, 0.00 sec, 596 bytes.

Yes
?-

After this point, Unix and Windows users are united again.


22..11..11..22 SSttaarrttiinngg SSWWII--PPrroolloogg oonn WWiinnddoowwss

After SWI-Prolog has been  installed on a Windows system,  the following
important new things are available to the user:

  o A  folder  (called  _d_i_r_e_c_t_o_r_y in  the  remainder of  this  document)
    called  pl  containing the  executables,  libraries, etc.    of  the
    system.  No files are installed outside this directory.

  o A  program  plwin.exe,  providing  a  window  for  interaction  with
    Prolog.  The  program plcon.exe is a version of SWI-Prolog that runs
    in a DOS-box.

  o The  file-extension .pl  is associated with  the program  plwin.exe.
    Opening  a .pl file will cause plwin.exe to start,  change directory
    to  the directory in  which the file-to-open  resides and load  this
    file.

The  normal   way  to  start  with   the  likes.pl  file  mentioned   in
section 2.1.1.1  is by simply double-clicking  this file in the  Windows
explorer.


22..11..22 EExxeeccuuttiinngg aa qquueerryy

After loading a program,  one can ask Prolog queries about  the program.
The query below  asks Prolog to prove  whether `john' likes someone  and
who is  liked by  `john'.   The system  responds with X = <_v_a_l_u_e> if  it
can prove  the goal for a  certain _X. The  user can type the  semi-colon
(;) if  (s)he wants another solution,  or return if (s)he is  satisfied,
after which Prolog will say YYeess.  If Prolog answers  NNoo, it indicates it
cannot find any more  answers to the query.  Finally, Prolog  can answer
using an  error message  to indicate  the query or  program contains  an
error.

?- likes(john, X).

X = mary


22..22 TThhee uusseerr''ss iinniittiiaalliissaattiioonn ffiillee

After  the necessary  system  initialisation  the system  consults  (see
consult/1) the user's startup file.  The base-name  of this file follows
conventions of  the operating  system.   On MS-Windows,  it is the  file
pl.ini  and on  Unix systems  .plrc.   The  file is  searched using  the
file_search_path/2 clauses for user_profile.  The table below  shows the
default value for this search-path.

     _______________________________________________________________
     |________________|UUnniixx__||WWiinnddoowwss________________________________________________________________________________||
     || llooccaall  ||.    |.                                              |

     | hhoommee   ||~    |%HOME% or %HOMEDRIVE%\%HOMEPATH%               |
     |_global_|____|SWI-Home_directory_or_%WINDIR%_or_%SYSTEMROOT%_|_

After the  first startup  file is found  it is  loaded and Prolog  stops
looking for further startup files.  The name of the  startup file can be
changed with the  `-f file' option.   If _F_i_l_e denotes an absolute  path,
this file is loaded,  otherwise the file is searched for using  the same
conventions as for the default startup file.  Finally,  if _f_i_l_e is none,
no file is loaded.


22..33 IInniittiiaalliissaattiioonn ffiilleess aanndd ggooaallss

Using  commandline  arguments  (see  section  2.4),  SWI-Prolog  can  be
forced to  load files  and execute queries  for initialisation  purposes
or  non-interactive operation.    The  most  commonly used  options  are
-f file to  make Prolog load an  initialisation file, -g goal to  define
an initialisation  goal and -t goal  to define the _t_o_p_l_e_v_e_l  _g_o_a_l.   The
following  is a  typical example  for starting  an application  directly
from the commandline.

machine% pl -f load.pl -g go -t halt

It tells  SWI-Prolog to load  load.pl, start  the application using  the
_e_n_t_r_y_-_p_o_i_n_t go/0 and ---instead of entering  the interactive toplevel---
exit after completing go/0.

In  MS-Windows,  the  same  can  be  achieved  using  a  short-cut  with
appropriately  defined  commandline   arguments.     A  typically   seen
alternative  is to  write  a file  run.pl  with content  as  illustrated
below.  Double-clicking run.pl will start the application.

:- [load].                      % load program
:- go.                          % run it
:- halt.                        % and exit

Chapter 6  discusses the  generation of  runtime executables.    Runtime
executables are a  mean to deliver executables  that do not require  the
Prolog system.


22..44 CCoommmmaanndd lliinnee ooppttiioonnss

The full set of command line options is given below:

--hheellpp
    When  given as  the only  option, it summarises  the most  important
    options.

--vv
    When  given as the  only option, it  summarises the version and  the
    architecture identifier.

--aarrcchh
    When   given  as  the  only  option,  it  prints   the  architecture
    identifier  (see  current_prolog_flag(arch,  Arch)) and  exits.    See
    also -dump-runtime-variables.

--dduummpp--rruunnttiimmee--vvaarriiaabblleess
    When  given as  the only option,  it prints  a sequence of  variable
    settings  that can  be  used in  shell-scripts to  deal with  Prolog
    parameters.   This feature is  also used by plld (see section  5.7).
    Below is a typical example of using this feature.

    eval `pl -dump-runtime-variables`
    cc -I$PLBASE/include -L$PLBASE/runtime/$PLARCH ...

--LL_s_i_z_e_[_k_m_]
    Give  local stack limit (2 Mbytes default).   Note that there  is no
    space  between the size option  and its argument.   By default,  the
    argument  is interpreted in  Kbytes.   Postfixing the argument  with
    m  causes the argument to be  interpreted in Mbytes.  The  following
    example specifies 32 Mbytes local stack.

    % pl -L32m

    A maximum is  useful to stop buggy programs from claiming all memory
    resources.   -L0 sets the limit to the highest possible value.   See
    section 2.16.

--GG_s_i_z_e_[_k_m_]
    Give  global  stack limit  (4 Mbytes  default).    See -L  for  more
    details.

--TT_s_i_z_e_[_k_m_]
    Give  trail  stack  limit  (4  Mbytes  default).     This  limit  is
    relatively  high because trail-stack overflows are not  often caused
    by program bugs.  See -L for more details.

--AA_s_i_z_e_[_k_m_]
    Give  argument stack limit (1 Mbytes  default).  The argument  stack
    limits  the  maximum  nesting of  terms  that  can be  compiled  and
    executed.    SWI-Prolog does `last-argument  optimisation' to  avoid
    many  deeply nested  structure  using this  stack.   Enlarging  this
    limit is only necessary in extreme cases.  See -L for more details.

--cc _f_i_l_e _._._.
    Compile files into an `intermediate code file'.  See section 2.10.

--oo _o_u_t_p_u_t
    Used  in combination  with -c  or -b  to determine  output file  for
    compilation.

--OO
    Optimised compilation.  See current_prolog_flag/2.

--ff _f_i_l_e
    Use  _f_i_l_e as startup file instead  of the default.  `-f none'  stops
    SWI-Prolog from searching for a startup file.  See section 2.2.

--FF _s_c_r_i_p_t
    Selects  a startup-script from the  SWI-Prolog home directory.   The
    script-file  is  named <_s_c_r_i_p_t>.rc.    The  default _s_c_r_i_p_t  name  is
    deduced  from  the  executable,  taking the  leading  alphanumerical
    characters  (letters, digits and underscore) from  the program-name.
    -F none stops looking  for a script.  Intended for simple management
    of  slightly  different  versions.    One  could for  example  write
    a  script  iso.rc  and  then select  ISO  compatibility  mode  using
    pl -F iso or make a link from iso-pl to pl.

--gg _g_o_a_l
    _G_o_a_l  is executed just before entering the top level.  Default  is a
    predicate  which prints the  welcome message.   The welcome  message
    can  thus be suppressed by  giving -g true.   _g_o_a_l can be a  complex
    term.   In this case quotes  are normally needed to protect  it from
    being expanded by the Unix shell.

--tt _g_o_a_l
    Use  _g_o_a_l  as  interactive  toplevel instead  of  the  default  goal
    prolog/0.    _g_o_a_l  can be  a complex  term.   If  the toplevel  goal
    succeeds  SWI-Prolog exits  with status  0.   If it  fails the  exit
    status  is  1.    This  flag also  determines  the goal  started  by
    break/0  and abort/0.   If you want to  stop the user from  entering
    interactive  mode  start the  application  with `-g goal'  and  give
    `halt' as toplevel.

--ttttyy
    Unix  only.      Switches  controlling  the  terminal  for  allowing
    single-character  commands to the tracer and  get_single_char/1.   By
    default  manipulating  the terminal  is  enabled unless  the  system
    detects  it is not  connected to a  terminal or it  is running as  a
    GNU-Emacs  inferior process.   This flag  is sometimes required  for
    smooth interaction with other applications.

--xx _b_o_o_t_f_i_l_e
    Boot  from _b_o_o_t_f_i_l_e instead  of the system's default  boot file.   A
    bootfile is a  file resulting from a Prolog compilation using the -b
    or -c option or a program saved using qsave_program/[1,2].

--pp _a_l_i_a_s_=_p_a_t_h_1_[_:_p_a_t_h_2 _._._._]
    Define  a path  alias for  file_search_path.    _a_l_i_a_s is  the name  of
    the  alias, _p_a_t_h_1  _._._.   is  a : separated  list of  values for  the
    alias.    A  value is  either a  term of  the  form alias(value)  or
    pathname.    The  computed aliases  are added  to file_search_path/2
    using  asserta/1, so they precede  predefined values for the  alias.
    See  file_search_path/2  for details  on  using  this  file-location
    mechanism.

--
    Stops  scanning for more  arguments, so you  can pass arguments  for
    your  application after this  one.   See current_prolog_flag/2 using
    the flag argv for obtaining the commandline arguments.

The following options  are for system maintenance.   They are given  for
reference only.

--bb _i_n_i_t_f_i_l_e _._._.-c _f_i_l_e _._._.
    Boot  compilation.   _i_n_i_t_f_i_l_e  _._._.   are compiled  by the  C-written
    bootstrap  compiler,  _f_i_l_e  _._._.    by  the normal  Prolog  compiler.
    System maintenance only.

--dd _l_e_v_e_l
    Set  debug  level to  _l_e_v_e_l.    Only  has effect  if the  system  is
    compiled with the -DO_DEBUG flag.  System maintenance only.


22..55 GGNNUU EEmmaaccss IInntteerrffaaccee

Once  upon a  time,  there  was port  of  the Quintus  Prolog  GNU-Emacs
package  for GNU-Emacs  18.   This  package has  been  dropped from  the
distribution because it didn't work on Emacs 19 and 20.

The default  Prolog mode for  GNU-Emacs can be  activated by adding  the
following rules to your Emacs initialisation file:

(setq auto-mode-alist
      (append
       '(("\\.pl" . prolog-mode))
       auto-mode-alist))
(setq prolog-program-name "pl")
(setq prolog-consult-string "[user].\n")
;If you want this.  Indentation is either poor or I don't use
;it as intended.
;(setq prolog-indent-width 8)

If anyone has a better suggestion, please make this public.


22..66 OOnnlliinnee HHeellpp

Online  help  provides a  fast  lookup  and browsing  facility  to  this
manual.   The online  manual can show predicate  definitions as well  as
entire sections of the manual.

The online help  is displayed from the file library('MANUAL').  The file
library(helpidx) provides  an index into this  file.   library('MANUAL')
is created  from the LaTeX  sources with a  modified version of  dvitty,
using overstrike  for printing bold text  and underlining for  rendering
italic  text.    XPCE  is  shipped  with  library(swi_help),  presenting
the  information from  the  online help  in a  hypertext  window.    The
prolog-flag  write_help_with_overstrike controls  whether  or not  help/1
writes  its output  using  overstrike  to realise  bold  and  underlined
output or  not.   If this prolog-flag  is not set  it is initialised  by
the help  library to true  if the TERM variable  equals xterm and  false
otherwise.   If  this default does  not satisfy you,  add the  following
line to your personal startup file (see section 2.2):

:- set_prolog_flag(write_help_with_overstrike, true).


hheellpp
    Equivalent to help(help/1).


hheellpp((_+_W_h_a_t))
    Show specified part of the manual.  _W_h_a_t is one of:

          <_N_a_m_e>/<_A_r_i_t_y> Give help on specified predicate
          <_N_a_m_e>         Give  help on  named  predicate with  any
                         arity or  C interface function  with that
                         name
          <_S_e_c_t_i_o_n>      Display  specified  section.      Section
                         numbers are dash-separated  numbers:  2-3
                         refers  to  section 2.3  of  the  manual.

                         Section   numbers  are   obtained   using
                         apropos/1.

    Examples:

       ?- help(assert).     Give help on predicate assert
       ?- help(3-4).        Display section 3.4 of the manual
       ?- help('PL_retry'). Give    help   on    interface   function
                            PL_retry()

    See   also   apropos/1,    and   the   SWI-Prolog   home   page   at
    http://www.swi.psy.uva.nl/projects/SWI-Prolog/,   which  provides  a
    FAQ, an HTML version  of manual for online browsing and HTML and PDF
    versions for downloading.


aapprrooppooss((_+_P_a_t_t_e_r_n))
    Display all predicates,  functions and sections that have _P_a_t_t_e_r_n in
    their  name or summary  description.   Lowercase letters in  _P_a_t_t_e_r_n
    also match a corresponding uppercase letter.  Example:

        ?- apropos(file).  Display  predicates,  functions and  sec-
                           tions that have  `file' (or `File', etc.)
                           in their summary description.


eexxppllaaiinn((_+_T_o_E_x_p_l_a_i_n))
    Give an explanation on  the given `object'.  The argument may be any
    Prolog data object.   If the argument is an atom, a term of the form
    _N_a_m_e_/_A_r_i_t_y  or a term  of the  form _M_o_d_u_l_e_:_N_a_m_e_/_A_r_i_t_y, explain  will
    try to explain the predicate as well as possible references to it.


eexxppllaaiinn((_+_T_o_E_x_p_l_a_i_n_, _-_E_x_p_l_a_n_a_t_i_o_n))
    Unify  _E_x_p_l_a_n_a_t_i_o_n with an explanation for _T_o_E_x_p_l_a_i_n.   Backtracking
    yields further explanations.


22..77 QQuueerryy SSuubbssttiittuuttiioonnss

SWI-Prolog  offers a  query substitution  mechanism similar  to that  of
Unix csh (csh(1)), called  `history'.  The availability of  this feature
is controlled by  set_prolog_flag/2, using  the history prolog-flag.   By
default,  history is  available if  the prolog-flag  readline is  false.
To  enable this  feature,  remembering the  last  50 commands,  put  the
following into your startup file (see section 2.2:

:- set_prolog_flag(history, 50).

The history  system allows the  user to compose  new queries from  those
typed before and  remembered by the system.   It also allows to  correct
queries and  syntax errors.    SWI-Prolog does  not offer  the Unix  csh
capabilities to  include arguments.   This is omitted  as it is  unclear
how the first, second, etc. argument should be defined.

The available history commands are shown in table 2.1.
       __________________________________________________________
       | !!.            |Repeat last query                        |

       | !nr.           |Repeat query numbered <_n_r>               |
       | !str.          |Repeat last query starting with <_s_t_r>    |
       | !?str.         |Repeat last query holding <_s_t_r>          |
       | ^old^new.      |Substitute <_o_l_d> into <_n_e_w> in last query |
       | !nr^old^new.   |Substitute in query numbered <_n_r>        |
       | !str^old^new.  |Substitute in query starting with <_s_t_r>  |
       | !?str^old^new. |Substitute in query holding <_s_t_r>        |
       | h.             |Show history list                        |

       |_!h.____________|Show_this_list__________________________ |

                      Table 2.1:  History commands


22..77..11 LLiimmiittaattiioonnss ooff tthhee HHiissttoorryy SSyysstteemm

History expansion  is executed  after _r_a_w_-_r_e_a_d_i_n_g.   This  is the  first
stage of read_term/2 and friends,  reading the term into a  string while
deleting comment  and canonising blank.   This makes  it hard to use  it
for correcting  syntax errors.   Command-line editing as provided  using
the GNU-readline library is  more suitable for this.   History expansion
is first  of all useful  for executing or  combining commands from  long
ago.


22..88 RReeuussee ooff ttoopplleevveell bbiinnddiinnggss

Bindings resulting from the successful execution of a  toplevel goal are
asserted in a database.  These values may be  reused in further toplevel
queries as $Var.  Only the latest binding is available.  Example:
1 ?- maplist(plus(1), "hello", X).

X = [105,102,109,109,112]

Yes
2 ?- format('~s~n', [$X]).
ifmmp

Yes

3 ?-

                 Figure 2.1:  Reusing toplevel bindings

Note that variables may be set by executing =/2:

6 ?- X = statistics.

X = statistics

Yes
7 ?- $X.
28.00 seconds cpu time for 183,128 inferences
4,016 atoms, 1,904 functors, 2,042 predicates, 52 modules
55,915 byte codes; 11,239 external references

                      Limit    Allocated       In use
Heap         :                                624,820 Bytes
Local  stack :    2,048,000        8,192          404 Bytes
Global stack :    4,096,000       16,384          968 Bytes
Trail  stack :    4,096,000        8,192          432 Bytes

Yes
8 ?-


22..99 OOvveerrvviieeww ooff tthhee DDeebbuuggggeerr

SWI-Prolog has  a 6-port  tracer, extending the  standard 4-port  tracer
[Clocksin & Melish, 1987]  with two  additional  ports.    The  optional
_u_n_i_f_y port allows  the user to inspect  the result after unification  of
the head.  The _e_x_c_e_p_t_i_o_n port shows exceptions raised  by throw/1 or one
of the built-in predicates.  See section 3.9.

The standard  ports are called call,  exit, redo, fail  and unify.   The
tracer is started  by the trace/0 command,  when a spy point is  reached
and the system is  in debugging mode (see spy/1 and debug/0) or  when an
exception is raised.

The interactive  toplevel goal trace/0 means  ``trace the next  query''.
The  tracer shows  the  port,  displaying  the port  name,  the  current
depth of  the recursion and  the goal.   The goal  is printed using  the
Prolog predicate write_term/2.  The style is defined  by the prolog-flag
debugger_print_options  and can be modified using this flag or  using the
w, p and d commands of the tracer.
1 ?- visible(+all), leash(-exit).

Yes
2 ?- trace, min([3, 2], X).
  Call:  ( 3) min([3, 2], G235) ? creep
  Unify: ( 3) min([3, 2], G235)
  Call:  ( 4) min([2], G244) ? creep
  Unify: ( 4) min([2], 2)
  Exit:  ( 4) min([2], 2)

  Call:  ( 4) min(3, 2, G235) ? creep
  Unify: ( 4) min(3, 2, G235)
  Call:  ( 5) 3 < 2 ? creep
  Fail:  ( 5) 3 < 2 ? creep
  Redo:  ( 4) min(3, 2, G235) ? creep
  Exit:  ( 4) min(3, 2, 2)
  Exit:  ( 3) min([3, 2], 2)

Yes
[trace] 3 ?-

                       Figure 2.2:  Example trace

On _l_e_a_s_h_e_d  _p_o_r_t_s (set  with the  predicate leash/1,  default are  call,
exit, redo and  fail) the user is prompted  for an action.  All  actions
are single character  commands which are executed wwiitthhoouutt waiting  for a
return, unless the command line option -tty is active.  Tracer options:

+ ((SSppyy))
    Set a spy point (see spy/1) on the current predicate.

- ((NNoo ssppyy))
    Remove the spy point (see nospy/1) from the current predicate.

/ ((FFiinndd))
    Search  for a port.   After the  `/', the user  can enter a line  to
    specify  the port to  search for.   This line consists  of a set  of
    letters  indicating the  port type,  followed by  an optional  term,
    that  should unify with  the goal run by  the port.   If no term  is
    specified  it is taken as a variable, searching for any port  of the
    specified  type.  If an atom is given, any goal whose  functor has a
    name equal to that atom matches.  Examples:

            /f               Search for any fail port

            /fe solve        Search for a  fail or exit  port of
                             any goal with name solve
            /c solve(a, _)   Search for a call to  solve/2 whose
                             first argument is a variable or the
                             atom a
            /a member(_, _)  Search for  any  port on  member/2.
                             This is equivalent to setting a spy
                             point on member/2.

. ((RReeppeeaatt ffiinndd))
    Repeat the last find command (see `/').

A ((AAlltteerrnnaattiivveess))
    Show all goals that have alternatives.

C ((CCoonntteexxtt))
    Toggle  `Show Context'.   If on  the context module  of the goal  is
    displayed between square brackets (see section 4).  Default is off.

L ((LLiissttiinngg))
    List the current predicate with listing/1.

a ((AAbboorrtt))
    Abort Prolog execution (see abort/0).

b ((BBrreeaakk))
    Enter a Prolog break environment (see break/0).

c ((CCrreeeepp))
    Continue execution, stop at next port.  (Also return, space).

d ((DDiissppllaayy))
    Set  the max_depth(_D_e_p_t_h) option of debugger_print_options,  limiting
    the  depth  to which  terms are  printed.    See also  the  w and  p
    options.

e ((EExxiitt))
    Terminate Prolog (see halt/0).

f ((FFaaiill))
    Force failure of the current goal.

g ((GGooaallss))
    Show the list of  parent goals (the execution stack).  Note that due
    to  tail recursion optimization a  number of parent goals might  not
    exist any more.

h ((HHeellpp))
    Show available options (also `?').

i ((IIggnnoorree))
    Ignore the current goal, pretending it succeeded.

l ((LLeeaapp))
    Continue execution, stop at next spy point.

n ((NNoo ddeebbuugg))
    Continue execution in `no debug' mode.

p ((PPrriinntt))
    Set       the       prolog-flag       debugger_print_options       to
    [quoted(true), portray(true), max_depth(10)].        This   is   the
    default.

r ((RReettrryy))
    Undo  all actions (except for database and i/o actions) back  to the
    call  port of  the current  goal and  resume execution  at the  call
    port.

s ((SSkkiipp))
    Continue  execution,  stop  at the  next  port  of tthhiiss  goal  (thus
    skipping all calls to children of this goal).

u ((UUpp))
    Continue  execution, stop at the next port of tthhee ppaarreenntt  goal (thus
    skipping  this goal and all calls to  children of this goal).   This
    option is useful to stop tracing a failure driven loop.

w ((WWrriittee))
    Set   the  prolog-flag   debugger_print_options  to   [quoted(true)],
    bypassing portray/1, etc.

The   ideal  4   port  model   as  described   in   many  Prolog   books
[Clocksin & Melish, 1987] is not visible in many  Prolog implementations
because code optimisation  removes part of the choice- and  exit-points.
Backtrack  points   are  not   shown  if  either   the  goal   succeeded
deterministically or its alternatives were removed using the cut.   When
running in  debug mode (debug/0) choice  points are only destroyed  when
removed by  the cut.    In debug  mode, tail  recursion optimisation  is
switched off.


22..1100 CCoommppiillaattiioonn


22..1100..11 DDuurriinngg pprrooggrraamm ddeevveellooppmmeenntt

During  program   development,  programs   are  normally  loaded   using
consult/1, or the list abbreviation.  It is  common practice to organise
a project  as a  collection of source-files  and a  _l_o_a_d_-_f_i_l_e, a  Prolog
file  containing only  use_module/[1,2]  or ensure_loaded/1  directives,
possibly  with a  definition  of the  _e_n_t_r_y_-_p_o_i_n_t  of the  program,  the
predicate that  is normally used  to start  the program.   This file  is
often  called load.pl.    If the  entry-point is  called _g_o,  a  typical
session starts as:

% pl
<banner>

1 ?- [load].
<compilation messages>

Yes
2 ?- go.
<program interaction>

When  using  Windows,  the  user  may  open  load.pl  from  the  Windows
explorer,  which will cause  plwin.exe to  be started  in the  directory
holding load.pl.  Prolog loads load.pl before entering the toplevel.


22..1100..22 FFoorr rruunnnniinngg tthhee rreessuulltt

There are  various options if  you want to make  your program ready  for
real usage.   The best  choice depends on whether  the program is to  be
used only  on machines  holding the SWI-Prolog  development system,  the
size of the program and the operating system (Unix vs. Windows).


22..1100..22..11 CCrreeaattiinngg aa sshheellll--ssccrriipptt

Especially  on  Unix systems  and  not-too-large  applications,  writing
a  shell-script  that  simply  loads  your  application  and  calls  the
entry-point is often a good choice.  A skeleton for  the script is given
below, followed by the Prolog code to obtain the program arguments.

#!/bin/sh

base=<absolute-path-to-source>
PL=pl

exec $PL -f none -g "load_files(['$base/load'],[silent(true)])" \
         -t go -- $*

go :-
        current_prolog_flag(argv, Arguments),
        append(_SytemArgs, [--|Args], Arguments), !,
        go(Args).

go(Args) :-
        ...

On Windows  systems, similar  behaviour can  be achieved  by creating  a
shortcut to Prolog, passing the proper options or writing a .bat file.


22..1100..22..22 CCrreeaattiinngg aa ssaavveedd--ssttaattee

For larger programs,  as well as for  programs that are required run  on
systems that  do not have the  SWI-Prolog development system  installed,
creating a saved state is  the best solution.  A saved state  is created
using qsave_program/[1,2] or  using the linker plld(1).   A saved  state
is a file  containing machine-independent intermediate code in a  format
dedicated for fast loading.  Optionally, the  emulator may be integrated
in  the saved  state,  creating  a single-file,  but  machine-dependent,
executable.  This process is described in chapter 6.


22..1100..22..33 CCoommppiillaattiioonn uussiinngg tthhee --cc ccoommmmaannddlliinnee ooppttiioonn

This mechanism loads a series of Prolog source files  and then creates a
saved-state as qsave_program/2 does.  The command syntax is:

% pl [option ...] [-o output] -c file ...

The  _o_p_t_i_o_n_s argument  are  options to  qsave_program/2 written  in  the
format below.    The option-names  and their values  are described  with
qsave_program/2.

    --_o_p_t_i_o_n_-_n_a_m_e=_o_p_t_i_o_n_-_v_a_l_u_e

For example, to create a stan-alone executable that  starts by executing
main/0  and for  which the  source is  loaded through  load.pl, use  the
command

% pl --goal=main --stand_alone=true -o myprog -c load.pl

This performs exactly the same as executing

% pl
<banner>
?- [load].
?- qsave_program(myprog,
                 [ goal(main),
                   stand_alone(true)
                 ]).
?- halt.


22..1111 EEnnvviirroonnmmeenntt CCoonnttrrooll ((PPrroolloogg ffllaaggss))

The current  system defines 2 different  mechanisms to query and/or  set
properties  of the  environment:   flag/3  and  current_prolog_flag/2 as
well  as a  number of  special purpose  predicates  of which  unknown/2,
fileerrors/2 are examples.  The ISO standard defines prolog_flag.  It is
likely that all  these global features will  be merged into a single  in
the future.


ccuurrrreenntt__pprroolloogg__ffllaagg((_?_K_e_y_, _-_V_a_l_u_e))
    The   predicate  current_prolog_flag/2  defines   an  interface   to
    installation   features:    options  compiled  in,  version,   home,
    etc.    With both arguments  unbound, it  will generate all  defined
    prolog-flags.    With  the  `Key' instantiated  it unify  the  value
    of  the  prolog-flag.    Features  come  in three  types:    boolean
    prolog-flags,  prolog-flags  with  an  atom value  and  prolog-flags
    with  an integer  value.    A boolean  prolog-flag is  true iff  the
    prolog-flag  is present aanndd the _V_a_l_u_e  is the atom true.   Currently
    defined keys:

    aarrcchh _(_a_t_o_m_)
         Identifier for the hardware and operating system  SWI-Prolog is
         running on.  Used  to determine the startup file as well  as to
         select foreign  files for  the right  architecture.   See  also
         load_foreign/5.

    vveerrssiioonn _(_i_n_t_e_g_e_r_)
         The version identifier is an integer with value:

                          10000_*Major+ 100_*Minor+_P_a_t_c_h

         Note that  in  releases upto  2.7.10 this  prolog-flag  yielded
         an  atom   holding  the  three   numbers  separated  by   dots.
         The  current representation  is  much easier  for  implementing
         version-conditional statements.

    hhoommee _(_a_t_o_m_)
         SWI-Prolog's  notion  of   the  home-directory.      SWI-Prolog
         uses  it's  home  directory   to  find  its  startup  file   as
         <_h_o_m_e>/startup/startup.<_a_r_c_h> and  to   find  its  library   as
         <_h_o_m_e>/library.

    eexxeeccuuttaabbllee _(_a_t_o_m_)
         ath-name of the running executable.  Used by qsave_program/2 as
         default emulator.

    aarrggvv _(_l_i_s_t_)
         List  is  a   list  of  atoms  representing  the   command-line
         arguments used  to invoke  SWI-Prolog.   Please  note that  aallll
         arguments are included in the list returned.

    ppiippee _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true,  open(pipe(command), mode, Stream),   etc.  are  sup-
         ported.    Can  be  changed to  disable  the use  of  pipes  in
         applications testing this feature.  Not recommended.

    ooppeenn__sshhaarreedd__oobbjjeecctt _(_b_o_o_l_)
         If  true,  open_shared_object/2 and  friends  are  implemented,
         providing access  to shared  libraries (.so  files) or  dynamic
         link libraries (.DLL files).

    sshhaarreedd__oobbjjeecctt__eexxtteennssiioonn _(_a_t_o_m_)
         Extension used  by  the operating  system for  shared  objects.
         so  for most  Unix systems  and  dll for  Windows.    Used  for
         locating  files using  the  file_type  executable.    See  also
         absolute_file_name/3.

    ddyynnaammiicc__ssttaacckkss _(_b_o_o_l_)
         If true,  the system uses some  form of `sparse-memory  manage-
         ment' to realise the stacks.  If  false, malloc()/realloc() are
         used for  the stacks.   In earlier  days this had  consequenses
         for foreign code.   As  of version 2.5,  this is no longer  the
         case.

         Systems using  `sparse-memory management' are  a bit faster  as
         there is no  stack-shifter, and checking the stack-boundary  is
         often realised  by the hardware  using a  `guard-page'.   Also,
         memory  is actually  returned to  the  system after  a  garbage
         collection or call  to trim_stacks/0 (called by prolog/0  after
         finishing a user-query).

    cc__lliibbss _(_a_t_o_m_)
         Libraries passed  to the C-linker  when SWI-Prolog was  linked.
         May  be  used to  determine  the  libraries  needed  to  create
         statically linked extensions for SWI-Prolog.  See section 5.7.

    cc__cccc _(_a_t_o_m_)
         Name of the  C-compiler used to  compile SWI-Prolog.   Normally
         either gcc or cc.  See section 5.7.

    cc__llddffllaaggss _(_a_t_o_m_)
         Special  linker  flags  passed   to  link  SWI-Prolog.      See
         section 5.7.

    rreeaaddlliinnee _(_b_o_o_l_)
         If  true,  SWI-Prolog  is linked  with  the  readline  library.
         This is  done by  default if  you have  this library  installed
         on your  system.    It is  also true  for  the Win32  plwin.exe
         version of SWI-Prolog, which realises a subset  of the readline
         functionality.

    ssaavveedd__pprrooggrraamm _(_b_o_o_l_)
         If  true,   Prolog  is   started  from   a  state  saved   with
         qsave_program/[1,2].

    rruunnttiimmee _(_b_o_o_l_)
         If true,  SWI-Prolog  is compiled  with  -DO_RUNTIME,  disabling
         various useful development  features (currently the tracer  and
         profiler).

    mmaaxx__iinntteeggeerr _(_i_n_t_e_g_e_r_)
         Maximum  integer  value.     Most  arithmetic  operations  will
         automatically convert  to floats if  integer values above  this
         are returned.

    mmiinn__iinntteeggeerr _(_i_n_t_e_g_e_r_)
         Minimum integer value.

    mmaaxx__ttaaggggeedd__iinntteeggeerr _(_i_n_t_e_g_e_r_)
         Maximum integer value represented as a `tagged' value.   Tagged
         integers require  4-bytes storage  and are  used for  indexing.
         Larger integers are represented as `indirect data'  and require
         16-bytes  on  the  stacks  (though  a  copy   requires  only  4
         additional bytes).

    mmiinn__ttaaggggeedd__iinntteeggeerr _(_i_n_t_e_g_e_r_)
         Start of the tagged-integer value range.

    ffllooaatt__ffoorrmmaatt _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         C printf() format specification used by write/1  and friends to
         determine how floating point numbers are printed.   The default
         is %g.    The  specified value  is passed  to printf()  without
         further  checking.    For  example,  if you  want  more  digits
         printed, %.12g  will print all floats  using 12 digits  instead
         of the default 6.  See also format/[1,2],  write/1, print/1 and
         portray/1.

    ttoopplleevveell__pprriinntt__ooppttiioonnss _(_t_e_r_m_, _c_h_a_n_g_e_a_b_l_e_)
         This  argument   is  given   as  option-list   to  write_term/2
         for   printing    results   of   queries.         Default    is
         [quoted(true), portray(true), max_depth(10)].

    ddeebbuuggggeerr__pprriinntt__ooppttiioonnss _(_t_e_r_m_, _c_h_a_n_g_e_a_b_l_e_)
         This  argument is  given  as  option-list to  write_term/2  for
         printing  goals  by  the  debugger.     Modified  by  the  `w',
         `p'  and  `<_N>  d'  commands  of  the  debugger.    Default  is
         [quoted(true), portray(true), max_depth(10)].

    ccoommppiilleedd__aatt _(_a_t_o_m_)
         Describes when the  system has been  compiled.  Only  available
         if  the C-compiler  used  to  compile SWI-Prolog  provides  the
         __DATE__and __TIME__macros.

    cchhaarraacctteerr__eessccaappeess _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true  (default),  read/1 interprets  \  escape sequences  in
         quoted atoms and strings.  May be changed.   This flag is local
         to the module in which it is changed.

    ddoouubbllee__qquuootteess _(_c_o_d_e_s_,_c_h_a_r_s_,_a_t_o_m_,_s_t_r_i_n_g_, _c_h_a_n_g_e_a_b_l_e_)
         This flag  determines  how double-quotes  strings are  read  by
         Prolog and is ---like  character_escapes--- maintained for  each
         module.    If codes  (default), a  list  of character-codes  is
         returned,  if chars  a list  of  one-character atoms,  if  atom
         double  quotes  are the  same  as  single-quotes  and  finally,
         string reads the text into a Prolog string  (see section 3.23).
         See also atom_chars/2 and atom_codes/2.

    aallllooww__vvaarriiaabbllee__nnaammee__aass__ffuunnccttoorr _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true  (default  is false),  Functor(arg) is  read  as if  it
         was written 'Functor'(arg).   Some applications use the  Prolog
         read/1  predicate for  reading  an application  defined  script
         language.   In these  cases, it is  often difficult to  explain
         none-Prolog  users  of  the  application  that   constants  and
         functions can only  start with a  lowercase letter.   Variables
         can be  turned into atoms  starting with  an uppercase atom  by
         calling read_term/2 using the option variable_names and binding
         the variables to their name.   Using this feature, F(x)  can be
         turned into valid syntax for such script languages.   Suggested
         by Robert van Engelen.  SWI-Prolog specific.

    hhiissttoorryy _(_i_n_t_e_g_e_r_, _c_h_a_n_g_e_a_b_l_e_)
         If _i_n_t_e_g_e_r >0,  support Unix csh(1)  like history as described
         in section  2.7.    Otherwise,  only support  reusing  commands
         through the  commandline editor.   The default  is to set  this
         prolog-flag  to 0  if a  commandline  editor is  provided  (see
         prolog-flag readline) and 15 otherwise.

    ggcc _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default), the garbage collector is active.   If false,
         neither garbage-collection,  nor stack-shifts will take  place,
         even not on explicit request.  May be changed.

    aaggcc__mmaarrggiinn _(_i_n_t_e_g_e_r_, _c_h_a_n_g_e_a_b_l_e_)
         If  this amount  of  atoms  has  been created  since  the  last
         atom-garbage collection,  perform  atom garbage  collection  at
         the  first  opportunity.    Initial  value  is  10,000.     May
         be  changed.    A  value  of 0  (zero)  disables  atom  garbage
         collection.  See also PL_register_atom().

    iissoo _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         Include some  weird ISO compatibility  that is incompatible  to
         normal SWI-Prolog behaviour.   Currently  it has the  following
         effect:

           o is/2  and  evaluation  under flag/3  do  not  automatically
             convert  floats  to integers  if  the float  represents  an
             integer.

           o In  the standard order  of terms (see  section 3.6.1),  all
             floats are before all integers.

    ooppttiimmiissee _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true, compile in optimised mode.  The initial  value is true
         if Prolog was started with the -O commandline option.

         Currently   optimise   compilation   implies   compilation   of
         arithmetic, and  deletion of redundant  true/0 that may  result
         from expand_goal/2.

         Later versions might imply various other optimisations  such as
         integrating small  predicates into  their callers,  eliminating
         constant expressions and other predictable constructs.   Source
         code  optimisation is  never  applied  to predicates  that  are
         declared dynamic (see dynamic/1).

    aauuttoollooaadd _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default) autoloading of library functions  is enabled.
         See section 2.13.

    vveerrbboossee__aauuttoollooaadd _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true the  normal  consult  message  will be  printed  if  a
         library is autoloaded.  By default this  message is suppressed.
         Intended to be used for debugging purposes.

    ttrraaccee__ggcc _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true  (false  is  the  default),  garbage  collections  and
         stack-shifts  will  be  reported on  the  terminal.     May  be
         changed.

    mmaaxx__aarriittyy _(_u_n_b_o_u_n_d_e_d_)
         ISO  prolog-flag  describing  there  is  no  maximum  arity  to
         compound terms.

    iinntteeggeerr__rroouunnddiinngg__ffuunnccttiioonn _(_d_o_w_n_,_t_o_w_a_r_d___z_e_r_o_)
         SO prolog-flag  describing rounding  by //  and rem  arithmetic
         functions.  Value depends on the C-compiler used.

    bboouunnddeedd _(_t_r_u_e_)
         ISO prolog-flag describing  integer representation is bound  by
         min_integer and min_integer.

    ttttyy__ccoonnttrrooll _(_b_o_o_l_)
         Determines whether  the terminal  is switched to  raw mode  for
         get_single_char/1,  which also  reads the  user-actions for  the
         trace.  May be set.  See also the +/-tty command-line option.

    ddeebbuugg__oonn__eerrrroorr _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true,  start  the  tracer  after   an  error  is  detected.
         Otherwise just continue  execution.   The goal that raised  the
         error  will normally  fail.    See  also fileerrors/2  and  the
         prolog-flag report_error.   May be changed.   Default is  true,
         except for the runtime version.

    rreeppoorrtt__eerrrroorr _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true, print  error messages, otherwise  suppress them.   May
         be changed.  See also  the debug_on_error prolog-flag.   Default
         is true, except for the runtime version.

    ffiillee__nnaammee__vvaarriiaabblleess _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If   true  (default   false),   expand   $varname  and   ~   in
         arguments  of  builtin-predicates  that  accept  a   file  name
         (open/3, exists_file/1,  access_file/2,  etc.).   The  predicate
         expand_file_name/2  should  be  used   to  expand   environment
         variables and wildcard patterns.  This  prolog-flag is intended
         for backward compatibility with older versions of SWI-Prolog.

    uunniixx _(_b_o_o_l_)
         If  true,  the  operating  system  is  some  version  of  Unix.
         Defined  if the  C-compiler used  to  compile this  version  of
         SWI-Prolog either defines __unix__ or unix.

    wwiinnddoowwss _(_b_o_o_l_)
         If  true,   the  operating  system  is  an  implementation   of
         Microsoft Windows (3.1, 95, NT, etc.).


sseett__pprroolloogg__ffllaagg((_+_K_e_y_, _+_V_a_l_u_e))
    Define  a new prolog-flag or change its value.  _K_e_y is an atom.   If
    the  flag is  a system-defined  flag that is  not marked  _c_h_a_n_g_e_a_b_l_e
    above,  an  attempt to  modify the flag  yields a  permission_error.
    If  the  provided _V_a_l_u_e  does not  match  the type  of the  flag,  a
    type_error is raised.

    In  addition  to  ISO,  SWI-Prolog allows  for  user-defined  prolog
    flags.   The type of the  flag is determined from the  initial value
    and cannot be changed afterwards.


22..1122 AAnn oovveerrvviieeww ooff hhooookk pprreeddiiccaatteess

SWI-Prolog provides a large number of hooks, mainly  to control handling
messages, debugging,  startup, shut-down, macro-expansion,  etc.   Below
is  a  summary  of  all  defined  hooks  with  an  indication  of  their
portability.

  o portray/1
    Hook into write_term/3 to alter the way terms are printed (ISO).

  o message_hook/3
    Hook  into  print_message/2 to  alter the  way system  messages  are
    printed (Quintus/SICStus).

  o library_directory/1
    Hook  into absolute_file_name/3 to define  new library  directories.
    (most Prolog system).

  o file_search_path/2
    Hook   into   absolute_file_name/3  to   define   new   search-paths
    (Quintus/SICStus).

  o term_expansion/2
    Hook  into  load_files/1  to  modify  read  terms  before  they  are
    compiled (macro-processing) (most Prolog system).

  o goal_expansion/2
    Same as term_expansion/2 for individual goals (SICStus).

  o prolog_edit:locate/3
    Hook into edit/1 to locate objects (SWI).

  o prolog_edit:edit_source/1
    Hook into edit/1 to call some internal editor (SWI).

  o prolog_edit:edit_command/2
    Hook into edit/1 to define the external editor to use (SWI).

  o prolog_list_goal/1
    Hook  into the tracer  to list the  code associated to a  particular
    goal (SWI).

  o prolog_trace_interception/4
    Hook into the tracer to handle trace-events (SWI).

  o resource/3
    Defines a new resource (not really a hook, but similar) (SWI).

  o exception/3
    Old  attempt  to  a  generic  hook mechanism.     Handles  undefined
    predicates (SWI).


22..1133 AAuuttoommaattiicc llooaaddiinngg ooff lliibbrraarriieess

If ---at  runtime--- an undefined predicate  is trapped the system  will
first try to import the predicate from the module's default  module.  If
this fails the _a_u_t_o  _l_o_a_d_e_r is activated.  On first activation  an index
to all library files  in all library directories is loaded in  core (see
library_directory/1).  If the undefined predicate can be  located in the
one of the libraries  that library file is automatically loaded  and the
call to  the (previously undefined)  predicate is resumed.   By  default
this  mechanism loads  the  file silently.     The current_prolog_flag/2
verbose_autoload is provided  to get verbose loading.   The  prolog-flag
autoload can be used to enable/disable the entire auto load system.

The auto-loader only  works if the unknown  flag (see unknown/2) is  set
to trace (default).  A more appropriate interaction  with this flag will
be considered.

Autoloading  only handles  (library) source  files that  use the  module
mechanism  described  in  chapter  4.     The  files   are  loaded  with
use_module/2 and only the  trapped undefined predicate will be  imported
to the module  where the undefined predicate  was called.  Each  library
directory  must hold  a file  INDEX.pl  that contains  an index  to  all
library files  in the directory.    This file consists  of lines of  the
following format:

index(Name, Arity, Module, File).

The predicate make/0 scans the autoload libraries and  updates the index
if it  exists, is  writable and out-of-date.   It  is advised to  create
an empty  file called  INDEX.pl in  a library directory  meant for  auto
loading  before doing  anything  else.   This  index  file can  then  be
updated  by running  the prolog  make_library_index/1 (`%'  is the  Unix
prompt):

% mkdir ~/lib/prolog
% cd !$
% pl -g true -t 'make_library_index(.)'

If  there  are  more than  one  library  files  containing  the  desired
predicate the following search schema is followed:

 1. If  there is a  library file  that defines the  module in which  the
    undefined predicate is trapped, this file is used.

 2. Otherwise  library files  are considered  in the  order they  appear
    in  the  library_directory/1  predicate  and  within  the  directory
    alphabetically.


mmaakkee__lliibbrraarryy__iinnddeexx((_+_D_i_r_e_c_t_o_r_y))
    Create  an index for this  directory.  The  index is written to  the
    file  'INDEX.pl' in the specified directory.   Fails with a  warning
    if the directory does not exist or is write protected.


22..1144 GGaarrbbaaggee CCoolllleeccttiioonn

SWI-Prolog  version  1.4  was  the  first  release  to  support  garbage
collection.     Together with  last-call  optimisation  this  guarantees
forward chaining programs do not waste infinite amounts of memory.


22..1155 SSyynnttaaxx NNootteess

SWI-Prolog uses  standard `Edinburgh'  syntax.   A  description of  this
syntax can be found in the Prolog books referenced  in the introduction.
Below are some  non-standard or non-common constructs that are  accepted
by SWI-Prolog:

  o 0'<_c_h_a_r>
    This  construct is not accepted by all Prolog systems that  claim to
    have  Edinburgh compatible syntax.  It describes the ASCII  value of
    <_c_h_a_r>.   To  test whether C is  a lower case character  one can use
    between(0'a, 0'z, C).

  o /* .../* ...*/ ...*/
    The  /* ...*/  comment statement  can be  nested.    This is  useful
    if  some  code with  /* ...*/  comment statements  in it  should  be
    commented out.


22..1155..11 IISSOO SSyynnttaaxx SSuuppppoorrtt

SWI-Prolog offers ISO compatible extensions to the Edinburgh syntax.


22..1155..11..11 CChhaarraacctteerr EEssccaappee SSyynnttaaxx

Within quoted  atoms (using single quotes:   '<_a_t_o_m>'special  characters
are represented  using escape-sequences.    An escape  sequence is  lead
in  by the  backslash  (\) character.    The  list of  escape  sequences
is compatible  with the  ISO standard,  but contains  one extension  and
the interpretation of numerically specified characters  is slightly more
flexible to improve compatibility.

\a
    Alert character.  Normally the ASCII character 7 (beep).

\b
    Backspace character.

\c
    No  output.    All  input  characters  upto but  not  including  the
    first  non-layout  character  are skipped.     This allows  for  the
    specification of pretty-looking  long lines.  For compatibility with
    Quintus Prolog.  Nor supported by ISO. Example:

    format('This is a long line that would look better if it was \c
           split across multiple physical lines in the input')

\<RETURN>
    No  output.   Skips input till the  next non-layout character or  to
    the end of the next line.  Same intention as \c but ISO compatible.

\f
    Form-feed character.

\n
    Next-line character.

\r
    Carriage-return only (i.e. go back to the start of the line).

\t
    Horizontal tab-character.

\v
    Vertical tab-character (ASCII 11).

\x23
    Hexadecimal  specification of a character.   23 is just an  example.
    The  `x'  may be  followed by  a maximum  of  2 hexadecimal  digits.
    The  closing \  is optional.   The  code \xa\3  emits the  character
    10  (hexadecimal `a')  followed by  `3'.   The code  \x201 emits  32
    (hexadecimal  `20') followed by `1'.  According to ISO,  the closing
    \  is  obligatory and  the  number  of digits  is  unlimited.    The
    SWI-Prolog  definition allows for ISO compatible specification,  but
    is compatible with other implementations.

\40
    Octal   character  specification.     The  rules  and   remarks  for
    hexadecimal  specifications apply to  octal specifications too,  but
    the maximum allowed number of octal digits is 3.

\<_c_h_a_r_a_c_t_e_r>
    Any  character immediately preceded  by a \  and not covered by  the
    above  escape sequences is copied verbatim.   Thus, '\\' is  an atom
    consisting  of a single \ and  '\'' and '''' both describe the  atom
    with a single '.

Character      escaping      is     only      available      if      the
current_prolog_flag(character_escapes, true) is active (default).    See
current_prolog_flag/2.   Character escapes conflict with writef/2  in two
ways:   \40  is interpreted  as decimal  40 by  writef/2, but  character
escapes  handling by  read has  already interpreted  as  32 (40  octal).
Also, \l is translated to  a single `l'.  It is adviced to use  the more
widely supported  format/[2,3] predicate instead.   If you insist  using
writef, either switch  character_escapes to  false, or use double \\,  as
in writef('\\l').


22..1155..11..22 SSyynnttaaxx ffoorr nnoonn--ddeecciimmaall nnuummbbeerrss

SWI-Prolog  implements  both  Edinburgh  and  ISO   representations  for
non-decimal numbers.   According to  Edinburgh syntax, such numbers  are
written as <_r_a_d_i_x>'<_n_u_m_b_e_r>, where <_r_a_d_i_x> is  a number between 2 and 36.
ISO defines binary,  octal and hexadecimal numbers using 0[bxo]<_n_u_m_b_e_r>.
For example:  A is 0b100 \/ 0xf00  is a valid expression.   Such numbers
are always unsigned.


22..1166 SSyysstteemm lliimmiittss


22..1166..11 LLiimmiittss oonn mmeemmoorryy aarreeaass

SWI-Prolog has  a number of  memory areas which are  only enlarged to  a
certain limit.   The  default sizes for these  areas should suffice  for
most applications, but big  applications may require larger ones.   They
are modified  by command  line options.    The table  below shows  these
areas.   The first column  gives the option name  to modify the size  of
the area.  The option character is immediately followed  by a number and
optionally by  a k or  m.   With k or  no unit  indicator, the value  is
interpreted in Kbytes (1024 bytes), with m, the  value is interpreted in
Mbytes (10241* 024 bytes).

The local-,  global- and  trail-stack are  limited to 128  Mbytes on  32
bit processors,  or more in general to  2 to the power bits-per-long - 5
bytes.
       ___________________________________________________________
       |_Option_|Default_|Area_name______|Description____________|_||-L||2Mllooccaa||llTssttaacckkhe|l||||ocal|stack is used

       |        |                        to  store   the  execu- |             |            ||
       |        |                        tion  environments   of |             |            ||
       |        |                        procedure  invocations. |             |            ||
       |        |                        The  space for  an  en- |             |            ||
       |        |                        vironment is  reclaimed |             |            ||
       |        |                        when  it  fails,  exits |             |            ||
       |        |                        without leaving  choice |             |            ||
       |        |                        points,   the  alterna- |             |            ||
       |        |                        tives are  cut of  with |             |            ||
       |        |                                                |             |            ||

       |        |                        the  !/0  predicate  or |             |            ||
       |        |                        no  choice points  have |             |            ||
       |        |                        been created  since the |             |            ||
       |        |                        invocation and the last |             |            ||
       |        |                        subclause  is   started |             |            ||
       |        |                        (tail recursion optimi- |             |            ||
       ||       ||      |               ||sation).                ||            |            ||

       |   -G   | 4M    |gglloobbaall ssttaacckk   ||Theusglobaled stacktois store| terms
       |        |       |               ||created during Prolog's |
       |        |       |               ||execution.    Terms  on |
       |        |       |               ||                        |
       |        |       |               ||this stack will  be re- |
       |        |       |               ||claimed by backtracking |
       |        |       |               ||to a  point before  the |
       |        |       |               ||term  was   created  or |
       |        |       |               ||by  garbage  collection |

       |        |       |               ||(provided  the term  is |
       ||       ||      ||              ||no||longer referenced).  ||
       |   -T   | 4M    |ttrraaiill ssttaacckk    ||Theusetraild stackto isstore|  as-
       |        |       |               ||signments during execu- |
       |        |       |               ||                        |
       |        |       |               ||tion.   Entries on this |
       |        |       |               ||stack remain  alive un- |

       |        |       |               ||til backtracking before |
       |        |       |               ||the  point of  creation |
       |        |       |               ||or the  garbage collec- |
       |        |       |               ||tor determines they are |
       ||       ||      ||              ||nor||needed any longer.  ||

       |   -A   | 1M    |aarrgguummeenntt ssttaacckk ||Theusargumentestackd isto|  store   one
       |        |       |               ||of   the   intermediate |
       |        |       |               ||code interpreter's reg- |
       |        |       |               ||isters.     The  amount |
       |        |       |               ||of space needed on this |
       |        |       |               ||stack is determined en- |
       |        |       |               ||                        |
       |        |       |               ||tirely by the  depth in |
       |        |       |               ||which terms  are nested |
       |        |       |               ||in  the   clauses  that |

       |        |       |               ||constitute the program. |
       |        |       |               ||Overflow is most likely |
       |        |       |               ||when using long strings |
       |________|_______|_______________||in_a_clause.____________|_

                        Table 2.2:  Memory areas


22..1166..11..11 TThhee hheeaapp

With  the heap,  we  refer  to the  memory  area  used by  malloc()  and
friends.  SWI-Prolog uses the area to store  atoms, functors, predicates
and their  clauses, records and  other dynamic data.   As of  SWI-Prolog
2.8.5, no limits are  imposed on the addresses returned by  malloc() and
friends.

On  some machines,  the  runtime stacks  described above  are  allocated
using `sparse allocation'.   Virtual space upto the limit is  claimed at
startup and  committed and released  while the  area grows and  shrinks.
On Win32  platform this  is realised using  VirtualAlloc() and  friends.
On Unix systems this is realised using mmap().


22..1166..22 OOtthheerr LLiimmiittss

CCllaauusseess  Currently the  following limitations  apply to  clauses.    The
    arity  may not be more than 1024 and the number of  variables should
    be less than 65536.

AAttoommss aanndd SSttrriinnggss  SWI-Prolog  has no  limits  on  the  sizes  of  atoms
    and  strings.   read/1  and its derivatives  however normally  limit
    the  number  of newlines  in  an  atom or  string  to 5  to  improve
    error  detection  and recovery.    This  can  be switched  off  with
    style_check/1.

AAddddrreessss ssppaaccee  SWI-Prolog  data  is  packed  in  a 32-bit  word,   which
    contains  both type and value information.  The size of  the various
    memory areas is limited  to 128 Mb for each of the areas, except for
    the program heap, which is not limited.

IInntteeggeerrss  Integers are  32-bit  to  the  user,  but  integers  upto  the
    value  of  the max_tagged_integer prolog-flag  are represented  more
    efficiently.

FFllooaattss  Floating  point  numbers   are  represented  as  native   double
    precision floats, 64 bit IEEE on most machines.


22..1166..33 RReesseerrvveedd NNaammeess

The boot compiler  (see -b option) does  not support the module  system.
As large parts of  the system are written in Prolog itself we  need some
way to  avoid name clashes  with the  user's predicates, database  keys,
etc.   Like Edinburgh C-Prolog [Pereira, 1986] all predicates,  database
keys, etc. that should  be hidden from the user start with a  dollar ($)
sign (see style_check/1).


CChhaapptteerr 33..  BBUUIILLTT--IINN PPRREEDDIICCAATTEESS


33..11 NNoottaattiioonn ooff PPrreeddiiccaattee DDeessccrriippttiioonnss

We have  tried to  keep the  predicate descriptions  clear and  concise.
First  the predicate  name is  printed  in bold  face, followed  by  the
arguments in  italics.   Arguments  are preceded by  a `+',  `-' or  `?'
sign.    `+'  indicates the  argument is  input  to the  predicate,  `-'
denotes output and  `?'  denotes `either  input or output'.   Constructs
like `op/3' refer to the predicate `op' with arity `3'.


33..22 CChhaarraacctteerr rreepprreesseennttaattiioonn

In  traditional (Edinburgh-)  Prolog, characters  are represented  using
_c_h_a_r_a_c_t_e_r_-_c_o_d_e_s.   Character codes are  integer indices into a  specific
character set.   Traditionally  the character  set was 7-bits  US-ASCII.
Since a long while  8-bit character sets are allowed,  providing support
for  national character  sets,  of  which  iso-latin-1 (ISO  8859-1)  is
applicable  to many  western  languages.    Text-files are  supposed  to
represent a sequence of character-codes.

ISO Prolog introduces three types, two of which  are used for characters
and one for accessing binary streams (see open/4).  These types are:

  o _c_o_d_e
    A  _c_h_a_r_a_c_t_e_r_-_c_o_d_e is  an  integer representing  a single  character.
    As  files  may  use  multi-byte encoding  for  supporting  different
    character  sets (utf-8 encoding for example), reading a code  from a
    text-file is in general not the same as reading a byte.

  o _c_h_a_r
    Alternatively,  characters  may  be  represented  as  _o_n_e_-_c_h_a_r_a_c_t_e_r_-
    _a_t_o_m_s.    This is  a  very natural  representation, hiding  encoding
    problems  from  the  programmer as  well  as providing  much  easier
    debugging.

  o _b_y_t_e
    Bytes are used for accessing binary-streams.

The  current  version  of  SWI-Prolog  does  not   provide  support  for
multi-byte character encoding.  This implies for example  that it is not
capable of  breaking a  multi-byte encoded  atom into characters.    For
SWI-Prolog, bytes  and codes  are the same  and one-character-atoms  are
simple atoms containing one byte.

To  ease  the  pain  of  these  multiple  representations,  SWI-Prolog's
built-in  predicates dealing  with character-data  work  as flexible  as
possible:   they accept  data in  any of these  formats as  long as  the
interpretation  is unambiguous.     In addition,  for  output  arguments
that are  instantiated, the character  is extracted before  unification.
This implies  that the following two  calls are identical, both  testing
whether the next input characters is an a.

peek_code(Stream, a).
peek_code(Stream, 97).

These  multiple-representations  are  handled  by  a   large  number  of
built-in  predicates,   all   of  which   are  ISO-compatible.       For
converting  betweem  code and  character  there  is  char_code/2.     For
breaking  atoms  and  numbers  into  characters  are  are  atom_chars/2,
atom_codes/2,  number_codes/2 and  number_chars/2.    For  character  I/O
on  streams  there  is get_char/[1,2],  get_code/[1,2],  get_byte/[1,2],
peek_char/[1,2],   peek_code/[1,2],   peek_byte/[1,2],   put_code/[1,2],
put_char/[1,2]  and  put_byte/[1,2].     The  prolog-flag  double_quotes
(see current_prolog_flag/2) controls how  text between double-quotes  is
interpreted.


33..33 LLooaaddiinngg PPrroolloogg ssoouurrccee ffiilleess

This section deals  with loading Prolog source-files.   A Prolog  source
file  is a  text-file (often  referred to  as  _A_S_C_I_I_-_f_i_l_e) containing  a
Prolog program  or part  thereof.   Prolog  source files  come in  three
flavours:

 AA ttrraaddiittiioonnaall   Prolog  source  file  contains  a  Prolog  clauses  and
    directives,  but no  _m_o_d_u_l_e_-_d_e_c_l_a_r_a_t_i_o_n.   They are normally  loaded
    using consult/1 or ensure_loaded/1.

 AA mmoodduullee   Prolog source file  starts with a module  declaration.   The
    subsequent Prolog code  is loaded into the specified module and only
    the _p_u_b_l_i_c predicates  are made available to the context loading the
    module.   Module  files are normally loaded  using use_module/[1,2].
    See chapter 4 for details.

 AA iinncclluuddee   Prolog source file is loaded using the  include/1 directive
    and normally contains only directives.

Prolog  source-files are  located  using  absolute_file_name/3 with  the
following options:

locate_prolog_file(Spec, Path) :-
        absolute_file_name(Spec,
                           [ file_type(prolog),
                             access(read)
                           ],
                           Path).

The file_type(_p_r_o_l_o_g) option is  used to determine the extension of  the
file using  prolog_file_type/2.    The default extension  is .pl.    _S_p_e_c
allows  for the  _p_a_t_h_-_a_l_i_a_s construct  defined  by absolute_file_name/3.
The  most  commonly  used  path-alias  is  library(_L_i_b_r_a_r_y_F_i_l_e).     The
example below loads the library file oset.pl  (containing predicates for
manipulating ordered sets).

:- use_module(library(oset)).

SWI-Prolog   recognises   grammar   rules   ((DCG))   as    defined   in
[Clocksin & Melish, 1987].     The  user  may   define  additional  com-
pilation  of  the   source  file  by  defining  the  dynamic   predicate
term_expansion/2.    Transformations  by  this  predicate  overrule  the
systems  grammar  rule transformations.     It  is not  allowed  to  use
assert/1, retract/1 or any other  database predicate in term_expansion/2
other than for local computational purposes.

Directives  may be  placed  anywhere  in a  source  file,  invoking  any
predicate.    They are  executed when  encountered.    If the  directive
fails, a warning is printed.  Directives are specified  by :-/1 or ?-/1.
There is no difference between the two.

SWI-Prolog   does   not   have   a   separate   reconsult/1   predicate.
Reconsulting  is  implied automatically  by  the  fact that  a  file  is
consulted which is already loaded.


llooaadd__ffiilleess((_+_F_i_l_e_s_, _+_O_p_t_i_o_n_s))
    The  predicate load_files/2 is the parent  of all the other  loading
    predicates.    It  currently supports  a subset  of  the options  of
    Quintus  load_files/2.   _F_i_l_e_s is  either specifies a  single, or  a
    list  of  source-files.    The specification  for a  source-file  is
    handled  absolute_file_name/2.  See this predicate  for the supported
    expansions.  _O_p_t_i_o_n_s is a list of options using the format

         _O_p_t_i_o_n_N_a_m_e(_O_p_t_i_o_n_V_a_l_u_e)

    The following options are currently supported:

    iiff((_C_o_n_d_i_t_i_o_n))
         Load the  file only  if the specified  condition is  satisfied.
         The value  true loads the  file unconditionally, changed  loads
         the file  if it  was not loaded  before, or  has been  modified
         since it was loaded the last time, not_loaded loads the file if
         it was not loaded before.

    mmuusstt__bbee__mmoodduullee((_B_o_o_l))
         If true,  raise an  error if  the file  is not  a module  file.
         Used by use_module/[1,2].

    iimmppoorrttss((_L_i_s_t_O_r_A_l_l))
         If  all and  the  file is  a  module file,  import  all  public
         predicates.  Otherwise import only the named predicates.   Each
         predicate is refered to  as <_n_a_m_e>/<_a_r_i_t_y>.  This  option has no
         effect if the file is not a module file.

    ssiilleenntt((_B_o_o_l))
         If  true, load  the  file  without printing  a  message.    The
         specified  value is  the  default for  all  files loaded  as  a
         result of loading the specified files.


ccoonnssuulltt((_+_F_i_l_e))
    Read  _F_i_l_e as a Prolog  source file.  _F_i_l_e  may be a list of  files,
    in  which case all members  are consulted in turn.   _F_i_l_e may  start
    with  the csh(1) special sequences ~,   <_u_s_e_r>and $<_v_a_r>.  _F_i_l_e  may
    also be library(Name),  in which case the libraries are searched for
    a  file with the specified  name.  See  also library_directory/1 and
    file_search_path/2.  consult/1  may be abbreviated by just  typing a
    number of file names in a list.  Examples:

        ?- consult(load).       % consult load or load.pl
        ?- [library(quintus)].  % load Quintus compatibility library

    Equivalent to load_files(Files, []).


eennssuurree__llooaaddeedd((_+_F_i_l_e))
    If the file  is not already loaded, this is equivalent to consult/1.
    Otherwise,   if  the  file  defines  a  module,  import  all  public
    predicates.    Finally,  if the  file is  already loaded,  is not  a
    module  file and the context module  is not the global user  module,
    ensure_loaded/1 will call consult/1.

    With the semantics, we  hope to get as closely possible to the clear
    semantics  without the presence  of a module  system.   Applications
    using modules should consider using use_module/[1,2].

    Equivalent to load_files(Files, [if(changed)]).


iinncclluuddee((_+_F_i_l_e))
    Pretend  the  terms   in  _F_i_l_e  are  in  the  source-file  in  which
    :- include(File)  appears.  The include construct is  only honnoured
    if  it appears  as  a directive  in a  source-file.   Normally  _F_i_l_e
    contains a sequence of directives.


rreeqquuiirree((_+_L_i_s_t_O_f_N_a_m_e_A_n_d_A_r_i_t_y))
    Declare  that  this file/module  requires the  specified  predicates
    to  be defined ``with  their commonly accepted  definition''.   This
    predicate originates from  the Prolog portability layer for XPCE. It
    is  intended to  provide a  portable mechanism  for specifying  that
    this module requires the specified predicates.

    The implementation normally  first verifies whether the predicate is
    already defined.   If not, it will search the libraries and load the
    required library.

    SWI-Prolog, having autoloading,  does nnoott load the library.  Instead
    it  creates a procedure  header for the  predicate if this does  not
    exist.    This will flag  the predicate  as `undefined'.   See  also
    check/0 and autoload/0.


mmaakkee
    Consult  all source  files that  have been changed  since they  were
    consulted.   It checks _a_l_l  loaded source files:  files loaded  into
    a  compiled state  using pl -c ...  and files  loaded using  consult
    or  one of its  derivatives.  The  predicate make/0 is called  after
    edit/1,  automatically reloading all  modified files.   It the  user
    uses  an external editor (in a separate window), make/0  is normally
    used to update the program after editing.


lliibbrraarryy__ddiirreeccttoorryy((_?_A_t_o_m))
    Dynamic  predicate used  to specify  library directories.    Default
    ./lib,  ~/lib/prolog and  the system's library  (in this order)  are
    defined.    The  user may  add library  directories using  assert/1,
    asserta/1 or remove system defaults using retract/1.


ffiillee__sseeaarrcchh__ppaatthh((_+_A_l_i_a_s_, _?_P_a_t_h))
    Dynamic  predicate used to specify `path-aliases'.  This  feature is
    best described using an example.  Given the definition

    file_search_path(demo, '/usr/lib/prolog/demo').

    the  file specification demo(myfile)  will be expanded to  /usr/lib/
    prolog/demo/myfile.   The second  argument of file_search_path/2 may
    be another alias.

    Below  is the  initial definition  of the file  search path.    This
    path  implies  swi(<_P_a_t_h>)  refers  to  a  file  in  the  SWI-Prolog
    home   directory.     The  alias  foreign(<_P_a_t_h>) is   intended  for
    storing   shared  libraries  (.so  or   .DLL  files).     See   also
    load_foreign_library/[1,2].

    user:file_search_path(library, X) :-
            library_directory(X).
    user:file_search_path(swi, Home) :-
            current_prolog_flag(home, Home).
    user:file_search_path(foreign, swi(ArchLib)) :-
            current_prolog_flag(arch, Arch),
            atom_concat('lib/', Arch, ArchLib).
    user:file_search_path(foreign, swi(lib)).

    The  file_search_path/2expansion  is used by all loading  predicates
    as well as by absolute_file_name/[2,3].


eexxppaanndd__ffiillee__sseeaarrcchh__ppaatthh((_+_S_p_e_c_, _-_P_a_t_h))
    Unifies  _P_a_t_h  will   all  possible  expansions  of  the  file  name
    specification _S_p_e_c.  See also absolute_file_name/3.


pprroolloogg__ffiillee__ttyyppee((_?_E_x_t_e_n_s_i_o_n_, _?_T_y_p_e))
    This  dynamic multifile predicate defined in module  user determines
    the  extensions considered by file_search_path/2.  _E_x_t_e_n_s_i_o_n is  the
    filename  extension without the leading  dot, _T_y_p_e denotes the  type
    as  used by the file_type(_T_y_p_e) option of  file_search_path/2.   Here
    is the initial definition of prolog_file_type/2:

    user:prolog_file_type(pl,       prolog).
    user:prolog_file_type(Ext,      prolog) :-
            current_prolog_flag(associate, Ext),
            Ext \== pl.
    user:prolog_file_type(qlf,      qlf).
    user:prolog_file_type(Ext,      executable) :-
            current_prolog_flag(shared_object_extension, Ext).

    Users  may  wish to  change  the extension  used for  Prolog  source
    files  to avoid  conflicts (for  example with  perl) as  well as  to
    be  compatible with  some specific  implementation.   The  preferred
    alternative extension is .pro.


ssoouurrccee__ffiillee((_?_F_i_l_e))
    Succeeds  if _F_i_l_e  is a  loaded Prolog  source file.    _F_i_l_e is  the
    absolute and canonical path to the source-file.


ssoouurrccee__ffiillee((_?_P_r_e_d_, _?_F_i_l_e))
    Is   true   if  the   predicate  specified   by   _P_r_e_d  was   loaded
    from   file  _F_i_l_e,  where  _F_i_l_e  is  an  absolute  path   name  (see
    absolute_file_name/2).  Can be used with  any instantiation pattern,
    but the database  only maintains the source file for each predicate.
    See also clause_property/2.


pprroolloogg__llooaadd__ccoonntteexxtt((_?_K_e_y_, _?_V_a_l_u_e))
    Determine loading context.  The following keys are defined:

      ________________________________________________________________
      |__KKeeyy______________________||DDeessccrriippttiioonn________________________________________________________________________||
      || module        |Module into which file is loaded               |
      | file          |File loaded                                    |
      | stream        |Stream identifier (see current_input/1)        |

      | directory     |Directory in which _F_i_l_e lives.                 |
      | term_position |Position of last  term read.  Term of  the form|
      |_______________|'$stream_position'(0,<_L_i_n_e>,0,0,0)_____________|

    Quintus compatibility predicate.  See also source_location/2.


ssoouurrccee__llooccaattiioonn((_-_F_i_l_e_, _-_L_i_n_e))
    If  the last term has been read from a physical file (i.e.  not from
    the file user or  a string), unify _F_i_l_e with an absolute path to the
    file  and _L_i_n_e with the  line-number in the file.   New code  should
    use prolog_load_context/2.


tteerrmm__eexxppaannssiioonn((_+_T_e_r_m_1_, _-_T_e_r_m_2))
    Dynamic  predicate, normally not defined.  When defined by  the user
    all  terms read during consulting that are given to  this predicate.
    If  the predicate succeeds Prolog will assert _T_e_r_m_2 in  the database
    rather  then the read term  (_T_e_r_m_1).  _T_e_r_m_2 may  be a term of a  the
    form  `?- _G_o_a_l' or `:- _G_o_a_l'.  _G_o_a_l is then treated  as a directive.
    If _T_e_r_m_2 is a  list all terms of the list are stored in the database
    or  called (for directives).   If  _T_e_r_m_2 is of  the form below,  the
    system  will assert _C_l_a_u_s_e and record the  indicated source-location
    with it.

         '$source_location'(<_F_i_l_e>, <_L_i_n_e>):<_C_l_a_u_s_e>

    When compiling a  module (see chapter 4 and the directive module/2),
    expand_term/2  will first try  term_expansion/2 in the module  being
    compiled  to  allow  for  term-expansion rules  that  are  local  to
    a  module.     If  there  is  no  local  definition,  or  the  local
    definition  fails  to translate  the  term,  expand_term/2 will  try
    term_expansion/2  in module user.    For compatibility with  SICStus
    and  Quintus Prolog,  this feature  should not  be used.   See  also
    expand_term/2, goal_expansion/2 and expand_goal/2.


eexxppaanndd__tteerrmm((_+_T_e_r_m_1_, _-_T_e_r_m_2))
    This  predicate  is  normally  called by  the  compiler  to  perform
    preprocessing.   First it calls term_expansion/2.   If this predicate
    fails  it performs  a grammar-rule translation.    If this fails  it
    returns the first argument.


ggooaall__eexxppaannssiioonn((_+_G_o_a_l_1_, _-_G_o_a_l_2))
    Like   term_expansion/2,   goal_expansion/2  provides   for   macro-
    expansion  of Prolog  source-code.   Between  expand_term/2 and  the
    actual  compilation, the body of clauses analysed and the  goals are
    handed  to expand_goal/2, which  uses the goal_expansion/2 hook to do
    user-defined expansion.

    The  predicate goal_expansion/2 is first  called in the module  that
    is being compiled, and then on the user module.

    Only  goals  apearing   in  the  body  of  clauses  when  reading  a
    source-file  are expanded using mechanism,  and only if they  appear
    literally  in the clause, or  as an argument to the  meta-predicates
    not/1, call/1 or  forall/2.  A real predicate definition is required
    to deal with dynamically constructed calls.


eexxppaanndd__ggooaall((_+_G_o_a_l_1_, _-_G_o_a_l_2))
    This  predicate  is  normally  called by  the  compiler  to  perform
    preprocessing.   First it calls goal_expansion/2.  If this  fails it
    returns the first argument.


aatt__iinniittiiaalliizzaattiioonn((_+_G_o_a_l))
    Register   _G_o_a_l   to   be   ran   when   the   system   initialises.
    Initialisation  takes place after  reloading a .qlf (formerly  .wic)
    file  as well as after reloading a  saved-state.  The hooks  are run
    in  the order they were registered.  A warning message is  issued if
    _G_o_a_l fails, but execution continues.  See also at_halt/1


aatt__hhaalltt((_+_G_o_a_l))
    Register  _G_o_a_l to be ran when the  system halts.  The hooks  are run
    in  the order they were registered.  Success or failure  executing a
    hook is ignored.  These hooks may not call halt/[0,1].


iinniittiiaalliizzaattiioonn((_+_G_o_a_l))
    Call  _G_o_a_l and  register it using  at_initialization/1.   Directives
    that  do  other things  that  creating clauses,  records,  flags  or
    setting  predicate attributes should normally be written  using this
    tag  to ensure the  initialisation is executed  when a saved  system
    starts.  See also qsave_program/[1,2].


ccoommppiilliinngg
    Succeeds if the  system is compiling source files with the -c option
    into  an  intermediate code  file.    Can be  used to  perform  code
    optimisations in expand_term/2 under this condition.


pprreepprroocceessssoorr((_-_O_l_d_, _+_N_e_w))
    Read  the input file via a  Unix process that acts as  preprocessor.
    A  preprocessor is specified  as an atom.   The first occurrence  of
    the  string `%f' is replaced by the  name of the file to  be loaded.
    The  resulting atom  is called as  a Unix  command and the  standard
    output  of this command is loaded.   To use the Unix  C preprocessor
    one should define:

    ?- preprocessor(Old, '/lib/cpp -C -P %f'), consult(...).

    Old = none


33..33..11 QQuuiicckk llooaadd ffiilleess

The features described in this section should be regarded aallpphhaa.

As of  version 2.0.0, SWI-Prolog  supports compilation of individual  or
multiple Prolog  sourcefiles into  `Quick Load  Files'.   A `Quick  Load
Files' (.qlf  file) stores  the contents  of the file  in a  precompiled
format.

These files load  considerably faster than sourcefiles and are  normally
more compact.    They are  machine independent  and may  thus be  loaded
on any  implementation of  SWI-Prolog.   Note however  that clauses  are
stored as virtual  machine instructions.   Changes to the compiler  will
generally make old compiled files unusable.

Quick Load Files  are created using qcompile/1.   They are loaded  using
consult/1  or one  of  the other  file-loading predicates  described  in
section 3.3.   If consult is given  the explicit .pl file, it will  load
the Prolog  source.  When  given the .qlf file,  it will load the  file.
When no extension is specified, it will load the  .qlf file when present
and the fileextpl file otherwise.


qqccoommppiillee((_+_F_i_l_e))
    Takes  a  single file  specification  like consult/1  (i.e.  accepts
    constructs like library(LibFile)  and creates a Quick Load File from
    _F_i_l_e.   The file-extension of this file  is .qlf.  The base  name of
    the Quick Load File is the same as the input file.

    If   the   file   contains   `:- consult(+File)'   or   `:- [+File]'
    statements,  the  referred files  are compiled  into  the same  .qlf
    file.    Other  directives  will  be stored  in  the .qlf  file  and
    executed in the same fashion as when loading the .pl file.

    For  term_expansion/2,  the same rules  as described in section  2.10
    apply.

    Source  references (source_file/2) in the  Quick Load File refer  to
    the Prolog source file from which the compiled code originates.


33..44 LLiissttiinngg aanndd EEddiittoorr IInntteerrffaaccee

SWI-Prolog  offers an  extensible  interface which  allows the  user  to
edit objects  of the program:   predicates,  modules, files,  etc.   The
editor interface is  implemented by edit/1 and consists of  three parts:
_l_o_c_a_t_i_n_g, _s_e_l_e_c_t_i_n_g and _s_t_a_r_t_i_n_g _t_h_e _e_d_i_t_o_r.

Any of  these parts may  be extended or redefined  by adding clauses  to
various multi-file  (see multifile/1) predicates  defined in the  module
prolog_edit.

The built-in  edit specifications for edit/1  (see prolog_edit:locate/3)
are described below.

   ___________________________________________________________________
   |__________________________________________FFuullllyy__ssppeecciiffiieedd__oobbjjeeccttss____________________________________________||
   || <_M_o_d_u_l_e>:<_N_a_m_e>/<_A_r_i_t_y>R|efers a predicate                      |
   | module(<_M_o_d_u_l_e>)      |Refers to a module                       |
   | file(<_P_a_t_h>)          |Refers to a file                         |

   |_source_file(<_P_a_t_h>)___R|efers_to_a_loaded_source-file___________|_
   |__________________________________________AAmmbbiigguuoouuss__ssppeecciiffiiccaattiioonnss__________________________________________||
   || <_N_a_m_e>/<_A_r_i_t_y>        R|efers this predicate in any module      |
   | <_N_a_m_e>                |Refers  to  (1) named  predicate  in  any|
   |                       |module  with any  arity,  (2) a  (source)|
   |_______________________|file_or_(3)_a_module.____________________|_


eeddiitt((_+_S_p_e_c_i_f_i_c_a_t_i_o_n))
    First  exploits prolog_edit:locate/3to  translate _S_p_e_c_i_f_i_c_a_t_i_o_n into
    a  list  of  _L_o_c_a_t_i_o_n_s.    If there  is  more than  one  `hit',  the
    user  is  allows to  select  from the  found  locations.    Finally,
    prolog_edit:edit_source/1 is  used  to invoke  the user's  preferred
    editor.


pprroolloogg__eeddiitt::llooccaattee((_+_S_p_e_c_, _-_F_u_l_l_S_p_e_c_, _-_L_o_c_a_t_i_o_n))
    Where  _S_p_e_c is  the  specification provided  through edit/1.    This
    multifile  predicate  is  used to  enumerate  locations at  with  an
    object satisfying the given  _S_p_e_c can be found.  _F_u_l_l_S_p_e_c is unified
    with  the complete specification for  the object.  This  distinction
    is  used to  allow for ambiguous  specifications.   For example,  if
    _S_p_e_c  is  an  atom,  which appears  as  the base-name  of  a  loaded
    file  and as  the name  of a predicate,  _F_u_l_l_S_p_e_c will  be bound  to
    file(_P_a_t_h) or _N_a_m_e/_A_r_i_t_y.

    _L_o_c_a_t_i_o_n  is a list of attributes  of the location.  Normally,  this
    list  will contain  the term file(_F_i_l_e)  and ---if available---  the
    term line(_L_i_n_e).


pprroolloogg__eeddiitt::llooccaattee((_+_S_p_e_c_, _-_L_o_c_a_t_i_o_n))
    Same  as prolog_edit:locate/3, but only deals with  fully-sepecified
    objects.


pprroolloogg__eeddiitt::eeddiitt__ssoouurrccee((_+_L_o_c_a_t_i_o_n))
    Start  editor on _L_o_c_a_t_i_o_n.  See  prolog_edit:locate/3for  the format
    of  a location  term.   This  multi-file predicate  is normally  not
    defined.  If it succeeds, edit/1 assumes the editor is started.

    If  it fails,  edit/1 will invoke  an external editor.   The  editor
    to  be invoked  is determined from  the evironment variable  EDITOR,
    which  may  be set  from the  operating system  or  from the  Prolog
    initialisation file using setenv/2.   If no editor is defined, vi is
    the default in Unix systems, and notepad on Windows.

    The  predicate  prolog_edit:edit_command/2 defines  how  the  editor
    will be invoked.


pprroolloogg__eeddiitt::eeddiitt__ccoommmmaanndd((_+_E_d_i_t_o_r_, _-_C_o_m_m_a_n_d))
    Determines  how _E_d_i_t_o_r is  to be invoked using  shell/1.  _E_d_i_t_o_r  is
    the  determined editor  (see edit_source/1), without  the full  path
    specification,  and without  possible (exe) extension.   _C_o_m_m_a_n_d  is
    an  atom describing  the command.   The  pattern %f  is replaced  by
    the  full file-name  of the  location, and  %d by  the line  number.
    If  the  editor can  deal with  starting at  a specified  line,  two
    clauses  should be provided,  one holding only  the %f pattern,  and
    one holding both patterns.

    The  default contains  definitions for vi,  emacs, emacsclient,  vim
    and notepad (latter without line-number version).

    Please contribute your specifications to jan@swi.psy.uva.nl.


pprroolloogg__eeddiitt::llooaadd
    Normally  not-defined  multifile  predicate.    This  predicate  may
    be  defined  to provide  loading hooks  for  user-extensions to  the
    edit  module.   For example,  XPCE provides the  code below to  load
    library(swi_edit),  containing  definitions  to locate  classes  and
    methods  as well as  to bind this  package to the PceEmacs  built-in
    editor.

    :- multifile prolog_edit:load/0.

    prolog_edit:load :-
            ensure_loaded(library(swi_edit)).


lliissttiinngg((_+_P_r_e_d))
    List  specified predicates  (when an  atom is  given all  predicates
    with  this name will  be listed).   The listing  is produced on  the
    basis  of the  internal representation,  thus loosing user's  layout
    and variable name information.  See also portray_clause/1.


lliissttiinngg
    List all predicates of the database using listing/1.


ppoorrttrraayy__ccllaauussee((_+_C_l_a_u_s_e))
    Pretty  print a  clause.   A clause  should be specified  as a  term
    `<_H_e_a_d> :- <_B_o_d_y>'.  Facts are represented as `<_H_e_a_d> :- true'.


33..55 VVeerriiffyy TTyyppee ooff aa TTeerrmm


vvaarr((_+_T_e_r_m))
    Succeeds if _T_e_r_m currently is a free variable.


nnoonnvvaarr((_+_T_e_r_m))
    Succeeds if _T_e_r_m currently is not a free variable.


iinntteeggeerr((_+_T_e_r_m))
    Succeeds if _T_e_r_m is bound to an integer.


ffllooaatt((_+_T_e_r_m))
    Succeeds if _T_e_r_m is bound to a floating point number.


nnuummbbeerr((_+_T_e_r_m))
    Succeeds if _T_e_r_m is bound to an integer or a floating point number.


aattoomm((_+_T_e_r_m))
    Succeeds if _T_e_r_m is bound to an atom.


ssttrriinngg((_+_T_e_r_m))
    Succeeds if _T_e_r_m is bound to a string.


aattoommiicc((_+_T_e_r_m))
    Succeeds  if _T_e_r_m is bound to  an atom, string, integer or  floating
    point number.


ccoommppoouunndd((_+_T_e_r_m))
    Succeeds  if _T_e_r_m is bound to a  compound term.  See  also functor/3
    and =../2.


ggrroouunndd((_+_T_e_r_m))
    Succeeds if _T_e_r_m holds no free variables.


33..66 CCoommppaarriissoonn aanndd UUnniiffiiccaattiioonn oorr TTeerrmmss


33..66..11 SSttaannddaarrdd OOrrddeerr ooff TTeerrmmss

Comparison and  unification of arbitrary  terms.   Terms are ordered  in
the so called ``standard order''.  This order is defined as follows:

 1. _V_a_r_i_a_b_l_e_s <_A_t_o_m_s <_S_t_r_i_n_g_s <_N_u_m_b_e_r_s <_T_e_r_m_s

 2. _O_l_d _V_a_r_i_a_b_l_e <_N_e_w _V_a_r_i_a_b_l_e

 3. _A_t_o_m_s are compared alphabetically.

 4. _S_t_r_i_n_g_s are compared alphabetically.

 5. _N_u_m_b_e_r_s  are compared  by value.   Integers  and floats are  treated
    identically.

 6. _C_o_m_p_o_u_n_d  terms are  first checked  on  their arity,  then on  their
    functor-name  (alphabetically)  and  finally  recursively  on  their
    arguments, leftmost argument first.

If  the  prolog_flag  (see  current_prolog_flag/2)  iso  is  defined,  all
floating point numbers precede all integers.


_+_T_e_r_m_1 == _+_T_e_r_m_2
    Succeeds  if _T_e_r_m_1  is  equivalent to  _T_e_r_m_2.   A  variable is  only
    identical to a sharing variable.


_+_T_e_r_m_1 \== _+_T_e_r_m_2
    Equivalent to \+Term1 == Term2.


_+_T_e_r_m_1 = _+_T_e_r_m_2
    Unify _T_e_r_m_1 with _T_e_r_m_2.  Succeeds if the unification succeeds.


uunniiffyy__wwiitthh__ooccccuurrss__cchheecckk((_+_T_e_r_m_1_, _+_T_e_r_m_2))
    As  =/2, but  using _s_o_u_n_d_-_u_n_i_f_i_c_a_t_i_o_n.    That is,  a variable  only
    unifies  to  a term  if  this term  does  not contain  the  variable
    itself.  To illustrate this, consider the two goals below:

    1 ?- A = f(A).

    A = f(f(f(f(f(f(f(f(f(f(...))))))))))
    2 ?- unify_with_occurs_check(A, f(A)).

    No

    I.e.   the  first  creates  a  _c_y_c_l_i_c_-_t_e_r_m,  which  is   printed  as
    an   infinitly  nested  f/1  term  (see  the   max_depth   option  of
    write_term/2).  The second executes  logically sound unification and
    thus fails.


_+_T_e_r_m_1 \= _+_T_e_r_m_2
    Equivalent to \+Term1 = Term2.


_+_T_e_r_m_1 =@= _+_T_e_r_m_2
    Succeeds  if _T_e_r_m_1  is `structurally  equal' to _T_e_r_m_2.    Structural
    equivalence  is weaker  than equivalence (==/2),  but stronger  than
    unification  (=/2).  Two terms are structurally equal if  their tree
    representation  is identical  and they  have the  same `pattern'  of
    variables.  Examples:

               a  =@=  A       false
               A  =@=  B       true
          x(A,A)  =@=  x(B,C)  false
          x(A,A)  =@=  x(B,B)  true
          x(A,B)  =@=  x(C,D)  true


_+_T_e_r_m_1 \=@= _+_T_e_r_m_2
    Equivalent to `\+Term1 =@= Term2'.


_+_T_e_r_m_1 @< _+_T_e_r_m_2
    Succeeds if _T_e_r_m_1 is before _T_e_r_m_2 in the standard order of terms.


_+_T_e_r_m_1 @=< _+_T_e_r_m_2
    Succeeds if both terms  are equal (==/2) or _T_e_r_m_1 is before _T_e_r_m_2 in
    the standard order of terms.


_+_T_e_r_m_1 @> _+_T_e_r_m_2
    Succeeds if _T_e_r_m_1 is after _T_e_r_m_2 in the standard order of terms.


_+_T_e_r_m_1 @>= _+_T_e_r_m_2
    Succeeds  if both terms are equal (==/2) or _T_e_r_m_1 is after  _T_e_r_m_2 in
    the standard order of terms.


ccoommppaarree((_?_O_r_d_e_r_, _+_T_e_r_m_1_, _+_T_e_r_m_2))
    Determine or test  the _O_r_d_e_r between two terms in the standard order
    of terms.  _O_r_d_e_r is one of <, >  or =, with the obvious meaning.


33..77 CCoonnttrrooll PPrreeddiiccaatteess

The predicates of  this section implement control structures.   Normally
these constructs  are translated  into virtual  machine instructions  by
the compiler.   It is still  necessary to implement these constructs  as
true predicates  to support meta-calls,  as demonstrated in the  example
below.  The  predicate finds all currently defined atoms of  1 character
long.   Note that  the cut has no  effect when called  via one of  these
predicates (see !/0).

one_character_atoms(As) :-
        findall(A, (current_atom(A), atom_length(A, 1)), As).


ffaaiill
    Always  fail.   The  predicate fail/0  is translated  into a  single
    virtual machine instruction.


ttrruuee
    Always  succeed.  The predicate  true/0 is translated into a  single
    virtual machine instruction.


rreeppeeaatt
    Always succeed, provide an infinite number of choice points.


!
    Cut.    Discard choice  points of  parent frame  and frames  created
    after  the parent  frame.   Note  that the  control structures  ;/2,
    |/2,  ->/2  and \+/1  are normally handled  by the  compiler and  do
    not  create a frame,  which implies the  cut operates through  these
    predicates.   Some  examples are given below.   Note the  difference
    between t3/1 and t4/1.   Also note the effect of call/1 in t5/0.  As
    the  argument of call/1 is  evaluated by predicates rather than  the
    compiler the cut has no effect.

       t1 :- (a, !, fail ; b).        % cuts a/0 and t1/0
       t2 :- (a -> b, !  ; c).        % cuts b/0 and t2/0
       t3(G) :- a, G, fail.           % if `G = !'  cuts a/0 and t1/1
       t4(G) :- a, call(G), fail.     % if `G = !'  cut has no effect
       t5 :- call((a, !, fail ; b)).  % Cut has no effect

       t6 :- \+(a, !, fail ; b).      % cuts a/0 and t6/0


_+_G_o_a_l_1 , _+_G_o_a_l_2
    Conjunction.   Succeeds if both  `Goal1' and `Goal2' can be  proved.
    It  is defined as (this  definition does not lead  to a loop as  the
    second comma is handled by the compiler):

    Goal1, Goal2 :- Goal1, Goal2.


_+_G_o_a_l_1 ; _+_G_o_a_l_2
    The `or' predicate is defined as:

    Goal1 ; _Goal2 :- Goal1.
    _Goal1 ; Goal2 :- Goal2.


_+_G_o_a_l_1 | _+_G_o_a_l_2
    Equivalent  to ;/2.    Retained for compatibility  only.   New  code
    should use ;/2.  Still nice though for grammar rules.


_+_C_o_n_d_i_t_i_o_n -> _+_A_c_t_i_o_n
    If-then  and  If-Then-Else.    The  ->/2  construct commits  to  the
    choices  made  at  its  left-hand  side,   destroying  choice-points
    created  inside the  clause (by  ;/2), or  by goals  called by  this
    clause.   Unlike !/0,  the choicepoint of  the predicate as a  whole
    (due  to multiple clauses)  is nnoott destroyed.   The combination  ;/2
    and ->/2  is defines as:

    If -> Then; _Else :- If, !, Then.
    If -> _Then; Else :- !, Else.
    If -> Then :- If, !, Then.

    Note   that  the   operator  precedence  relation   between  ;   and
    ->   ensure  If -> Then ; Else  is  actually  a  term  of  the  form
    ;(->(If, Then), Else).     The  first  two  clauses  belong  to  the
    definition of ;/2), while only the last defines ->/2 .


_+_C_o_n_d_i_t_i_o_n *-> _+_A_c_t_i_o_n _; _+_E_l_s_e
    This  construct implements  the so-called `soft-cut'.   The  control
    is  defined as follows:   If _C_o_n_d_i_t_i_o_n succeeds  at least once,  the
    semantics  is the same  as (_C_o_n_d_i_t_i_o_n, _A_c_t_i_o_n).   If _C_o_n_d_i_t_i_o_n  does
    not  succeed, the semantics is that of (_C_o_n_d_i_t_i_o_n, _E_l_s_e).   In other
    words,  If _C_o_n_d_i_t_i_o_n succeeds  at least once,  simply behave as  the
    conjunction of _C_o_n_d_i_t_i_o_n and _A_c_t_i_o_n, otherwise execute _E_l_s_e.


\+ _+_G_o_a_l
    Succeeds  if  `Goal'  cannot  be  proven (mnemonic:    +  refers  to
    _p_r_o_v_a_b_l_e  and  the  backslash  (\)  is  normally  used  to  indicate
    negation).


33..88 MMeettaa--CCaallll PPrreeddiiccaatteess

Meta call  predicates are used  to call terms  constructed at run  time.
The basic meta-call mechanism offered by SWI-Prolog is  to use variables
as a  subclause (which  should of  course be bound  to a  valid goal  at
runtime).   A  meta-call is  slower than a  normal call  as it  involves
actually searching the database at runtime for the  predicate, while for
normal calls this search is done at compile time.


ccaallll((_+_G_o_a_l))
    Invoke  _G_o_a_l as a  goal.   Note that clauses  may have variables  as
    subclauses,  which is identical to call/1, except when  the argument
    is bound to the cut.  See !/0.


ccaallll((_+_G_o_a_l_, _+_E_x_t_r_a_A_r_g_1_, _._._.))
    Append  _E_x_t_r_a_A_r_g_1_, _E_x_t_r_a_A_r_g_2_,  _._._.   to  the argument  list of  _G_o_a_l
    and  call the result.   For  example, call(plus(1), 2, X) will  call
    plus/3, binding _X to 3.

    The call/[2..]   construct is handled by the compiler, which implies
    that  redefinition as  a predicate has  no effect.   The  predicates
    call/[2-6]  are defined as true  predicates, so they can be  handled
    by interpreted code.


aappppllyy((_+_T_e_r_m_, _+_L_i_s_t))
    Append  the members of  _L_i_s_t to the arguments  of _T_e_r_m and call  the
    resulting  term.   For  example:   apply(plus(1), [2, X]) will  call
    plus(1, 2, X).   apply/2 is  incorporated in the virtual machine  of
    SWI-Prolog.   This implies that the overhead can be compared  to the
    overhead  of call/1.  New code should use call/[2..]   if the length
    of _L_i_s_t is  fixed, which is more widely supported and faster because
    there is no need to build and examine the argument list.


nnoott((_+_G_o_a_l))
    Succeeds  when _G_o_a_l cannot  be proven.   Retained for  compatibility
    only.  New code should use \+/1.


oonnccee((_+_G_o_a_l))
    Defined as:

    once(Goal) :-
            Goal, !.

    once/1  can  in  many  cases  be replaced  with  ->/2.     The  only
    difference  is how the  cut behaves  (see !/0).   The following  two
    clauses are identical:

    1) a :- once((b, c)), d.
    2) a :- b, c -> d.


iiggnnoorree((_+_G_o_a_l))
    Calls  _G_o_a_l  as once/1,  but succeeds,  regardless  of whether  _G_o_a_l
    succeeded or not.  Defined as:

    ignore(Goal) :-
            Goal, !.
    ignore(_).


ccaallll__wwiitthh__ddeepptthh__lliimmiitt((_+_G_o_a_l_, _+_L_i_m_i_t_, _-_R_e_s_u_l_t))
    If  _G_o_a_l can be proven  without recursion deeper than _L_i_m_i_t  levels,
    call_with_depth_limit/3 succeeds,  binding  _R_e_s_u_l_t  to  the  deepest
    recursion  level  used  during the  proof.    Otherwise,  _R_e_s_u_l_t  is
    unified  with depth_limit_exceeded  if the limit was exceeded  during
    the  proof,  or the  entire predicate  fails if  _G_o_a_l fails  without
    exceeding _L_i_m_i_t.

    The  depth-limit is guarded by the internal machinery.   This differ
    from  the  depth  computed  based  on a  theoretical  model.     For
    example,  true/0  is  translated  into an  inlined  virtual  machine
    instruction.   Also, repeat/0 is not implemented as below, but  as a
    non-deterministic foreign predicate.

    repeat.
    repeat :-
            repeat.

    As  a  result, call_with_depth_limit/3 may  still loop  inifitly  on
    programs  that should  theoretically finish  in finite time.    This
    problem  can be cured by  using Prolog equivalents to such  built-in
    predicates.

    This   predicate  may  be   used  for  theorem-provers  to   realise
    techniques  like _i_t_e_r_r_a_t_i_v_e  _d_e_e_p_e_n_i_n_g.   It  was implemented  after
    discussion with Steve Moyle smoyle@ermine.ox.ac.uk.


33..99 IISSOO ccoommpplliiaanntt EExxcceeppttiioonn hhaannddlliinngg

SWI-Prolog defines the predicates catch/3 and throw/1  for ISO compliant
raising  and catching  of exceptions.    In  the current  implementation
(2.9.0), only part of  the built-in predicates generate exceptions.   In
general, exceptions are implemented for I/O and arithmetic.


ccaattcchh((_:_G_o_a_l_, _+_C_a_t_c_h_e_r_, _:_R_e_c_o_v_e_r))
    Behaves  as call/1 if  no exception is  raised when executing  _G_o_a_l.
    If  a exception  is raised  using throw/1 while  _G_o_a_l executes,  and
    the  _G_o_a_l is the innermost goal  for which _C_a_t_c_h_e_r unifies with  the
    argument  of throw/1,  all choicepoints generated  by _G_o_a_l are  cut,
    and _R_e_c_o_v_e_r is called as in call/1.

    The  overhead of calling a  goal through catch/3 is very  comparable
    to call/1.  Recovery from an exception has a similar overhead.


tthhrrooww((_+_E_x_c_e_p_t_i_o_n))
    Raise an exception.   The system will look for the innermost catch/3
    ancestor  for which _E_x_c_e_p_t_i_o_n unifies  with the _C_a_t_c_h_e_r argument  of
    the catch/3 call.  See catch/3 for details.

    If  there is no  catch/3 willing to catch  the error in the  current
    Prolog  context,  the  toplevel  (prolog/0) catches  the  error  and
    prints  a  warning  message.    If  an  exception was  raised  in  a
    callback  from C (see  chapter 5), PL_next_solution() will fail  and
    the exception context can be retrieved using PL_exception().


33..99..11 DDeebbuuggggiinngg aanndd eexxcceeppttiioonnss

Before  the introduction  of exceptions  in SWI-Prolog  a runtime  error
was handled  by printing  an error  message, after  which the  predicate
failed.   If  the prolog_flag (see current_prolog_flag/2) debug_on_error
was in effect  (default), the tracer was  switched on.  The  combination
of the  error message and trace  information is generally sufficient  to
locate the error.

With exception handling,  things are different.   A programmer may  wish
to trap an  exception using catch/3 to avoid  it reaching the user.   If
the  exception is  not handled  by user-code,  the interactive  toplevel
will trap it to prevent termination.

If  we  do  not  take  special  precautions,   the  context  information
associated with  an unexpected exception (i.e.  a programming error)  is
lost.  Therefore,  if an exception is raised, which is not  caught using
catch/3 and the toplevel is running, the error will  be printed, and the
system will enter trace mode.

If the system  is in an non-interactive  callback from foreign code  and
there is no catch/3  active in the current context, it  cannot determine
whether or  not the  exception will  be caught by  the external  routine
calling Prolog.    It will  then base  its behaviour on  the prolog_flag
debug_on_error:

  o _c_u_r_r_e_n_t___p_r_o_l_o_g___f_l_a_g_(_d_e_b_u_g___o_n___e_r_r_o_r_, _f_a_l_s_e_)
    The  exception does  not trap the  debugger and  is returned to  the
    foreign  routine  calling Prolog,  where it  can  be accessed  using
    PL_exception().  This is the default.

  o _c_u_r_r_e_n_t___p_r_o_l_o_g___f_l_a_g_(_d_e_b_u_g___o_n___e_r_r_o_r_, _t_r_u_e_)
    If the exception is  not caught by Prolog in the current context, it
    will trap the tracer to help analysing the context of the error.

While looking for the  context in which an exception takes place,  it is
adviced to switch on debug mode using the predicate debug/0.


33..99..22 TThhee eexxcceeppttiioonn tteerrmm

Builtin  predicates  generates exceptions  using  a  term  error(_F_o_r_m_a_l_,
_C_o_n_t_e_x_t).    The  first argument  is  the  `formal' description  of  the
error,  specifying the class  and generic  defined context  information.
When applicable,  the ISO  error-term definition  is used.   The  second
part  describes some  additional context  to help  the programmer  while
debugging.    In its  most  generic form  this  is a  term of  the  form
context(_N_a_m_e_/_A_r_i_t_y_,  _M_e_s_s_a_g_e), where _N_a_m_e/_A_r_i_t_y  describes the  built-in
predicate  that raised  the error,  and _M_e_s_s_a_g_e  provides an  additional
description of the error.  Any part of this structure  may be a variable
if no information was present.


33..99..33 PPrriinnttiinngg mmeessssaaggeess

The predicate print_message/2 may be  used to print a message term  in a
human readable  format.   The other predicates  from this section  allow
the user  to refine  and extend  the message system.    The most  common
usage of  print_message/2 is to  print error  messages from  exceptions.
The code below  prints errors encountered during the execution  of _G_o_a_l,
without  further propagating  the  exception  and without  starting  the
debugger.

        ...,
        catch(Goal, E,
              ( print_message(error, E),
                fail
              )),
        ...

Another common  use is to  defined message_hook/3 for printing  messages
that are normally _s_i_l_e_n_t, suppressing messages,  redirecting messages or
make something happen in addition to printing the message.


pprriinntt__mmeessssaaggee((_+_K_i_n_d_, _+_T_e_r_m))
    The  predicate print_message/2 is  used to  print messages,  notably
    from  exceptions  in  a human-readable  format.    _K_i_n_d  is  one  of
    informational,  warning, error,  help or silent.   A  human-readable
    message is printed to the stream user_error.

    This  predicate first translates  the _T_e_r_m into  a list of  `message
    lines'  (see print_message_lines/3for  details).  Next it  will call
    the hook  message_hook/3to allow the  user intercepting the message.
    If  message_hook/3 fails it  will print the  message unless _K_i_n_d  is
    silent.

    The  print_message/2  predicate  and  its  rules  are  in  the  file
    <_p_l_h_o_m_e>/boot/messages.pl,   which  may   be   inspected  for   more
    information on the error messages and related error terms.


pprriinntt__mmeessssaaggee__lliinneess((_+_S_t_r_e_a_m_, _+_P_r_e_f_i_x_, _+_L_i_n_e_s))
    Print a  message (see print_message/2) that has  been translated to a
    list of message elements.  The elements of this list are:

    <_F_o_r_m_a_t>--<_A_r_g_s>
         Where _F_o_r_m_a_t is an atom and _A_r_g_s is a list  of format argument.
         Handed to format/3.

    flush
         If this  appears as the  last element,  _S_t_r_e_a_m is flushed  (see
         flush_output/1) and no final newline is generated.

    at_same_line
         If this  appears as  first element,  no prefix  is printed  for
         the first line  and the line-position is  not forced to 0  (see
         format/1, ~N).

    <_F_o_r_m_a_t>
         Handed to format/3 as format(Stream, Format, []).

    nnll
         A new line  is started and if  the message is not complete  the
         _P_r_e_f_i_x is printed too.

    See also print_message/2 and message_hook/3.


mmeessssaaggee__hhooookk((_+_T_e_r_m_, _+_K_i_n_d_, _+_L_i_n_e_s))
    Hook  predicate that may be define  in the module user to  intercept
    messages  from  print_message/2.    _T_e_r_m  and _K_i_n_d  are the  same  as
    passed to  print_message/2.  _L_i_n_e_s is a  list of format statements as
    described with print_message_lines/3.

    This  predicate should  be defined  dynamic and  multifile to  allow
    other modules defining clauses for it too.


33..1100 HHaannddlliinngg ssiiggnnaallss

As  of  version  3.1.0,   SWI-Prolog  is  capable  to   handle  software
interrupts  (signals) in  Prolog as  well as  in foreign  (C) code  (see
section 5.6.12).

Signals are used to handle internal errors (execution  of a non-existing
CPU  intruction,  arithmetic  domain  errors,   illegal  memory  access,
resource  overflow,   etc.),  as   well  as  for  dealing   asynchronous
inter-process communication.

Signals  are  defined  by  the Posix  standard  and  part  of  all  Unix
machines.    The  MS-Windows  Win32  provides  a subset  of  the  signal
handling  routines, lacking  the vital  funtionality to  raise a  signal
in  another   thread  for   achieving  asynchronous  inter-process   (or
inter-thread) communication (Unix kill() function).


oonn__ssiiggnnaall((_+_S_i_g_n_a_l_, _-_O_l_d_, _:_N_e_w))
    Determines  the reaction on  _S_i_g_n_a_l.   _O_l_d is  unified with the  old
    behaviour, while the behaviour  is switched to _N_e_w.  As with similar
    environment-control  predicates,  the  current  value  is  retrieved
    using on_signal(Signal, Current, Current).

    The  action  description  is  an  atom  denoting  the  name  of  the
    predicate  that  will be  called  if _S_i_g_n_a_l  arrives.    on_signal/3
    is  a meta predicate,  which implies that <_M_o_d_u_l_e>:<_N_a_m_e>  refers the
    <_N_a_m_e>/1 in the module <_M_o_d_u_l_e>.

    Two  predicate-names have  special meaning.    throw implies  Prolog
    will  map  the  signal  onto  a Prolog  exception  as  described  in
    section  3.9.   default resets  the handler  to the settings  active
    before SWI-Prolog manipulated the handler.

    After  receiving a signal mapped to throw, the exception  raised has
    the structure

         error(signal(<_S_i_g_N_a_m_e>, <_S_i_g_N_u_m>), <_C_o_n_t_e_x_t>)

    One possible usage of  this is, for example, to limit the time spent
    on  proving a goal.  This  requires a little C-code for  setting the
    alarm timer (see chapter 5):

    #include <SWI-Prolog.h>
    #include <unistd.h>

    foreign_t
    pl_alarm(term_t time)
    { double t;

      if ( PL_get_float(time, &t) )
      { alarm((long)(t+0.5));

        PL_succeed;
      }

      PL_fail;
    }

    install_t
    install()
    { PL_register_foreign("alarm", 1, pl_alarm, 0);
    }

    Next, we can define the following Prolog code:

    :- load_foreign_library(alarm).

    :- on_signal(alrm, throw).

    :- module_transparent
            call_with_time_limit/2.

    call_with_time_limit(Goal, MaxTime) :-
            alarm(MaxTime),
            catch(Goal, signal(alrm, _), fail), !,
            alarm(0).
    call_with_time_limit(_, _) :-
            alarm(0),
            fail.

    The  signal names are  defined by the  C-Posix standards as  symbols
    of  the form  SIG_<_S_I_G_N_A_M_E>.    The Prolog name  for a  signal is the
    lowercase  version of <_S_I_G_N_A_M_E>.  The predicate current_signal/3 may
    be used to map between names and signals.

    Initially,  some  signals  are  mapped to  throw,  while  all  other
    signals  are default.    The following signals  throw an  exception:
    ill, fpe, segv, pipe, alrm, bus, xcpu, xfsz and vtalrm.


ccuurrrreenntt__ssiiggnnaall((_?_N_a_m_e_, _?_I_d_, _?_H_a_n_d_l_e_r))
    Enumerate  the  currently defined  signal  handling.   _N_a_m_e  is  the
    signal  name,  _I_d is  the numerical  identifier and  _H_a_n_d_l_e_r is  the
    currently defined handler (see on_signal/3).


33..1100..11 NNootteess oonn ssiiggnnaall hhaannddlliinngg

Before  deciding  to deal  with  signals  in  your  application,  please
consider the following:

  o _P_o_r_t_i_b_i_l_i_t_y
    On MS-Windows, the  signal interface is severely limited.  Different
    Unix  brands support  different sets  of signals,  and the  relation
    between signal name and number may vary.

  o _S_a_f_e_t_y
    Signal   handling   is   not   completely  safe   in   the   current
    implementation,  especially  if throw  is used  in combination  with
    external  foreign  code.    The  system  will use  the  C  longjmp()
    construct  to  direct control  to the  innermost PL_next_solution(),
    thus  forcing an external procedure to be abandoned at  an arbitrary
    moment.   Most likely not all SWI-Prologs own foreign code  is (yet)
    safe too.

  o _G_a_r_b_a_g_e _C_o_l_l_e_c_t_i_o_n
    The  garbage  collector  will block  all  signals that  are  handled
    by  Prolog.    While handling  a  signal, the  garbage-collector  is
    disabled.

  o _T_i_m_e _o_f _d_e_l_i_v_e_r_y
    Normally  delivery  is immediate  (or as  defined  by the  operating
    system  used).   Signals are blocked  when the garbage collector  is
    active,  and internally delayed if they occur within in  a `critical
    section'.  The critical sections are generally very short.


33..1111 TThhee ``bblloocckk'' ccoonnttrrooll--ssttrruuccttuurree

The  block/3 predicate  and  friends  have been  introduced  before  ISO
compatible  catch/3  exception  handling  for  compatibility  with  some
Prolog implementation.    The only  feature not covered  by catch/3  and
throw/1 is the posibility  to execute global cuts.  New code  should use
catch/3 and throw/1 to deal with exceptions.


bblloocckk((_+_L_a_b_e_l_, _+_G_o_a_l_, _-_E_x_i_t_V_a_l_u_e))
    Execute  _G_o_a_l in a _b_l_o_c_k.   _L_a_b_e_l is the name  of the block.   _L_a_b_e_l
    is  normally an  atom, but  the system imposes  no type  constraints
    and  may even be a variable.   _E_x_i_t_V_a_l_u_e is normally unified  to the
    second argument of an exit/2 call invoked by _G_o_a_l.


eexxiitt((_+_L_a_b_e_l_, _+_V_a_l_u_e))
    Calling  exit/2 makes the innermost _b_l_o_c_k which _L_a_b_e_l  unifies exit.
    The  block's _E_x_i_t_V_a_l_u_e is unified with  _V_a_l_u_e.  If this  unification
    fails the block fails.


ffaaiill((_+_L_a_b_e_l))
    Calling  fail/1 makes the innermost  _b_l_o_c_k which _L_a_b_e_l unifies  fail
    immediately.  Implemented as

    fail(Label) :- !(Label), fail.


!((_+_L_a_b_e_l))
    Cut  all  choice-points created  since the  entry  of the  innermost
    _b_l_o_c_k which _L_a_b_e_l unifies.


33..1122 DDCCGG GGrraammmmaarr rruulleess

Grammar rules  form a comfortable interface  to _d_i_f_f_e_r_e_n_c_e_-_l_i_s_t_s.   They
are designed  both to support  writing parsers  that build a  parse-tree
from a list as for  generating a flat list from a term.   Unfortunately,
Definite  Clause  Grammar (DCG)  handling  is  not part  of  the  Prolog
standard.   Most Prolog  engines implement DCG,  but the details  differ
slightly.

Grammar rules  look like  ordinary clauses using  -->(_2) for  separating
the head and  body rather then :-(_2).   Expanding grammar rules is  done
by expand_term/2, which  adds two additional  argument to each term  for
representing the difference list.   We will illustrate the  behaviour by
defining a rule-set for parsing an integer.

integer(I) -->
        digit(D0),
        digits(D),
        { number_chars(I, [D0|D])
        }.

digits([D|T]) -->
        digit(D), !,
        digits(T).
digits([]) -->
        [].

digit(D) -->
        [D],
        { code_type(D, digit)
        }.

The  body of  a grammar  rule  can contain  three  types of  terms.    A
compound  term interpreted  as a  reference  to a  grammar-rule.    Code
between  {...} is interpreted asa reference to ordinary Prologcode and finally, alist is
interpreted asa sequence ofliterals. The Prolog control-constructs(\+(_1), ->(_2), ;(_/)2,
,(_2) and!(_0)) canbe used ingrammar rules.

Grammar rule-setsare calledusing the builtinpredicates phrase/2and phrase/3:


pphhrraassee((_+_R_u_l_e_S_e_t_, _+_I_n_p_u_t_L_i_s_t))
    Equivalent to phrase(RuleSet, InputList, []).


pphhrraassee((_+_R_u_l_e_S_e_t_, _+_I_n_p_u_t_L_i_s_t_, _-_R_e_s_t))
    Activate the rule-setwith given name. `InputList'is thelist of tokensto parse, `Rest'
    is unified with theremaining tokens ifthe sentence isparsed correctly. The example
    below calls therule-set `integer'defined above.

    ?- phrase(integer(X), "42 times", Rest).

    X = 42
    Rest = [32, 116, 105, 109, 101, 115]


33..1133 DDaattaabbaassee

SWI-Prolog offers threedifferent database mechanisms.  Thefirst one is the commonas-
sert/retract mechanismfor manipulating theclause database. Asfacts and clausesasserted
usingassert/1 orone ofits derivativesbecome partof theprogram thesepredicates compile
the termgiven tothem. retract/1 andretractall/1 haveto unify aterm andtherefore
have todecompile the program. For these reasonsthe assert/retract mechanism isexpen-
sive. Onthe otherhand, once compiled,queries tothe databaseare faster thanquerying the
recorded databasediscussed below. Seealso dynamic/1.

The secondway ofstoring arbitrary termsin thedatabase is usingthe \recordeddatabase".
In thisdatabase terms areassociated with a _k_e_y. Akey can bean atom, integer orterm.
In thelast caseonly the functorand aritydetermine the key.Each key hasa chainof terms
associated withit. New terms canbe added either atthe head orat the tailof this chain.
This mechanismis considerably faster thanthe assert/retract mechanismas terms are not
compiled, butjust copiedinto the heap.

The thirdmechanism is aspecial purpose one. Itassociates an integeror atom witha key,
which isan atom, integeror term. Each key canonly have oneatom or integer associated
with it. It is fasterthan the mechanisms described above,but can only be usedto store
simple statusinformation likecounters, etc.


aabboolliisshh((_:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r))
    Removes all clauses of apredicate with functor _F_u_n_c_t_o_r andarity _A_r_i_t_y from the
    database.  Allpredicate attributes (dynamic, multifile,index, etc.) are reset totheir
    defaults.  Abolishingan imported predicate onlyremoves the import link;the predi-
    cate will keepits old definitionin its definitionmodule. For `cleanup' ofthe dynamic
    database, one shoulduse retractall/1rather than abolish/2.


aabboolliisshh((_+_N_a_m_e_, _+_A_r_i_t_y))
    Same as abolish(Name/Arity). The predicate abolish/2 conformsto the Edin-
    burgh standard, whileabolish/1 isISO compliant.


rreeddeeffiinnee__ssyysstteemm__pprreeddiiccaattee((_+_H_e_a_d))
    This directive may beused both in moduleuser and innormal modules to redefine
    any system predicate. If the systemdefinition is redefined inmodule user, thenew
    definition is the default definitionfor all sub-modules. Otherwise the redefinition is
    local to themodule. The systemdefinition remainsin the modulesystem.

    Redefining system predicatefacilitates thedefinition of compatibilitypackages. Use in
    other context isdiscouraged.


rreettrraacctt((_+_T_e_r_m))
    When _T_e_r_m isan atom ora term itis unified withthe first unifyingfact or clausein
    the database. Thefact or clauseis removedfrom the database.


rreettrraaccttaallll((_+_H_e_a_d))
    All facts orclauses inthe database forwhich the_h_e_a_d unifies with_H_e_a_d areremoved.


aasssseerrtt((_+_T_e_r_m))
    Assert afact or clausein thedatabase. _T_e_r_mis asserted asthe lastfact orclause ofthe
    corresponding predicate.


aasssseerrttaa((_+_T_e_r_m))
    Equivalent to assert/1,but _T_e_r_mis asserted asfirst clauseor fact ofthe predicate.


aasssseerrttzz((_+_T_e_r_m))
    Equivalent to assert/1.


aasssseerrtt((_+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Equivalent to assert/1, but _R_e_f_e_r_e_n_c_e is unified witha unique reference to the
    asserted clause. Thiskey can laterbe usedwith clause/3 orerase/1.


aasssseerrttaa((_+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Equivalent to assert/2,but _T_e_r_mis asserted asfirst clauseor fact ofthe predicate.


aasssseerrttzz((_+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Equivalent to assert/2.


rreeccoorrddaa((_+_K_e_y_, _+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Assert _T_e_r_m inthe recordeddatabase under key_K_e_y. _K_e_yis an integer,atom orterm.
    _R_e_f_e_r_e_n_c_e is unifiedwith aunique reference tothe record(see erase/1).


rreeccoorrddaa((_+_K_e_y_, _+_T_e_r_m))
    Equivalent to recorda(Key, Value, _).


rreeccoorrddzz((_+_K_e_y_, _+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Equivalent to recorda/3,but puts the _T_e_r_mat the tailof the termsrecorded under
    _K_e_y.


rreeccoorrddzz((_+_K_e_y_, _+_T_e_r_m))
    Equivalent to recordz(Key, Value, _).


rreeccoorrddeedd((_+_K_e_y_, _-_V_a_l_u_e_, _-_R_e_f_e_r_e_n_c_e))
    Unify _V_a_l_u_e withthe first termrecorded under _K_e_ywhich does unify. _R_e_f_e_r_e_n_c_eis
    unified with thememory locationof the record.


rreeccoorrddeedd((_+_K_e_y_, _-_V_a_l_u_e))
    Equivalent to recorded(Key, Value, _).


eerraassee((_+_R_e_f_e_r_e_n_c_e))
    Erase a record or clause from thedatabase.  _R_e_f_e_r_e_n_c_e is an integerreturned by
    recorda/3 or recorded/3,clause/3, assert/2,asserta/2 orassertz/2. Other
    integers might conflictwith the internalconsistency of thesystem. Erase can onlybe
    called once on arecord or clause. Asecond call also mightconflict with theinternal
    consistency of thesystem.


ffllaagg((_+_K_e_y_, _-_O_l_d_, _+_N_e_w))
    _K_e_y is anatom, integeror term. Unify _O_l_dwith theold value associatedwith _K_e_y. If
    the key isused forthe firsttime _O_l_dis unified withthe integer0. Then storethe value
    of _N_e_w, which shouldbe an integer, float,atom or arithmeticexpression, under _K_e_y.
    flag/3 is avery fastmechanism for storingsimple factsin the database.Example:

    :- module_transparent succeeds_n_times/2.

    succeeds_n_times(Goal, Times) :-
            (   flag(succeeds_n_times, Old, 0),
                Goal,
                   flag(succeeds_n_times, N, N+1),
                fail
            ;   flag(succeeds_n_times, Times, Old)
            ).


33..1133..11 UUppddaattee vviieeww

Traditionally, Prolog systemsused the _i_m_m_e_d_i_a_t_e  _u_p_d_a_t_e  _v_i_e_w: new clauses became
visible topredicates backtrackingover dynamicpredicates immediatelyand retractedclauses
became invisibleimmediately.

Starting withSWI-Prolog 3.3.0we adherethe _l_o_g_i_c_a_l _u_p_d_a_t_e _v_i_e_w,where backtrackable
predicates that enterthe definition of apredicate will not see anychanges (either caused
by assert/1 orretract/1) to the predicate. This view is theISO standard, the most
commonly usedand themost `safe'. Logicalupdates arerealised bykeeping reference-counts
on predicatesand _g_e_n_e_r_a_t_i_o_ninformation on clauses. Eachchange tothe database causes
an incrementof the generationof the database. Eachgoal is taggedwith the generationin
which itwas started. Each clause is flaggedwith the generation itwas created as wellas
the generationit waserased. Only clauseswith `created'...`erased' interval thatencloses the
generation ofthe currentgoal are consideredvisible.


33..1133..22 IInnddeexxiinngg ddaattaabbaasseess

By default, SWI-Prolog, asmost other implementations, indexes predicates on theirfirst
argument. SWI-Prologallows indexingon otherandmultiple argumentsusing thedeclaration
index/1.

For advanceddatabase indexing,it defines hash_term/2:


hhaasshh__tteerrmm((_+_T_e_r_m_, _-_H_a_s_h_K_e_y))
    If _T_e_r_m is aground term (seeground/1), _H_a_s_h_K_e_y isunified with a positiveinteger
    value thatmay be usedas ahash-key tothe value. If_T_e_r_m isnot ground,the predicate
    succeeds immediately, leaving_H_a_s_h_K_e_y anunbound variable.

    This predicatemay beused tobuild hash-tablesas wellas toexploit argument-indexing
    to find complexterms morequickly.

    The hash-key doesnot relyon temporaryinformation like addressesof atomsand may
    be assumed constantover differentinvocations of SWI-Prolog.


33..1144 DDeeccllaarriinngg pprreeddiiccaatteess pprrooppeerrttiieess

This sectiondescribes directives which manipulateattributes of predicate definitions. The
functors dynamic/1, multifile/1and discontiguous/1 areoperators of priority 1150
(see op/3),which implies thelist ofpredicates they involvecan just bea comma separated
list:

:- dynamic
        foo/0,
        baz/2.

On SWI-Prologall these directivesare just predicates.This implies theycan also becalled
by aprogram. Donot relyon thisfeature if youwant tomaintain portabilityto otherProlog
implementations.


ddyynnaammiicc _+_F_u_n_c_t_o_r_/_+_A_r_i_t_y_, _._._.
    Informs the interpreter thatthe definition ofthe predicate(s) may changeduring ex-
    ecution (using assert/1 and/orretract/1).  Currentlydynamic/1 only stops the
    interpreter from complainingabout undefined predicates(see unknown/2). Futurere-
    leases might prohibitassert/1 andretract/1 for not-dynamicdeclared procedures.


mmuullttiiffiillee _+_F_u_n_c_t_o_r_/_+_A_r_i_t_y_, _._._.
    Informs the systemthat the specifiedpredicate(s) may bedefined overmore than one
    file. This stopsconsult/1 fromredefining a predicatewhen anew definitionis found.


ddiissccoonnttiigguuoouuss _+_F_u_n_c_t_o_r_/_+_A_r_i_t_y_, _._._.
    Informs the systemthat theclauses of thespecified predicate(s)might notbe together
    in the sourcefile. See alsostyle_check/1.


iinnddeexx((_+_H_e_a_d))
    Index theclauses ofthe predicatewith thesame nameandarity as_H_e_a_d onthe specified
    arguments. _H_e_a_d is aterm of whichall arguments areeither `1' (denoting`index this
    argument') or`0' (denoting`do notindex this argument').Indexing hasno implications
    for the semantics of apredicate, only on itsperformance.  If indexingis enabled on
    a predicate a special purposealgorithm is used toselect candidate clauses based on
    the actual arguments ofthe goal. This algorithm checkswhether indexed arguments
    might unify inthe clausehead. Only atoms,integers andfunctors (e.g.name and arity
    of a term) are considered. Indexing is veryuseful for predicates with manyclauses
    representing facts.

    Due to the representation techniqueused at most 4arguments can be indexed. All
    indexed arguments shouldbe inthe first32 argumentsof the predicate.If morethan 4
    arguments are specifiedfor indexingonly thefirst 4will beaccepted. Arguments above
    32 are ignoredfor indexing.

    By default allpredicates with <_a_r_i_t_y> 1are indexed ontheir first argument. Itis
    possible to redefineindexing onpredicates thatalready have clausesattached tothem.
    This willinitiate ascan throughthe predicates clauselist toupdate theindex summary
    information stored witheach clause.

    If_for   example_one  wants  to  represents   sub-types  using  a  fact  list
    `sub_type(Sub, Super)'that shouldbe used both to determinesub- and super types
    one should declaresub_type/2as follows:

    :- index(sub_type(1, 1)).

    sub_type(horse, animal).
    ...
    ...


33..1155 EExxaammiinniinngg tthhee pprrooggrraamm


ccuurrrreenntt__aattoomm((_-_A_t_o_m))
    Successively  unifies _A_t_o_m  with all atoms  known to  the system.   Note  that
    current_atom/1 alwayssucceeds if _A_t_o_mis instantiatedto anatom.


ccuurrrreenntt__ffuunnccttoorr((_?_N_a_m_e_, _?_A_r_i_t_y))
    Successively unifies _N_a_m_ewith the nameand _A_r_i_t_y with thearity of functorsknown
    to the system.


ccuurrrreenntt__ffllaagg((_-_F_l_a_g_K_e_y))
    Successively unifies _F_l_a_g_K_e_ywith allkeys used forflags (seeflag/3).


ccuurrrreenntt__kkeeyy((_-_K_e_y))
    Successively unifies _K_e_ywith allkeys used forrecords (seerecorda/3, etc.).


ccuurrrreenntt__pprreeddiiccaattee((_?_N_a_m_e_, _?_H_e_a_d))
    Successively unifies _N_a_m_ewith thename ofpredicates currently definedand _H_e_a_dwith
    the most generalterm built from_N_a_m_e and thearity of thepredicate. This predicate
    succeeds for allpredicates defined inthe specifiedmodule, imported toit, or inone of
    the modules fromwhich thepredicate will beimported ifit is called.


pprreeddiiccaattee__pprrooppeerrttyy((_?_H_e_a_d_, _?_P_r_o_p_e_r_t_y))
    Succeeds if _H_e_a_d refersto a predicate thathas property _P_r_o_p_e_r_t_y. Can beused to
    test whether apredicate has acertain property,obtain all propertiesknown for _H_e_a_d,
    find all predicateshaving _p_r_o_p_e_r_t_y oreven obtaining allinformation available about
    the current program._P_r_o_p_e_r_t_y is oneof:

    iinntteerrpprreetteedd
         Is true ifthe predicate is defined in Prolog. We return true onthis because,
         although the codeis actually compiled, it is completely transparent, justlike
         interpretedcode.

    bbuuiilltt__iinn
         Istrue if thepredicate islocked asa built-in predicate.This implies itcannot be
         redefinedin its definitionmodule andit can normallynot beseen in thetracer.

    ffoorreeiiggnn
         Istrue if thepredicate isdefined in theC language.

    ddyynnaammiicc
         Istrue if thepredicate isdeclared dynamic usingthe dynamic/1declaration.

    mmuullttiiffiillee
         Istrue if thepredicate isdeclared multifile usingthe multifile/1declaration.

    uunnddeeffiinneedd
         Is trueif a proceduredefinition block for thepredicate exists, butthere are no
         clauses init and itis not declareddynamic. This istrue if thepredicate occurs
         in thebody of aloaded predicate, an attemptto call ithas been madevia one
         ofthe meta-call predicatesor the predicatehad a definitionin thepast. See the
         librarypackage _c_h_e_c_k forexample usage.

    ttrraannssppaarreenntt
         Istrue ifthe predicateis declaredtransparent usingthe module_transparent/1
         declaration.

    eexxppoorrtteedd
         Istrue if thepredicate isin the publiclist ofthe context module.

    iimmppoorrtteedd__ffrroomm((_M_o_d_u_l_e))
         Istrue ifthe predicate isimported intothe contextmodule frommodule _M_o_d_u_l_e.

    iinnddeexxeedd((_H_e_a_d))
         Predicate isindexed (see index/1) according to_H_e_a_d.  _H_e_a_dis a term whose
         nameand arity areidentical tothe predicate. Thearguments areunified with`1'
         forindexed arguments, `0'otherwise.

    ffiillee((_F_i_l_e_N_a_m_e))
         Unify_F_i_l_e_N_a_m_e withthe nameof the sourcefilein whichthe predicateis defined.
         Seealso source_file/2.

    lliinnee__ccoouunntt((_L_i_n_e_N_u_m_b_e_r))
         Unify_L_i_n_e_N_u_m_b_e_r with theline numberof thefirst clauseof thepredicate. Fails
         ifthe predicate isnot associatedwith a file.See also source_file/2.

    nnuummbbeerr__ooff__ccllaauusseess((_C_l_a_u_s_e_C_o_u_n_t))
         Unify_C_l_a_u_s_e_C_o_u_n_t tothe numberof clausesassociated with thepredicate. Fails
         forforeign predicates.


ddwwiimm__pprreeddiiccaattee((_+_T_e_r_m_, _-_D_w_i_m))
    `Do What I Mean'(`dwim') support predicate. _T_e_r_m isa term, which nameand ar-
    ity are used asa predicate specification. _D_w_i_m is instantiatedwith the most general
    term built from _N_a_m_e and the arityof a defined predicate that matches thepredi-
    cate specified by _T_e_r_m inthe `Do What I Mean'sense.  Seedwim_match/2 for `Do
    What I Mean' stringmatching.  Internalsystem predicates are notgenerated, unless
    style_check(+dollar) isactive. Backtracking providesall alternativematches.


ccllaauussee((_?_H_e_a_d_, _?_B_o_d_y))
    Succeeds when_H_e_a_d canbe unifiedwith aclause headand _B_o_d_ywiththe corresponding
    clause body. Gives alternativeclauses on backtracking.For facts _B_o_d_yis unified with
    the atom _t_r_u_e. Normallyclause/2 is usedto find clausedefinitions for apredicate,
    but it canalso beused to findclause headsfor some bodytemplate.


ccllaauussee((_?_H_e_a_d_, _?_B_o_d_y_, _?_R_e_f_e_r_e_n_c_e))
    Equivalent to clause/2,but unifies_R_e_f_e_r_e_n_c_e with aunique reference tothe clause
    (see alsoassert/2, erase/1). If_R_e_f_e_r_e_n_c_e isinstantiated toa referencethe clause's
    head and bodywill beunified with  _H_e_a_dand _B_o_d_y.


nntthh__ccllaauussee((_?_P_r_e_d_, _?_I_n_d_e_x_, _?_R_e_f_e_r_e_n_c_e))
    Provides access tothe clausesof apredicate usingtheir index number.Counting starts
    at 1. If _R_e_f_e_r_e_n_c_e is specifiedit unifies _P_r_e_d withthe most generalterm with the
    same name/arity as the predicate and _I_n_d_e_xwith the index-number of the clause.
    Otherwise the nameand arity of_P_r_e_d are usedto determine thepredicate. If _I_n_d_e_x
    is provided _R_e_f_e_r_e_n_c_ewill beunified with theclause reference. If_I_n_d_e_x isunbound,
    backtracking willyield boththe indicesand thereferences ofall clausesof thepredicate.
    The following examplefinds the2nd clause ofmember/2:

    ?- nth_clause(member(_,_), 2, Ref), clause(Head, Body, Ref).

    Ref = 160088
    Head = system : member(G575, [G578|G579])
    Body = member(G575, G579)


ccllaauussee__pprrooppeerrttyy((_+_C_l_a_u_s_e_R_e_f_, _-_P_r_o_p_e_r_t_y))
    Queries properties of aclause.  _C_l_a_u_s_e_R_e_fis a referenceto a clause asproduced by
    clause/3, nth_clause/3 orprolog_frame_attribute/3. _P_r_o_p_e_r_t_yis one ofthe
    following:

    ffiillee((_F_i_l_e_N_a_m_e))
         Unify _F_i_l_e_N_a_m_ewith the nameof the sourcefile inwhich the clauseis defined.
         Failsif the clauseis notassociated to afile.

    lliinnee__ccoouunntt((_L_i_n_e_N_u_m_b_e_r))
         Unify _L_i_n_e_N_u_m_b_e_rwith theline number ofthe clause. Fails ifthe clause isnot
         associatedto a file.

    ffaacctt
         Trueif the clausehas nobody.

    eerraasseedd
         Trueif the clausehas beenerased, butnot yet reclaimedbecause itis referenced.


33..1166 IInnppuutt aanndd oouuttppuutt

SWI-Prolog providestwo different packagesfor input andoutput. One confirms tothe Ed-
inburgh standard. This packagehas a notion of`current-input' and `current-output'. The
reading and writing predicates implicitlyrefer to these streams.  In thesecond package,
streams areopened explicitlyand theresulting handle isused asan argumentto thereading
andwriting predicateto specifythe sourceor destination. Bothpackages arefully integrated;
the usermay switchfreely between them.


33..1166..11 IInnppuutt aanndd oouuttppuutt uussiinngg iimmpplliicciitt ssoouurrccee aanndd ddeessttiinnaattiioonn

The packagefor implicitinput andoutput destinationis upwardscompatible to DEC-10and
C-Prolog. The readingand writing predicates referto resp. the currentinput- and output
stream. Initially these streamsare connected to theterminal.  Thecurrent output stream
is changedusing tell/1 orappend/1. The current inputstream is changedusing see/1.
The streams current valuecan be obtained using telling/1 foroutput- and seeing/1
for input streams. The table below shows the validstream specifications.  The reserved
namesuser_input, user_output anduser_error arefor neatintegration withthe explicit
streams.

           ___________________________________________________
           | user        |This reservedname refersto the terminal|
           | user_input  I|nput fromthe terminal             |
           | user_output O|utput tothe terminal              |
           | user_error  U|nix errorstream (outputonly)      |

           | <_A_t_o_m>      N|ame ofa Unixfile                  |
           |_pipe(<_A_t_o_m>)N|ame_ofa_Unixcommand_______________|_

Source and destination are either a file,  one of the reserved words above, or a term
`pipe(_C_o_m_m_a_n_d)'.  In thepredicate descriptions below we will call the source/destination
argument `_S_r_c_D_e_s_t'.Below are someexamples ofsource/destination specifications.

           ?- see(data).         %Start readingfrom file `data'.
           ?- tell(user_error).  %Start writingon the errorstream.
           ?- tell(pipe(lpr)).   %Start writingto the printer.

Another example ofusing the pipe/1 construct is shownbelow.  Note that the pipe/1
construct isnot partof Prolog's standardI/O repertoire.

getwd(Wd) :-
        seeing(Old), see(pipe(pwd)),
        collect_wd(String),
        seen, see(Old),
        atom_codes(Wd, String).

collect_wd([C|R]) :-
        get0(C), C \== -1, !,
        collect_wd(R).
collect_wd([]).


sseeee((_+_S_r_c_D_e_s_t))
    Make _S_r_c_D_e_s_t thecurrent input stream. If_S_r_c_D_e_s_t was alreadyopened for reading
    with see/1and hasnot beenclosed since,reading willbe resumed.Otherwise _S_r_c_D_e_s_t
    will be openedand thefile pointer ispositioned atthe start ofthe file.


tteellll((_+_S_r_c_D_e_s_t))
    Make _S_r_c_D_e_s_t thecurrent outputstream. If _S_r_c_D_e_s_twas already openedfor writing
    with tell/1 or append/1 and hasnot been closed since, writing willbe resumed.
    Otherwise the fileis createdor_when existing_truncated. Seealso append/1.


aappppeenndd((_+_F_i_l_e))
    Similar to tell/1,but positions thefile pointerat the endof _F_i_l_e ratherthan trun-
    cating an existingfile. The pipeconstruct isnot accepted bythis predicate.


sseeeeiinngg((_?_S_r_c_D_e_s_t))
    Unify the nameof thecurrent input streamwith _S_r_c_D_e_s_t.


tteelllliinngg((_?_S_r_c_D_e_s_t))
    Unify the nameof thecurrent output streamwith _S_r_c_D_e_s_t.


sseeeenn
    Close the currentinput stream. Thenew inputstream becomes _u_s_e_r.


ttoolldd
    Close the currentoutput stream. Thenew outputstream becomes _u_s_e_r.


33..1166..22 EExxpplliicciitt IInnppuutt aanndd OOuuttppuutt SSttrreeaammss

The predicatesbelow arepart of theQuintus compatiblestream-based I/O package. Inthis
package streams areexplicitly created using the predicateopen/3.  The resulting stream
identifier isthen passed asa parameterto the readingand writing predicatesto specify the
source ordestination ofthe data.


ooppeenn((_+_S_r_c_D_e_s_t_, _+_M_o_d_e_, _-_S_t_r_e_a_m_, _+_O_p_t_i_o_n_s))
    ISO compliantpredicate toopen astream. _S_r_c_D_e_s iseither anatom, specifyinga Unix
    file, or a term`pipe(Command)', just likesee/1 and tell/1. _M_o_d_e isone of read,
    write, appendor update. Modeappendopens thefile forwriting, positioningthe file-
    pointer at theend. Modeupdate opens thefile forwriting, positioningthe file-pointer
    at the beginningof thefile without truncatingthe file. Seealso stream_position/3.
    _S_t_r_e_a_m is either a variable, inwhich case it is bound toan integer identifying the
    stream, oran atom, inwhich casethis atomwill bethe streamidentifier. The_O_p_t_i_o_n_s
    list can containthe followingoptions:

    ttyyppee((_T_y_p_e))
         Using typetext (default), Prolog will writea text-file in anoperating-system
         compatibleway. Using typebinary thebytes willbe reador writtenwithout any
         translation. Notethere isno difference betweenthe twoon Unix systems.

    aalliiaass((_A_t_o_m))
         Gives thestream a name. Below isan example. Be carefulwith this option as
         stream-namesare global. Seealso set_stream/2.

         ?- open(data, read, Fd, [alias(input)]).

                 ...,
                 read(input, Term),
                 ...

    eeooff__aaccttiioonn((_A_c_t_i_o_n))
         Defineswhat happensif theend of theinput streamis reached.Action eof_code
         makes get0/1and friends return -1 andread/1 and friends return theatom
         end_of_file. Repetitive reading keepsyielding the sameresult. Action error
         is likeeof_code, butrepetitive reading willraise an error. Withaction reset,
         Prologwill examine thefile againand return moredata ifthe file hasgrown.

    bbuuffffeerr((_B_u_f_f_e_r_i_n_g))
         Defines outputbuffering. The atomfullf (default) definesfull buffering, line
         bufferingby line,and falseimplies thestreamis fullyunbuffered. Smaller buffer-
         ingis useful ifanother processor the useris waitingfor the outputas itis being
         produced. See alsoflush/0 and flush_output/1. Thisoption is notan ISO
         option.

    cclloossee__oonn__aabboorrtt((_B_o_o_l))
         If true(default), the stream is closed onan abort (see abort/0). If false,
         the streamis not closed. If it isan output stream, it willbe flushed however.
         Usefulfor logfiles andif the streamis associatedto a process(using the pipe/1
         construct).

    The option repositionis not supportedin SWI-Prolog. All streamsconnected to a
    file may berepositioned.


ooppeenn((_+_S_r_c_D_e_s_t_, _+_M_o_d_e_, _?_S_t_r_e_a_m))
    Equivalent to open/4with anempty option-list.


ooppeenn__nnuullll__ssttrreeaamm((_?_S_t_r_e_a_m))
    Open a stream thatproduces no output. All countingfunctions are enabledon such
    a stream. An attempt to readfrom a null-streamwill immediately signal end-of-file.
    Similar to Unix/dev/null. _S_t_r_e_a_m can bean atom, givingthe null-stream analias
    name.


cclloossee((_+_S_t_r_e_a_m))
    Close the specifiedstream. If _S_t_r_e_a_mis notopen an errormessage isdisplayed. If the
    closed stream isthe current input oroutput stream theterminal is madethe current
    input or output.


cclloossee((_+_S_t_r_e_a_m_, _+_O_p_t_i_o_n_s))
    Provides close(_S_t_r_e_a_m_,  _[_f_o_r_c_e_(_t_r_u_e_)_])as theonly option. Called thisway, any
    resource error (suchas write-errorswhile flushing theoutput buffer)are ignored.


ssttrreeaamm__pprrooppeerrttyy((_?_S_t_r_e_a_m_, _?_S_t_r_e_a_m_P_r_o_p_e_r_t_y))
    ISO compatible predicatefor querying statusof open I/Ostreams. _S_t_r_e_a_m_P_r_o_p_e_r_t_y
    is one of:

    ffiillee__nnaammee((_A_t_o_m))
         If_S_t_r_e_a_m is associatedto afile, unify _A_t_o_mto thename of thisfile.

    mmooddee((_I_O_M_o_d_e))
         Unify_I_O_M_o_d_e to themode given toopen/4 for openingthe stream. Valuesare:
         read,write, append andthe SWI-Prologextension update.

    iinnppuutt
         Trueif _S_t_r_e_a_m hasmode read.

    oouuttppuutt
         Trueif _S_t_r_e_a_m hasmode write,append or update.

    aalliiaass((_A_t_o_m))
         If_A_t_o_m isbound, test ofthe streamhas thespecified alias. Otherwiseunify _A_t_o_m
         withthe first aliasof thestream.

    ppoossiittiioonn((_T_e_r_m))
         Unify _T_e_r_m withthe current stream-position.  A stream-positionis a term of
         format $stream_position(_C_h_a_r_I_n_d_e_x_,    _L_i_n_e_N_o_,    _L_i_n_e_P_o_s). See also
         term_position/3.

    eenndd__ooff__ssttrreeaamm((_E))
         If_S_t_r_e_a_m isan inputstream, unify_E withone of theatoms not,at orpast. See
         alsoat_end_of_stream/[0,1].

    eeooff__aaccttiioonn((_A))
         Unify_A with oneof eof_code,reset orerror. See open/4for details.

    rreeppoossiittiioonn((_B_o_o_l))
         Unify_B_o_o_l with _t_r_u_eif theposition ofthe streamcan beset (see seek/4).It is
         assumed theposition canbe set ifthe stream hasa _s_e_e_k_-_f_u_n_c_t_i_o_n andis not
         basedon a POSIXfile-descriptor thatis not associatedto aregular file.

    ttyyppee((_T))
         Unify_B_o_o_l with textor binary.

    ffiillee__nnoo((_I_n_t_e_g_e_r))
         If the streamis associated with a POSIX file-descriptor, unify _I_n_t_e_g_e_rwith
         thedescriptor number. SWI-Prologextension usedprimarily for integrationwith
         foreigncode. See alsoSfileno() from SWI-Stream.h.


ccuurrrreenntt__ssttrreeaamm((_?_O_b_j_e_c_t_, _?_M_o_d_e_, _?_S_t_r_e_a_m))
    The predicate current_stream/3isused toaccess thestatus of astream aswell asto
    generate all openstreams. _O_b_j_e_c_tis thename ofthe file openedif thestream refersto
    an open file, aninteger file-descriptor ifthe stream encapsulatesan operating-system
    stream or theatom [] ifthe stream refersto someother object. _M_o_d_e isone of read
    or write.


sseett__ssttrreeaamm__ppoossiittiioonn((_+_S_t_r_e_a_m_, _+_P_o_s))
    Set  the current position  of _S_t_r_e_a_m to _P_o_s.   _P_o_s is  a term as returned  by
    stream_property/2 usingthe position(_P_o_s) property.See alsoseek/4.


sseeeekk((_+_S_t_r_e_a_m_, _+_O_f_f_s_e_t_, _+_M_e_t_h_o_d_, _-_N_e_w_L_o_c_a_t_i_o_n))
    Reposition the currentpoint of thegiven _S_t_r_e_a_m. _M_e_t_h_o_dis one ofbof, _c_u_r_r_e_n_t or
    _e_o_f, indicating positioningrelative tothe start, currentpoint orend ofthe underlying
    object. _N_e_w_L_o_c_a_t_i_o_n isunified withthe new offset,relative tothe startof thestream.

    If the seekmodifies thecurrent location, theline numberand characterposition in the
    line are setto 0.

    If the stream cannot be repostioned, areposition error is raised. The predicate
    seek/4 is compatibleto Quintus Prolog,though theerror conditions andsignalling is
    ISO compliant. Seealso stream_position/3.


sseett__ssttrreeaamm((_+_S_t_r_e_a_m_, _+_A_t_t_r_i_b_u_t_e))
    Modify an attributeof an existingstream. _A_t_t_r_i_b_u_t_e isin the currentimplemention
    only alias(_A_l_i_a_s_N_a_m_e) toset the aliasof an alreadycreated stream. If _A_l_i_a_s_N_a_m_e
    is the name of one ofthe standard streams is used, thisstream is rebound. Thus,
    set_stream(S, current_input) is thesame as set_input/1 andby setting the
    alias of astream to user_input, etc.all user terminalinput is readfrom thisstream.
    See also interactor/0.


33..1166..33 SSwwiittcchhiinngg BBeettwweeeenn IImmpplliicciitt aanndd EExxpplliicciitt II//OO

The predicatesbelow canbe usedfor switchingbetween theimplicit- and theexplicit stream
based I/Opredicates.


sseett__iinnppuutt((_+_S_t_r_e_a_m))
    Set the current input stream to become _S_t_r_e_a_m.  Thus, open(file, read, Stream),
    set_input(Stream) isequivalent tosee(file).


sseett__oouuttppuutt((_+_S_t_r_e_a_m))
    Set the currentoutput streamto become _S_t_r_e_a_m.


ccuurrrreenntt__iinnppuutt((_-_S_t_r_e_a_m))
    Get the currentinput stream. Useful toget access tothe statuspredicates associated
    with streams.


ccuurrrreenntt__oouuttppuutt((_-_S_t_r_e_a_m))
    Get the currentoutput stream.


33..1177 SSttaattuuss ooff ssttrreeaammss


wwaaiitt__ffoorr__iinnppuutt((_+_L_i_s_t_O_f_S_t_r_e_a_m_s_, _-_R_e_a_d_y_L_i_s_t_, _+_T_i_m_e_O_u_t))
    Wait forinput onone of thestreams in_L_i_s_t_O_f_S_t_r_e_a_m_s andreturn alist ofstreams on
    which inputis availablein _R_e_a_d_y_L_i_s_t. wait_for_input/3waitsfor atmost _T_i_m_e_O_u_t
    seconds. _T_i_m_e_o_u_t maybe specified asa floatingpoint numberto specify fractionsof a
    second. If _T_i_m_e_o_u_tequals 0,wait_for_input/3waits indefinitely. Thispredicate can
    be usedto implement timeoutwhile readingand tohandle inputfrom multiplesources.
    The followingexample willwait forinput fromthe userand anexplicitly openedsecond
    terminal. On return,_I_n_p_u_t_s may holduser or_P_4 or both.

    ?- open('/dev/ttyp4', read, P4),
       wait_for_input([user, P4], Inputs, 0).


cchhaarraacctteerr__ccoouunntt((_+_S_t_r_e_a_m_, _-_C_o_u_n_t))
    Unify _C_o_u_n_t with thecurrent character index. For inputstreams this isthe number
    of characters readsince the open,for output streamsthis is thenumber of characters
    written. Counting startsat 0.


lliinnee__ccoouunntt((_+_S_t_r_e_a_m_, _-_C_o_u_n_t))
    Unify _C_o_u_n_t withthe numberof lines reador written. Countingstarts at1.


lliinnee__ppoossiittiioonn((_+_S_t_r_e_a_m_, _-_C_o_u_n_t))
    Unify _C_o_u_n_twith theposition onthecurrent line. Notethat thisassumesthe positionis
    0 afterthe open. Tabsare assumedto bedefined oneach 8-thcharacter andbackspaces
    are assumed toreduce thecount by one,provided itis positive.


ffiilleeeerrrroorrss((_-_O_l_d_, _+_N_e_w))
    Define errorbehaviour onerrors whenopening afile forreading orwriting. Valid values
    are the atomson (default)and off. First_O_l_d is unifiedwith the currentvalue. Then
    the new valueis setto _N_e_w.


33..1188 PPrriimmiittiivvee cchhaarraacctteerr II//OO

See section3.2 foran overview ofsupported characterrepresentations.


nnll
    Write a newline character tothe current output stream. On Unix systems nl/0 is
    equivalent to put(10).


nnll((_+_S_t_r_e_a_m))
    Write a newlineto _S_t_r_e_a_m.


ppuutt((_+_C_h_a_r))
    Write _C_h_a_rto thecurrent outputstream,_C_h_a_r iseither aninteger-expression evaluating
    to an ASCIIvalue (0 _C_h_a_r 255)or an atomof onecharacter.


ppuutt((_+_S_t_r_e_a_m_, _+_C_h_a_r))
    Write _C_h_a_r to_S_t_r_e_a_m.


ppuutt__bbyyttee((_+_B_y_t_e))
    Alias for put/1.


ppuutt__bbyyttee((_+_S_t_r_e_a_m_, _+_B_y_t_e))
    Alias for put/2


ppuutt__cchhaarr((_+_C_h_a_r))
    Alias for put_char/1.


ppuutt((_+_S_t_r_e_a_m_, _+_C_h_a_r))
    Alias for put/2


ppuutt__ccooddee((_+_C_o_d_e))
    Alias for put/1.


ppuutt__ccooddee((_+_S_t_r_e_a_m_, _+_C_o_d_e))
    Alias for put/2


ttaabb((_+_A_m_o_u_n_t))
    Writes _A_m_o_u_n_t spaceson the currentoutput stream. _A_m_o_u_n_tshould be anexpression
    that evaluates toa positiveinteger (see section3.25).


ttaabb((_+_S_t_r_e_a_m_, _+_A_m_o_u_n_t))
    Writes _A_m_o_u_n_t spacesto _S_t_r_e_a_m.


fflluusshh
    Flush pending outputon current outputstream. flush/0 is automaticallygenerated
    by read/1 andderivatives ifthe currentinput stream isuser andthe cursor isnot at
    the left margin.


fflluusshh__oouuttppuutt((_+_S_t_r_e_a_m))
    Flush output onthe specifiedstream. The streammust be openfor writing.


ttttyyfflluusshh
    Flush pending outputon stream_u_s_e_r. See alsoflush/0.


ggeett__bbyyttee((_-_B_y_t_e))
    Read the currentinput streamand unify thenext bytewith _B_y_t_e (aninteger between
    0 and 255._B_y_t_e is unifiedwith -1on end offile.


ggeett__bbyyttee((_+_S_t_r_e_a_m_, _-_B_y_t_e))
    Read the nextbyte from_S_t_r_e_a_m.


ggeett__ccooddee((_-_C_o_d_e))
    Read the current input streamand unify _C_o_d_e with thecharacter code of the next
    character. _C_h_a_r isunified with -1on endof file. Seealso get_char/1.


ggeett__ccooddee((_+_S_t_r_e_a_m_, _-_C_o_d_e))
    Read the nextcharacter-code from_S_t_r_e_a_m.


ggeett__cchhaarr((_-_C_h_a_r))
    Read the current input stream and unify _C_h_a_r with the next characteras a one-
    character-atom.  Seealso atom_chars/2. Onend-of-file, _C_h_a_r is unifiedto the atom
    end_of_file.


ggeett__cchhaarr((_+_S_t_r_e_a_m_, _-_C_h_a_r))
    Unify _C_h_a_r with thenext character from _S_t_r_e_a_mas a one-character-atom. See also
    get_char/2, get_byte/2and get_code/2.


ggeett00((_-_C_h_a_r))
    Edinburgh version ofthe ISOget_byte/1 predicate.


ggeett00((_+_S_t_r_e_a_m_, _-_C_h_a_r))
    Edinburgh version ofthe ISOget_byte/2 predicate.


ggeett((_-_C_h_a_r))
    Read thecurrent inputstream andunify thenext non-blankcharacter with_C_h_a_r. _C_h_a_r
    is unified with-1 onend of file.


ggeett((_+_S_t_r_e_a_m_, _-_C_h_a_r))
    Read the nextnon-blank characterfrom _S_t_r_e_a_m.


ppeeeekk__bbyyttee((_-_B_y_t_e))
    Reads the next input bytelike get_byte/1, butdoes not remove itfrom the input
    stream.


ppeeeekk__bbyyttee((_+_S_t_r_e_a_m_, _-_B_y_t_e))
    Reads the nextinput bytelike get_byte/2,but doesnot remove itfrom thestream.


ppeeeekk__ccooddee((_-_C_o_d_e))
    Reads the next inputcode like get_code/1, butdoes not remove itfrom the input
    stream.


ppeeeekk__ccooddee((_+_S_t_r_e_a_m_, _-_C_o_d_e))
    Reads the nextinput codelike get_code/2,but doesnot remove itfrom thestream.


ppeeeekk__cchhaarr((_-_C_h_a_r))
    Reads thenext inputcharacter likeget_char/1, butdoes notremove itfrom theinput
    stream.


ppeeeekk__cchhaarr((_+_S_t_r_e_a_m_, _-_C_h_a_r))
    Reads the next input character like get_char/2, but does not remove it fromthe
    stream.


sskkiipp((_+_C_h_a_r))
    Read the inputuntil _C_h_a_r orthe end ofthe file isencountered. A subsequent call to
    get0/1 will readthe firstcharacter after _C_h_a_r.


sskkiipp((_+_S_t_r_e_a_m_, _+_C_h_a_r))
    Skip input (asskip/1) on_S_t_r_e_a_m.


ggeett__ssiinnggllee__cchhaarr((_-_C_h_a_r))
    Get asingle characterfrom inputstream `user'(regardless ofthe currentinput stream).
    Unlike get0/1this predicatedoes not waitfor areturn. Thecharacter isnot echoedto
    the user's terminal. Thispredicate is meantfor keyboardmenu selection etc. IfSWI-
    Prolog wasstarted withthe -ttyoption this predicatereads anentire lineof inputand
    returns thefirst non-blank characteron thisline, orthe ASCIIcode ofthe newline(10)
    if the entireline consistedof blank characters.


aatt__eenndd__ooff__ssttrreeaamm
    Succeeds after the last character of the currentinput stream has been read.  Also
    succeeds if thereis novalid current inputstream.


aatt__eenndd__ooff__ssttrreeaamm((_+_S_t_r_e_a_m))
    Succeeds after thelast characterof thenamed stream isread, or_S_t_r_e_a_m is nota valid
    input stream.


ccooppyy__ssttrreeaamm__ddaattaa((_+_S_t_r_e_a_m_I_n_, _+_S_t_r_e_a_m_O_u_t_, _+_L_e_n))
    Copy _L_e_n bytesfrom stream_S_t_r_e_a_m_I_n to _S_t_r_e_a_m_O_u_t.


ccooppyy__ssttrreeaamm__ddaattaa((_+_S_t_r_e_a_m_I_n_, _+_S_t_r_e_a_m_O_u_t))
    Copy data all(remaining) datafrom stream _S_t_r_e_a_m_I_nto _S_t_r_e_a_m_O_u_t.


33..1199 TTeerrmm rreeaaddiinngg aanndd wwrriittiinngg

This section describes the basic term reading and writing predicates.   The predicates
term_to_atom/2, atom_to_term/3 andsformat/3 provide means for translating atoms
and stringsto terms. Thepredicates format/[1,2] andwritef/2 provideformatted out-
put.

There aretwo ways tomanipulate theoutput format. The predicateprint/[1,2] maybe
programmed usingportray/1. The format offloating point numbersmay be manipulated
using theprolog_flag(see current_prolog_flag/2) float_format.

Readingis sensitiveto theprolog_flagcharacter_escapes,which controlsthe interpretation
of the\ characterin quoted atomsand strings.


wwrriittee__tteerrmm((_+_T_e_r_m_, _+_O_p_t_i_o_n_s))
    The predicate write_term/2is the genericform of all Prologterm-write predicates.
    Valid options are:

    qquuootteedd((true _o_r false))
         If true,atoms and functors that needsquotes will be quoted. The default is
         false.

    cchhaarraacctteerr__eessccaappeess((true _o_r false))
         If true, andquoted(_t_r_u_e) is active, special characters in quotedatoms and
         stringsare emitted asISO escape-sequences. Default istaken fromthe reference
         module(see below).

    iiggnnoorree__ooppss((true _o_r false))
         Iftrue, the genericterm-representation (<_f_u_n_c_t_o_r>(<_a_r_g_s>...)) will beused for
         all terms,Otherwise (default), operators,list-notation and {}/1will be written
         usingtheir special syntax.

    mmoodduullee((_M_o_d_u_l_e))
         Definethe referencemodule (default user).This definesthe defaultvalue forthe
         character_escapesoption as wellas the operatordefinitions to use. See also
         op/3.

    nnuummbbeerrvvaarrss((true _o_r false))
         If true,terms of the format $VAR(N),where <_N> is apositive integer, will be
         writtenas a variablename. The defaultis false.

    ppoorrttrraayy((true _o_r false))
         Iftrue, thehook portray/1iscalled beforeprinting aterm thatisnot avariable.
         If portray/1succeeds, the termis considered printed. Seealso print/1. The
         defaultis false. Thisoption is anextension tothe ISO write_term options.

    mmaaxx__ddeepptthh((_I_n_t_e_g_e_r))
         If theterm is nesteddeaper than _I_n_t_e_g_e_r, printthe remainder aseclipse (...).
         A 0(zero) value(default) imposes nodepth limit. This optionalso delimits the
         numberof printed fora list. Example:

         ?- write_term(a(s(s(s(s(0)))), [a,b,c,d,e,f]), [max_depth(3)]).
         a(s(s(...)), [a, b|...])

         Yes

         Usedby thetoplevel anddebugger tolimit screenoutput. Seealso theprolog-flags
         toplevel_print_options anddebugger_print_options.


wwrriittee__tteerrmm((_+_S_t_r_e_a_m_, _+_T_e_r_m_, _+_O_p_t_i_o_n_s))
    As write_term/2,but output issent to_S_t_r_e_a_m ratherthan the currentoutput.


wwrriittee__ccaannoonniiccaall((_+_T_e_r_m))
    Write _T_e_r_m onthe currentoutput streamusing standard parenthesisedprefix notation
    (i.e. ignoringoperator declarations). Atomsthatneed quotesare quoted. Termswritten
    with thispredicate canalways beread back,regardless ofcurrent operatordeclarations.
    Equivalent to write_term/2using theoptions ignore_ops and quoted.


wwrriittee__ccaannoonniiccaall((_+_S_t_r_e_a_m_, _+_T_e_r_m))
    Write _T_e_r_m incanonical formon _S_t_r_e_a_m.


wwrriittee((_+_T_e_r_m))
    Write _T_e_r_mto the currentoutput, usingbrackets andoperators whereappropriate. See
    current_prolog_flag/2for controlling floatingpoint outputformat.


wwrriittee((_+_S_t_r_e_a_m_, _+_T_e_r_m))
    Write _T_e_r_m to_S_t_r_e_a_m.


wwrriitteeqq((_+_T_e_r_m))
    Write _T_e_r_m to the current output,using brackets and operators whereappropriate.
    Atoms that need quotes arequoted.  Termswritten with this predicate canbe read
    back with read/1provided thecurrently active operatordeclarations areidentical.


wwrriitteeqq((_+_S_t_r_e_a_m_, _+_T_e_r_m))
    Write _T_e_r_m to_S_t_r_e_a_m, insertingquotes.


pprriinntt((_+_T_e_r_m))
    Prints _T_e_r_mon thecurrent outputstream similarto write/1,but foreach (sub)termof
    _T_e_r_m firstthe dynamicpredicate portray/1is called. Ifthis predicatesucceeds _p_r_i_n_t
    assumes the (sub)termhas beenwritten. This allowsfor user definedterm writing.


pprriinntt((_+_S_t_r_e_a_m_, _+_T_e_r_m))
    Print _T_e_r_m to_S_t_r_e_a_m.


ppoorrttrraayy((_+_T_e_r_m))
    A dynamic predicate, which can bedefined by the user tochange the behaviour of
    print/1 on (sub)terms.For eachsubterm encountered thatis nota variableprint/1
    first calls portray/1using the termas argument. Forlists only thelist as awhole is
    given to portray/1.If portraysucceeds print/1 assumesthe termhas beenwritten.


rreeaadd((_-_T_e_r_m))
    Read the nextProlog termfrom the currentinput stream andunify itwith _T_e_r_m. On
    a syntax errorread/1 displaysan error message,attempts to skipthe erroneousterm
    and fails. Onreaching end-of-file _T_e_r_mis unifiedwith the atomend_of_file.


rreeaadd((_+_S_t_r_e_a_m_, _-_T_e_r_m))
    Read _T_e_r_m from_S_t_r_e_a_m.


rreeaadd__ccllaauussee((_-_T_e_r_m))
    Equivalent  to read/1,  but warns the  user for  variables only occurring  once
    in  a  term (singleton  variables) which  do not  start  with an  underscore if
    style_check(singleton)  is active  (default).   Used  to read  Prolog source
    files  (see consult/1).   New  code should use  read_term/2 with the option
    singletons(warning).


rreeaadd__ccllaauussee((_+_S_t_r_e_a_m_, _-_T_e_r_m))
    Read a clausefrom _S_t_r_e_a_m. Seeread_clause/1.


rreeaadd__tteerrmm((_-_T_e_r_m_, _+_O_p_t_i_o_n_s))
    Read aterm from thecurrent inputstream andunify theterm with_T_e_r_m. The reading
    is controlled byoptions fromthe listof _O_p_t_i_o_n_s. Ifthis list isempty, thebehaviour is
    the same asfor read/1. The optionsare upward compatibleto Quintus Prolog. The
    argument order is accordingto the ISO standard. Syntax-errorsare always reported
    using exception-handling (seecatch/3). Options:

    vvaarriiaabbllee__nnaammeess((_V_a_r_s))
         Unify _V_a_r_swith a listof `_N_a_m_e = _V_a_r',where _N_a_m_e isan atom describing the
         variable nameand _V_a_ris a variablethat shares withthe corresponding variable
         in_T_e_r_m. (ISO).

    ssiinngglleettoonnss((_V_a_r_s))
         As variable_names, but only reportsthe variables occurringonly once in the
         _T_e_r_m read. Variables startingwith an underscore (`_') are notincluded in this
         list. (ISO).

    mmoodduullee((_M_o_d_u_l_e))
         Specify _M_o_d_u_l_e for operators, character_escapes flag and double_quotes
         flag. The valueof the lattertwo isoverruled if thecorresponding read_term/3
         optionis provided. Ifno module isspecified, thecurrent `source-module' isused.
         (SWI-Prolog).

    cchhaarraacctteerr__eessccaappeess((_B_o_o_l))
         Defines howto read \ escape-sequences inquoted atoms.  Seethe prolog-flags
         character_escapes,current_prolog_flag/2.(SWI-Prolog).

    ddoouubbllee__qquuootteess((_B_o_o_l))
         Defines how to  read "..." strings.   See the  prolog-flags double_quotes,
         current_prolog_flag/2. (SWI-Prolog).

    tteerrmm__ppoossiittiioonn((_P_o_s))
         Unifies_P_o_s withthe startingposition of theterm read._P_o_s ifof thesame format
         asuse by stream_position/3.

    ssuubbtteerrmm__ppoossiittiioonnss((_T_e_r_m_P_o_s))
         Describes thedetailed layout ofthe term. The formats forthe various typesof
         termsif given below.All positions arecharacter positions. Ifthe inputis related
         to anormal stream, thesepositions are relative tothe start ofthe input, when
         readingfrom the terminal,they arerelative to thestart ofthe term.

         FFrroomm--TToo
             Used forprimitive types (atoms,numbers, variables).

         ssttrriinngg__ppoossiittiioonn((_F_r_o_m_, _T_o))
             Used toindicate the positionof astring enclosed indouble quotes(").

         bbrraaccee__tteerrmm__ppoossiittiioonn((_F_r_o_m_, _T_o_, _A_r_g))
             Term ofthe form{...},as usedin DCGrules. _A_r_g describesthe argument.

         lliisstt__ppoossiittiioonn((_F_r_o_m_, _T_o_, _E_l_m_s_, _T_a_i_l))
             A list. _E_l_m_s describes the positions ofthe elements.  Ifthe list specifies
             the tail as|<_T_a_i_l_T_e_r_m>, _T_a_i_l isunified withthe term-position ofthe tail,
             otherwise withthe atom none.

         tteerrmm__ppoossiittiioonn((_F_r_o_m_, _T_o_, _F_F_r_o_m_, _F_T_o_, _S_u_b_P_o_s))
             Used fora compound termnot matchingone of theabove. _F_F_r_o_m and_F_T_o
             describe theposition ofthe functor. _S_u_b_P_o_sis alist, each elementof which
             describes theterm-position of thecorresponding subterm.


rreeaadd__tteerrmm((_+_S_t_r_e_a_m_, _-_T_e_r_m_, _+_O_p_t_i_o_n_s))
    Read term withoptions from_S_t_r_e_a_m. See read_term/2.


rreeaadd__hhiissttoorryy((_+_S_h_o_w_, _+_H_e_l_p_, _+_S_p_e_c_i_a_l_, _+_P_r_o_m_p_t_, _-_T_e_r_m_, _-_B_i_n_d_i_n_g_s))
    Similar to read_term/2 using the optionvariable_names, but allows for history
    substitutions.  read_history/6is used by the toplevel to read the user's actions.
    _S_h_o_w is the command the usershould type to show the savedevents.  _H_e_l_p is the
    command to getan overview of thecapabilities. _S_p_e_c_i_a_l is alist of commandsthat
    are not savedin the history. _P_r_o_m_p_tis thefirst prompt given. Continuationprompts
    for more linesare determinedby prompt/2. A%w in theprompt issubstituted by the
    event number. Seesection 2.7 foravailable substitutions.

    SWI-Prolog calls read_history/6as follows:

    read_history(h, '!h', [trace], '%w ?- ', Goal, Bindings)


pprroommpptt((_-_O_l_d_, _+_N_e_w))
    Set prompt associated withread/1 and its derivatives. _O_l_dis first unified withthe
    current prompt. Onsuccess theprompt willbe setto _N_e_wif this isan atom.Otherwise
    an errormessage isdisplayed. A promptis printedif oneof theread predicatesis called
    and the cursoris atthe left margin.It is alsoprinted whenever anewline isgiven and
    the term hasnot been terminated. Prompts areonly printed whenthe current input
    stream is _u_s_e_r.


pprroommpptt11((_+_P_r_o_m_p_t))
    Sets the promptfor thenext line tobe read. Continuationlines willbe read usingthe
    prompt defined byprompt/2.


33..2200 AAnnaallyyssiinngg aanndd CCoonnssttrruuccttiinngg TTeerrmmss


ffuunnccttoorr((_?_T_e_r_m_, _?_F_u_n_c_t_o_r_, _?_A_r_i_t_y))
    Succeeds if _T_e_r_mis a termwith functor _F_u_n_c_t_o_rand arity _A_r_i_t_y. If_T_e_r_m is avari-
    able it isunified with anew term holdingonly variables. functor/3 silentlyfails on
    instantiation faults If_T_e_r_m is anatom ornumber, _F_u_n_c_t_o_r willbe unified with_T_e_r_m
    and arity willbe unifiedwith the integer0 (zero).


aarrgg((_?_A_r_g_, _?_T_e_r_m_, _?_V_a_l_u_e))
    _T_e_r_m should be instantiatedto a term,_A_r_g to an integerbetween 1 andthe arity of
    _T_e_r_m. _V_a_l_u_e isunified with the_A_r_g-th argumentof _T_e_r_m. _A_r_gmay alsobe unbound.
    In this case _V_a_l_u_e will be unifiedwith the successive arguments of the term. On
    successful unification, _A_r_g isunified with theargument number. Backtracking yields
    alternative solutions. Thepredicate arg/3fails silentlyif _A_r_g= 0or _A_r_g> _a_r_i_t_yand
    raises the exceptiondomain_error(not_less_then_zero, Arg)if_A_r_g <0.


sseettaarrgg((_+_A_r_g_, _+_T_e_r_m_, _+_V_a_l_u_e))
    Extra-logical predicate. Assignsthe _A_r_g-thargument ofthe compoundterm _T_e_r_mwith
    the given _V_a_l_u_e. Theassignment isundone if backtrackingbrings the stateback into
    a position beforethe setarg/3call.

    This predicate may be usedfor destructive assignment toterms, using them as and
    extra-logical storage bin.


_?_T_e_r_m =.. _?_L_i_s_t
    _L_i_s_t is alist which headis thefunctor of _T_e_r_mand the remainingarguments are the
    arguments of theterm. Each of thearguments maybe a variable,but not both. This
    predicate is called`Univ'. Examples:

    ?- foo(hello, X) =.. List.

    List = [foo, hello, X]

    ?- Term =.. [baz, foo(1)]

    Term = baz(foo(1))


nnuummbbeerrvvaarrss((_+_T_e_r_m_, _+_F_u_n_c_t_o_r_, _+_S_t_a_r_t_, _-_E_n_d))
    Unify the freevariables of_T_e_r_m witha term constructedfrom theatom _F_u_n_c_t_o_r with
    one argument. Theargument isthe number ofthe variable. Countingstarts at_S_t_a_r_t.
    _E_n_d is unifiedwith thenumber that shouldbe givento the nextvariable. Example:

    ?- numbervars(foo(A, B, A), this_is_a_variable, 0, End).

    A = this_is_a_variable(0)
    B = this_is_a_variable(1)
    End = 2

    In Edinburgh Prologthe secondargument is missing.It is fixedto be$VAR.


ffrreeee__vvaarriiaabblleess((_+_T_e_r_m_, _-_L_i_s_t))
    Unify _L_i_s_t witha list ofvariables, each sharing witha unique variableof _T_e_r_m. For
    example:

    ?- free_variables(a(X, b(Y, X), Z), L).

    L = [G367, G366, G371]
    X = G367
    Y = G366
    Z = G371


ccooppyy__tteerrmm((_+_I_n_, _-_O_u_t))
    Make a copyof term_I_n and unifythe resultwith _O_u_t. Groundparts of _I_nare shared
    by _O_u_t. Provided _I_nand _O_u_thave no sharingvariables beforethis call theywill have
    no sharing variablesafterwards. copy_term/2is semanticallyequivalent to:

    copy_term(In, Out) :-
            recorda(copy_key, In, Ref),
            recorded(copy_key, Out, Ref),
            erase(Ref).


33..2211 AAnnaallyyssiinngg aanndd ccoonnssttrruuccttiinngg aattoommss

These predicatesconvert betweenProlog constantsand listsof ASCIIvalues. The predicates
atom_codes/2, number_codes/2and name/2 behave the same whenconverting from a
constant toa list ofASCII values. When convertingthe other wayaround, atom_codes/2
will generatean atom, number_codes/2will generate anumber or exception andname/2
will returna numberif possible andan atomotherwise.

The ISOstandard defines atom_chars/2to describethe `broken-up' atomas a listof one-
character atomsinstead of alist of codes.Upto version 3.2.x,SWI-Prolog's atom_chars/2
behaved,compatible toQuintus andSICStus Prolog,like atom_codes. As of3.3.xSWI-Prolog
atom_codes/2and atom_chars/2are compliantto the ISOstandard.

To easethe painof allvariations inthe Prolog community,all SWI-Prologpredicates behave
as flexibleas possible. Thisimplies the`list-side' accepts eithera code-listor a char-listand
the `atom-side'accept allatomic types (atom,number andstring).


aattoomm__ccooddeess((_?_A_t_o_m_, _?_S_t_r_i_n_g))
    Convert between anatom anda list ofASCII values. If_A_t_o_m isinstantiated, if willbe
    translated into a listof ASCII valuesand the resultis unified with _S_t_r_i_n_g. If_A_t_o_m
    is unbound and_S_t_r_i_n_g is alist of ASCIIvalues, it will_A_t_o_m will beunified with an
    atom constructed fromthis list.


aattoomm__cchhaarrss((_?_A_t_o_m_, _?_C_h_a_r_L_i_s_t))
    As atom_codes/2,but _C_h_a_r_L_i_s_t isa listof one-character atomsrather thana list of
    ASCII values.

    ?- atom_chars(hello, X).

    X = [h, e, l, l, o]


cchhaarr__ccooddee((_?_A_t_o_m_, _?_A_S_C_I_I))
    Convert between characterand ASCIIvalue for asingle character.


nnuummbbeerr__cchhaarrss((_?_N_u_m_b_e_r_, _?_C_h_a_r_L_i_s_t))
    Similar to atom_chars/2, but convertsbetween a numberand its representationas a
    list ofone-character atoms. Failswitha representation_errorif _N_u_m_b_e_risunbound
    and _C_h_a_r_L_i_s_t doesnot describea number.


nnuummbbeerr__ccooddeess((_?_N_u_m_b_e_r_, _?_C_o_d_e_L_i_s_t))
    As number_chars/2,but convertsto alist of charactercodes (normallyASCII values)
    rather than one-characteratoms. In themode -, +,both predicatesbehave identically
    to improve handlingof non-ISOsource.


nnaammee((_?_A_t_o_m_O_r_I_n_t_, _?_S_t_r_i_n_g))
    _S_t_r_i_n_g is a listof ASCII values describing_A_t_o_m.  Eachof the arguments maybe a
    variable, but not both. When_S_t_r_i_n_g is bound toan ASCII valuelist describing an
    integer and _A_t_o_mis avariable _A_t_o_m willbe unifiedwith the integervalue describedby
    _S_t_r_i_n_g (e.g. `name(N, "300"), 400 is N + 100'succeeds).


iinntt__ttoo__aattoomm((_+_I_n_t_, _+_B_a_s_e_, _-_A_t_o_m))
    Convert _I_n_t to an asciirepresentation using base _B_a_s_eand unify the result with
    _A_t_o_m. If _B_a_s_e6= 10the basewill be prependedto _A_t_o_m._B_a_s_e =0 will tryto interpret
    _I_n_t as anASCII value andreturn 0'<_c>. Otherwise 2 _B_a_s_e 36. Some examples
    are given below.

                     int_to_atom(45, 2,A)-!  A= 20101101
                     int_to_atom(97, 0,A)-!  A= 00a
                     int_to_atom(56, 10,A)-! A= 56


iinntt__ttoo__aattoomm((_+_I_n_t_, _-_A_t_o_m))
    Equivalent to int_to_atom(Int, 10, Atom).


tteerrmm__ttoo__aattoomm((_?_T_e_r_m_, _?_A_t_o_m))
    Succeeds if _A_t_o_m describes a termthat unifies with _T_e_r_m. When _A_t_o_m is instanti-
    ated _A_t_o_m is converted and then unified with_T_e_r_m.  If _A_t_o_m has novalid syntax,
    a syntax_error exception is raised. Otherwise _T_e_r_m is \written" on _A_t_o_m using
    write/1.


aattoomm__ttoo__tteerrmm((_+_A_t_o_m_, _-_T_e_r_m_, _-_B_i_n_d_i_n_g_s))
    Use _A_t_o_m as input to read_term/2using the option variable_names andreturn
    the read term in _T_e_r_mand the variable bindings in _B_i_n_d_i_n_g_s. _B_i_n_d_i_n_g_s is alist
    of _N_a_m_e = _V_a_rcouples, thus providingaccess to the actualvariable names. See also
    read_term/2. If _A_t_o_mhas novalid syntax,a syntax_errorexception is raised.


aattoomm__ccoonnccaatt((_?_A_t_o_m_1_, _?_A_t_o_m_2_, _?_A_t_o_m_3))
    _A_t_o_m_3 forms the concatenationof _A_t_o_m_1 and_A_t_o_m_2.  Atleast two ofthe arguments
    must beinstantiated to atoms,integers orfloating pointnumbers. ForISO compliance,
    the instantiation-pattern -,-, +is allowedtoo, non-deterministically splittingthe 3-th
    argument into twoparts (asappend/3 does forlists). See alsostring_concat/3.


ccoonnccaatt__aattoomm((_+_L_i_s_t_, _-_A_t_o_m))
    _L_i_s_t is a listof atoms, integers orfloating point numbers. Succeeds if_A_t_o_m can be
    unified with the concatenatedelements of _L_i_s_t. If_L_i_s_t has exactly 2elements it is
    equivalent to atom_concat/3, allowing forvariables inthe list.


ccoonnccaatt__aattoomm((_+_L_i_s_t_, _+_S_e_p_a_r_a_t_o_r_, _-_A_t_o_m))
    Creates an atomjust like concat_atom/2,but inserts _S_e_p_a_r_a_t_o_rbetween each pair
    of atoms. Forexample:

    ?- concat_atom([gnu, gnat], ', ', A).

    A = 'gnu, gnat'


aattoomm__lleennggtthh((_+_A_t_o_m_, _-_L_e_n_g_t_h))
    Succeeds if _A_t_o_mis an atomof _L_e_n_g_t_h characterslong. This predicatealso works for
    integers andfloats, expressingthe numberof charactersoutput whengiven towrite/1.


aattoomm__pprreeffiixx((_+_A_t_o_m_, _+_P_r_e_f_i_x))
    Succeeds if _A_t_o_mstarts with thecharacters from _P_r_e_f_i_x. Its behaviouris equivalent
    to ?- concat(Prefix, _, Atom), but avoidsthe construction of an atomfor the
    `remainder'.


ssuubb__aattoomm((_+_A_t_o_m_, _?_B_e_f_o_r_e_, _?_L_e_n_, _?_A_f_t_e_r_, _?_S_u_b))
    ISO predicatefor breakingatoms. Itmaintains thefollowing relation:_S_u_b isa sub-atom
    of _A_t_o_mthat startsat _B_e_f_o_r_e, has_L_e_n charactersand _A_t_o_mcontains _A_f_t_e_rcharacters
    after the match.

    ?- sub_atom(abc, 1, 1, A, S).

    A = 1, S = b

    The implementationminimalises non-determinismand creationof atoms. Thisis avery
    flexible predicate thatcan dosearch, prefix- andsuffix-matching, etc.


33..2222 CCllaassssiiffyyiinngg cchhaarraacctteerrss

SWI-Prolog offers two comprehensive predicates forclassifying characters and character-
codes. These predicates are definedas built-in predicates to exploitthe C-character clas-
sification's handlingof _l_o_c_a_l_e (handlingof localcharacter-sets). These predicates arefast,
logical anddeterministic ifapplicable.

In addition,there isthe librarylibrary(ctype) providing compatibilityto someother Prolog
systems. Thepredicates of thislibrary aredefined in termsof code_type/2.


cchhaarr__ttyyppee((_?_C_h_a_r_, _?_T_y_p_e))
    Tests or generatesalternative _T_y_p_esor _C_h_a_rs. Thecharacter-types areinspired bythe
    standard C <ctype.h>primitives.

    aallnnuumm
         _C_h_a_ris a letter(upper- orlowercase) or digit.

    aallpphhaa
         _C_h_a_ris a letter(upper- orlowercase).

    ccssyymm
         _C_h_a_ris aletter (upper-or lowercase),digit or theunderscore (_).These arevalid
         C-and Prolog symbolcharacters.

    ccssyymmff
         _C_h_a_ris a letter(upper- orlowercase) or theunderscore (_). Theseare validfirst
         charactersfor C- andProlog symbols

    aasscciiii
         _C_h_a_ris a 7-bitsASCII character(0..127).

    wwhhiittee
         _C_h_a_ris a spaceor tab. E.i.white spaceinside a line.

    ccnnttrrll
         _C_h_a_ris an ASCIIcontrol-character (0..31).

    ddiiggiitt
         _C_h_a_ris a digit.

    ddiiggiitt((_W_e_i_g_t_h))
         _C_h_a_ris adigit withvalue _W_e_i_g_t_h.I.e. char_type(X, digit(6)yields _X='6'.
         Usefulfor parsing numbers.

    ggrraapphh
         _C_h_a_rproduces a visiblemark ona pagewhen printed. Notethat thespace isnot
         included!

    lloowweerr
         _C_h_a_ris a lower-caseletter.

    lloowweerr((_U_p_p_e_r))
         _C_h_a_ris a lower-caseversion of_U_p_p_e_r. Only trueif _C_h_a_ris lowercase and_U_p_p_e_r
         uppercase.

    ttoo__lloowweerr((_U_p_p_e_r))
         _C_h_a_r isa lower-case version of_U_p_p_e_r.  For non-letters,or letter without case,
         _C_h_a_rand _L_o_w_e_r arethe same.

    uuppppeerr
         _C_h_a_ris an upper-caseletter.

    uuppppeerr((_L_o_w_e_r))
         _C_h_a_ris anupper-case versionof _L_o_w_e_r.Only trueif _C_h_a_risuppercase and_L_o_w_e_r
         lowercase.

    ttoo__uuppppeerr((_L_o_w_e_r))
         _C_h_a_r isan upper-case versionof _L_o_w_e_r. For non-letters,or letter withoutcase,
         _C_h_a_rand _L_o_w_e_r arethe same.

    ppuunncctt
         _C_h_a_ris a punctuationcharacter. Thisis agraph character thatis nota letteror
         digit.

    ssppaaccee
         _C_h_a_ris some formof layoutcharacter (tab, vertical-tab,newline, etc.).

    eenndd__ooff__ffiillee
         _C_h_a_ris -1.

    eenndd__ooff__lliinnee
         _C_h_a_rends a line(ASCII: 10..13).

    nneewwlliinnee
         _C_h_a_ris a thenewline character(10).

    ppeerriioodd
         _C_h_a_rcounts as theend ofa sentence (.,!,?).

    qquuoottee
         _C_h_a_ris a quote-character(", ',`).

    ppaarreenn((_C_l_o_s_e))
         _C_h_a_ris an open-parenthesisand _C_l_o_s_eis the correspondingclose-parenthesis.


ccooddee__ttyyppee((_?_C_o_d_e_, _?_T_y_p_e))
    As char_type/2, but usescharacter-codes rather than one-characteratoms.  Please
    note that bothpredicates areas flexibleas possible. Theyhandle either representation
    if the argument isinstantiated and onlywill instantiate with aninteger code orone-
    character atomdepending ofthe versionused. See alsothe prolog-flagdouble_quotes,
    atom_chars/2 andatom_codes/2.


33..2233 RReepprreesseennttiinngg tteexxtt iinn ssttrriinnggss

SWI-Prologsupports thedata type_s_t_r_i_n_g. Strings area timeand spaceefficientmechanism
to handletext text inProlog. Strings are storesas a bytearray on theglobal (term) stack
and thusdestroyed onbacktracking and reclaimedby thegarbage collector.

Strings were addedto SWI-Prolog based on anearly draft of theISO standard, offerring
a mechanismto represent temporary characterdata efficiently. As SWI-Prolog stringscan
handle 0-bytes,they are frequently usedthrough the foreign languageinterface (section 5)
for storingarbitrary byte-sequences.

Starting withversion 3.3,SWI-Prolog offers garbagecollection on theatom-space aswell as
representing 0-bytesin atoms. Althoughstrings and atomsstill have differentfeatures, new
code shouldconsider using atoms toavoid too manyrepresentations for textas well as for
compatibility toother Prologsystems. Below aresome of thedifferences:

  o _c_r_e_a_t_i_o_n
    Creating strings is fast,as the data issimply copied to theglobal stack. Atoms are
    unique and thereforemore expensive interms of memoryand time tocreate.  Onthe
    other hand, if the same texthas to be represented multiple times, atomsare more
    efficient.

  o _d_e_s_t_r_u_c_t_i_o_n
    Backtracking destroysatoms atno cost. Theycheap tohandle bythe garbagecollector,
    but itshould benoted that extensiveuse ofstrings willcause manygarbage collections.
    Atom garbage collectionis generallyfaster.

See alsothe prolog-flagdouble_quotes.


ssttrriinngg__ttoo__aattoomm((_?_S_t_r_i_n_g_, _?_A_t_o_m))
    Logical conversion betweena string and anatom. At least oneof the twoarguments
    must be instantiated._A_t_o_m can alsobe aninteger or floatingpoint number.


ssttrriinngg__ttoo__lliisstt((_?_S_t_r_i_n_g_, _?_L_i_s_t))
    Logical conversion betweena stringand a listof ASCIIcharacters. At leastone of the
    two arguments mustbe instantiated.


ssttrriinngg__lleennggtthh((_+_S_t_r_i_n_g_, _-_L_e_n_g_t_h))
    Unify _L_e_n_g_t_h withthe numberof charactersin _S_t_r_i_n_g. Thispredicate isfunctionally
    equivalent to atom_length/2and also accepts atoms,integers and floats asits first
    argument.


ssttrriinngg__ccoonnccaatt((_?_S_t_r_i_n_g_1_, _?_S_t_r_i_n_g_2_, _?_S_t_r_i_n_g_3))
    Similar to atom_concat/3,but the unbound argumentwill be unified witha string
    object rather than anatom.  Also, ifboth _S_t_r_i_n_g_1 and _S_t_r_i_n_g_2are unbound and
    _S_t_r_i_n_g_3 isbound totext, it breaks_S_t_r_i_n_g_3, unifyingthe startwith _S_t_r_i_n_g_1and the
    end with _S_t_r_i_n_g_2as appenddoes with lists.Note that thisis notparticularly fast on
    long strings as foreach redo thesystem has tocreate two entirely newstrings, while
    the list equivalentonly createsa single newlist-cell andmoves some pointersaround.


ssuubb__ssttrriinngg((_+_S_t_r_i_n_g_, _?_S_t_a_r_t_, _?_L_e_n_g_t_h_, _?_A_f_t_e_r_, _?_S_u_b))
    _S_u_b is asubstring of _S_t_r_i_n_gstarting at_S_t_a_r_t, with length_L_e_n_g_t_h and _S_t_r_i_n_ghas
    _A_f_t_e_r characters leftafter thematch. See alsosub_atom/5.


33..2244 OOppeerraattoorrss

Operators aredefined toimprove the readibilityof source-code. Forexample, without oper-
ators, towrite 2*3+4*5one would haveto write+(*(2,3),*(4,5)). In Prolog, anumber
of operatorshave beenpredefined. All operators, exceptfor thecomma (,) canbe redefined
by theuser.

Some carehas tobe takenbefore definingnew operators.Defining too manyoperators might
make your source`natural' looking, but atthe same time lead tohard to understand the
limits ofyour syntax. To ease thepain, as of SWI-Prolog3.3.0, operators arelocal to the
modulein whichthey aredefined. The module-tableof themodule useracts asdefault table
for allmodules. This globaltable canbe modified explictlyfrom insidea module:

:- module(prove,
          [ prove/1
          ]).

:- op(900, xfx, user:(=>)).

Unlike whatmany usersthink, operatorsand quotedatoms haveno relation:defining aatom
as anoperator does nnoottinfluence parsing charactersinto atoms andquoting an atomdoes
nnoott stopit fromacting as anoperator. To stopan atomacting as anoperator, encloseit in
braces likethis: (myop).


oopp((_+_P_r_e_c_e_d_e_n_c_e_, _+_T_y_p_e_, _:_N_a_m_e))
    Declare _N_a_m_e tobe anoperator of type_T_y_p_e withprecedence _P_r_e_c_e_d_e_n_c_e. _N_a_m_ecan
    also be alist ofnames, inwhich caseall elementsof the listare declaredto beidentical
    operators.  _P_r_e_c_e_d_e_n_c_eis an integerbetween 0 and1200. Precedence 0 removesthe
    declaration. _T_y_p_e is oneof: xf, yf, xfx,xfy, yfx, yfy,fy or fx. The`f' indicates
    the position ofthe functor, while xand y indicatethe position ofthe arguments. `y'
    should be interpreted as \onthis position a termwith precedence lower orequal to
    the precedence of thefunctor should occur". For `x'the precedence ofthe argument
    must be strictly lower. The precedenceof a term is0, unless its principalfunctor is
    an operator, in whichcase the precedenceis the precedenceof this operator. Aterm
    enclosed in brackets(...) hasprecedence 0.

    The predefinedoperators areshown intable3.1. Note thatalloperators canbe redefined
    by the user.
     ______________________________________________________________
     | 1200 |xfx  |-->, :-                                        |
     | 1200 | fx  |:-, ?-                                         |
     | 1150 | fx  |dynamic, multifile, module_transparent, discon-|
     |      |     |tiguous, volatile, initialization              |
     | 1100 |xfy  |;, |                                           |

     | 1050 |xfy  |->                                             |
     | 1000 |xfy  |,                                              |
     |  954 |xfy  |\                                              |
     |  900 | fy  |\+                                             |
     |  900 | fx  |~                                              |
     |  700 |xfx  |<, =, =.., =@=,  =:=, =<, ==, =\=,  >, >=, @<, |
     |      |     |@=<, @>, @>=, \=, \==, is                      |
     |  600 |xfy  |:                                              |

     |  500 | yfx |+, -, /\, \/, xor                              |
     |  500 | fx  |+, -, ?, \                                     |
     |  400 | yfx |*, /, //, <<, >>, mod, rem                     |
     |  200 |xfx  |**                                             |
     |__200_|xfy__|^______________________________________________|_

                      Table 3.1:  System operators


ccuurrrreenntt__oopp((_?_P_r_e_c_e_d_e_n_c_e_, _?_T_y_p_e_, _?_:_N_a_m_e))
    Succeeds when _N_a_m_eis currently definedas anoperator of type_T_y_p_e withprecedence
    _P_r_e_c_e_d_e_n_c_e. See alsoop/3.


33..2255 AArriitthhmmeettiicc

Arithmetic canbe dividedinto somespecial purposeinteger predicatesand aseries ofgeneral
predicatesfor floatingpoint andinteger arithmeticas appropriate. Theinteger predicatesare
as \logical"as possible.Their usage isrecommended wheneverapplicable, resultingin faster
and more\logical" programs.

Thegeneral arithmeticpredicates areoptionally compilednow (seeset_prolog_flag/2and
the -Ocommand line option). Compiled arithmeticreduces global stack requirementsand
improves performance.Unfortunately compiled arithmeticcannot betraced, whichis why it
is optional.

The generalarithmetic predicatesall handle_e_x_p_r_e_s_s_i_o_n_s. An expressionis either asimple
number or a_f_u_n_c_t_i_o_n.  Thearguments of a functionare expressions.  Thefunctions are
described insection 3.26.


bbeettwweeeenn((_+_L_o_w_, _+_H_i_g_h_, _?_V_a_l_u_e))
    _L_o_w and _H_i_g_hare integers,_H_i_g_h _L_o_w. If _V_a_l_u_eis aninteger, _L_o_w _V_a_l_u_e _H_i_g_h.
    When _V_a_l_u_eis avariable itis successivelybound toall integersbetween _L_o_wand _H_i_g_h.


ssuucccc((_?_I_n_t_1_, _?_I_n_t_2))
    Succeeds if _I_n_t_2= _I_n_t_1+1. Atleast oneof the argumentsmust beinstantiated toan
    integer.


pplluuss((_?_I_n_t_1_, _?_I_n_t_2_, _?_I_n_t_3))
    Succeeds if _I_n_t_3= _I_n_t_1+_I_n_t_2. At leasttwo of thethree argumentsmust beinstan-
    tiated to integers.


_+_E_x_p_r_1 > _+_E_x_p_r_2
    Succeeds when expression_E_x_p_r_1 evaluatesto a largernumber than_E_x_p_r_2.


_+_E_x_p_r_1 < _+_E_x_p_r_2
    Succeeds when expression_E_x_p_r_1 evaluatesto a smallernumber than_E_x_p_r_2.


_+_E_x_p_r_1 =< _+_E_x_p_r_2
    Succeeds when expression_E_x_p_r_1 evaluatesto a smalleror equalnumber to _E_x_p_r_2.


_+_E_x_p_r_1 >= _+_E_x_p_r_2
    Succeeds when expression_E_x_p_r_1 evaluatesto a largeror equalnumber to _E_x_p_r_2.


_+_E_x_p_r_1 =\= _+_E_x_p_r_2
    Succeeds when expression_E_x_p_r_1 evaluatesto a numbernon-equal to_E_x_p_r_2.


_+_E_x_p_r_1 =:= _+_E_x_p_r_2
    Succeeds when expression_E_x_p_r_1 evaluatesto a numberequal to _E_x_p_r_2.


_-_N_u_m_b_e_r iiss _+_E_x_p_r
    Succeeds when _N_u_m_b_e_rhas successfully beenunified with thenumber _E_x_p_r evaluates
    to. If _E_x_p_revaluates toa floatthat canbe representedusing aninteger (i.e.the valueis
    integer and withinthe rangethat canbe described byProlog's integerrepresentation),
    _E_x_p_r is unifiedwith theinteger value.

    Note that normally,is/2 will beused withunbound left operand. Ifequality isto be
    tested, =:=/2 shouldbe used. Forexample:

         ?- 1.0 is sin(pi/2).         Fails!. sin(pi/2) evaluatesto 1.0, but
                                      is/2will represent thisas theinteger
                                      1, afterwhich unifywill fail.
         ?- 1.0 is float(sin(pi/2)).  Succeeds, as the float/1 function
                                      forces theresult tobe float.

         ?- 1.0 =:= sin(pi/2).        Succeeds asexpected.


33..2266 AArriitthhmmeettiicc FFuunnccttiioonnss

Arithmetic functionsare terms which areevaluated by thearithmetic predicates described
above. SWI-Prologtries to hidethe differencebetween integer arithmeticand floatingpoint
arithmetic fromthe Prologuser. Arithmetic isdone asinteger arithmetic aslong aspossible
and convertedto floating pointarithmetic whenever one ofthe arguments orthe combina-
tion of themrequires it.  Ifa function returns a floatingpoint value which is whole itis
automatically transformedinto aninteger. There arethree types ofarguments tofunctions:

        _E_x_p_r     Arbitrary expression,returning either afloating point value
                 or aninteger.
        _I_n_t_E_x_p_r  Arbitrary expressionthat shouldevaluate intoan integer.
        _I_n_t      An integer.

In caseinteger addition,subtraction andmultiplication wouldlead toan integer overflowthe
operands areautomatically convertedto floatingpoint numbers.The floatingpoint functions
(sin/1, exp/1,etc.) form a directinterface to the correspondingC library functionsused
to compileSWI-Prolog. Please referto theC library documentationfor detailson precision,
error handling,etc.


- _+_E_x_p_r
    _R_e_s_u_l_t =-_E_x_p_r


_+_E_x_p_r_1 + _+_E_x_p_r_2
    _R_e_s_u_l_t =_E_x_p_r_1 +_E_x_p_r_2


_+_E_x_p_r_1 - _+_E_x_p_r_2
    _R_e_s_u_l_t =_E_x_p_r_1 -_E_x_p_r_2


_+_E_x_p_r_1 * _+_E_x_p_r_2
    _R_e_s_u_l_t =_E_x_p_r_1_*Expr2


_+_E_x_p_r_1 / _+_E_x_p_r_2
    _R_e_s_u_l_t =_E_x_p_r_1=_E_x_p_r_2


_+_I_n_t_E_x_p_r_1 mmoodd _+_I_n_t_E_x_p_r_2
    Modulo: _R_e_s_u_l_t =_I_n_t_E_x_p_r_1 - (_I_n_t_E_x_p_r_1// _I_n_t_E_x_p_r_2) * _I_n_t_E_x_p_r_2The function
    mod/2 is implemented usingthe C % operator. It's behaviourwith negtive values is
    illustrated in thetable below.

                              2 =   17  mod   5
                              2 =   17  mod   -5
                             -2 =   -17 mod   5
                             -2 =   -17 mod   5


_+_I_n_t_E_x_p_r_1 rreemm _+_I_n_t_E_x_p_r_2
    Remainder of division:_R_e_s_u_l_t = float_fractional_part(_I_n_t_E_x_p_r_1/_I_n_t_E_x_p_r_2)


_+_I_n_t_E_x_p_r_1 // _+_I_n_t_E_x_p_r_2
    Integer division: _R_e_s_u_l_t= truncate(_E_x_p_r_1/_E_x_p_r_2)


aabbss((_+_E_x_p_r))
    Evaluate _E_x_p_r andreturn theabsolute value ofit.


ssiiggnn((_+_E_x_p_r))
    Evaluate to -1if _E_x_p_r< 0,1 if _E_x_p_r> 0and 0if _E_x_p_r= 0.


mmaaxx((_+_E_x_p_r_1_, _+_E_x_p_r_2))
    Evaluates to thelargest ofboth _E_x_p_r_1 and_E_x_p_r_2.


mmiinn((_+_E_x_p_r_1_, _+_E_x_p_r_2))
    Evaluates to thesmallest ofboth _E_x_p_r_1 and_E_x_p_r_2.


.((_+_I_n_t_, _[_]))
    A listof one elementevaluates tothe element.This implies"a" evaluatesto theASCII
    value of theletter `a' (97). Thisoption is availablefor compatibility only. It willnot
    work if`style_check(+string)'is activeas "a"will thenbe transformedintoa string
    object. The recommendedway to specifythe ASCIIvalue of theletter `a'is 0'a.


rraannddoomm((_+_I_n_t))
    Evaluates to a random integer_i for which 0 i < _I_n_t.  Theseed of this random
    generator is determinedby thesystem clock whenSWI-Prolog wasstarted.


rroouunndd((_+_E_x_p_r))
    Evaluates _E_x_p_r androunds theresult to thenearest integer.


iinntteeggeerr((_+_E_x_p_r))
    Same as round/1(backward compatibility).


ffllooaatt((_+_E_x_p_r))
    Translate the result to a floatingpoint number.  Normally, Prologwill use integers
    whenever possible. When used around the2nd argument of is/2,the result willbe
    returned as afloating pointnumber. In othercontexts, the operationhas noeffect.


ffllooaatt__ffrraaccttiioonnaall__ppaarrtt((_+_E_x_p_r))
    Fractional part of afloating-point number. Negative if_E_x_p_r is negative,0 if _E_x_p_r is
    integer.


ffllooaatt__iinntteeggeerr__ppaarrtt((_+_E_x_p_r))
    Integer part of floating-pointnumber.  Negativeif _E_x_p_r is negative,_E_x_p_r if _E_x_p_r is
    integer.


ttrruunnccaattee((_+_E_x_p_r))
    Truncate _E_x_p_r toan integer. Sameas float_integer_part/1.


fflloooorr((_+_E_x_p_r))
    Evaluates _E_x_p_r and returns thelargest integer smaller or equalto the result ofthe
    evaluation.


cceeiilliinngg((_+_E_x_p_r))
    Evaluates _E_x_p_r and returns thesmallest integer larger or equalto the result ofthe
    evaluation.


cceeiill((_+_E_x_p_r))
    Same as ceiling/1(backward compatibility).


_+_I_n_t_E_x_p_r >> _+_I_n_t_E_x_p_r
    Bitwise shift _I_n_t_E_x_p_r_1by _I_n_t_E_x_p_r_2bits to theright.


_+_I_n_t_E_x_p_r << _+_I_n_t_E_x_p_r
    Bitwise shift _I_n_t_E_x_p_r_1by _I_n_t_E_x_p_r_2bits to theleft.


_+_I_n_t_E_x_p_r \/ _+_I_n_t_E_x_p_r
    Bitwise `or' _I_n_t_E_x_p_r_1and _I_n_t_E_x_p_r_2.


_+_I_n_t_E_x_p_r /\ _+_I_n_t_E_x_p_r
    Bitwise `and' _I_n_t_E_x_p_r_1and _I_n_t_E_x_p_r_2.


_+_I_n_t_E_x_p_r xxoorr _+_I_n_t_E_x_p_r
    Bitwise `exclusive or'_I_n_t_E_x_p_r_1 and_I_n_t_E_x_p_r_2.


\ _+_I_n_t_E_x_p_r
    Bitwise negation.


ssqqrrtt((_+_E_x_p_r))
    _R_e_s_u_l_t =square root of_E_x_p_r


ssiinn((_+_E_x_p_r))
    _R_e_s_u_l_t =sine of _E_x_p_r. _E_x_p_ris the anglein radians.


ccooss((_+_E_x_p_r))
    _R_e_s_u_l_t =cosine of _E_x_p_r._E_x_p_r is theangle inradians.


ttaann((_+_E_x_p_r))
    _R_e_s_u_l_t =tangus of _E_x_p_r. _E_x_p_r isthe anglein radians.


aassiinn((_+_E_x_p_r))
    _R_e_s_u_l_t =inverse sine of_E_x_p_r. _R_e_s_u_l_tis theangle in radians.


aaccooss((_+_E_x_p_r))
    _R_e_s_u_l_t =inverse cosine of_E_x_p_r._R_e_s_u_l_t is theangle inradians.


aattaann((_+_E_x_p_r))
    _R_e_s_u_l_t =inverse tangus of_E_x_p_r. _R_e_s_u_l_tis the anglein radians.


aattaann((_+_Y_E_x_p_r_, _+_X_E_x_p_r))
    _R_e_s_u_l_t = inverse tangusof _Y_E_x_p_r /_X_E_x_p_r.  _R_e_s_u_l_tis the angle in radians. The
    return value isin the range[-pi:::pi]. Used to convertbetween rectangular andpolar
    coordinate system.


lloogg((_+_E_x_p_r))
    _R_e_s_u_l_t =natural logarithm of_E_x_p_r


lloogg1100((_+_E_x_p_r))
    _R_e_s_u_l_t =10 base logarithmof _E_x_p_r


eexxpp((_+_E_x_p_r))
    _R_e_s_u_l_t =e to thepower _E_x_p_r


_+_E_x_p_r_1 ** _+_E_x_p_r_2
    _R_e_s_u_l_t =_E_x_p_r_1 to thepower _E_x_p_r_2


_+_E_x_p_r_1 ^ _+_E_x_p_r_2
    Same as **/2.(backward compatibility).


ppii
    Evaluates to themathematical constantpi(3.141593).


ee
    Evaluates to themathematical constante (2.718282).


ccppuuttiimmee
    Evaluates to a floating point numberexpressing the cpu time (inseconds) used by
    Prolog up tillnow. See alsostatistics/2 andtime/1.


33..2277 AAddddiinngg AArriitthhmmeettiicc FFuunnccttiioonnss

Prolog predicatescan be given therole of arithmetic function. The lastargument is used
to returnthe result, thearguments before thelast are theinputs. Arithmetic functionsare
added usingthe predicatearithmetic_function/1, whichtakes thehead as itsargument.
Arithmetic functionsare module sensitive,that is theyare only visible fromthe module in
whichthe functionis definedand declared. Globalarithmetic functionsshould bedefined and
registered frommodule user. Global definitions canbe overruled locallyin modules. The
builtin functionsdescribed abovecan be redefinedas well.


aarriitthhmmeettiicc__ffuunnccttiioonn((_+_H_e_a_d))
    Register aProlog predicateas an arithmeticfunction (seeis/2, >/2,etc.). The Prolog
    predicate shouldhave onemore argumentthan specifiedby _H_e_a_d,which iteither aterm
    _N_a_m_e_/_A_r_i_t_y, an atomor a complexterm. This lastargument is anunbound variable
    at call time andshould be instantiated toan integer or floatingpoint number. The
    other argumentsare theparameters. This predicateis modulesensitive andwill declare
    the arithmeticfunction onlyfor thecontext module,unless declaredfrom moduleuser.
    Example:

    1 ?- [user].
    :- arithmetic_function(mean/2).

    mean(A, B, C) :-
            C is (A+B)/2.
    user compiled, 0.07 sec, 440 bytes.

    Yes
    2 ?- A is mean(4, 5).

    A = 4.500000


ccuurrrreenntt__aarriitthhmmeettiicc__ffuunnccttiioonn((_?_H_e_a_d))
    Successively unifies all arithmeticfunctions that are visiblefrom the context module
    with _H_e_a_d.


33..2288 LLiisstt MMaanniippuullaattiioonn


iiss__lliisstt((_+_T_e_r_m))
    Succeeds if _T_e_r_mis boundto theempty list([]) ora termwith functor `.'and arity2.


pprrooppeerr__lliisstt((_+_T_e_r_m))
    Equivalent to is_list/1, butalso requires thetail ofthe listto bea list (recursively).
    Examples:

    is_list([x|A])          % true
    proper_list([x|A])      % false


aappppeenndd((_?_L_i_s_t_1_, _?_L_i_s_t_2_, _?_L_i_s_t_3))
    Succeeds when _L_i_s_t_3unifies withthe concatenation of_L_i_s_t_1 and_L_i_s_t_2. The predi-
    cate can beused withany instantiation pattern(even threevariables).


mmeemmbbeerr((_?_E_l_e_m_, _?_L_i_s_t))
    Succeeds when _E_l_e_mcan be unifiedwith one ofthe members of_L_i_s_t. The predicate
    can be usedwith anyinstantiation pattern.


mmeemmbbeerrcchhkk((_?_E_l_e_m_, _+_L_i_s_t))
    Equivalent to member/2,but leavesno choice point.


ddeelleettee((_+_L_i_s_t_1_, _?_E_l_e_m_, _?_L_i_s_t_2))
    Delete all membersof _L_i_s_t_1that simultaneouslyunify with _E_l_e_mand unifythe result
    with _L_i_s_t_2.


sseelleecctt((_?_L_i_s_t_1_, _?_E_l_e_m_, _?_L_i_s_t_2))
    Select an element of _L_i_s_t_1 that unifieswith _E_l_e_m.  _L_i_s_t_2 is unifiedwith the list
    remaining from _L_i_s_t_1 after deleting theselected element.  Normally usedwith the
    instantiation pattern _+_L_i_s_t_1_,  _-_E_l_e_m_,  _-_L_i_s_t_2,but can alsobe used to insertan
    element in alist using_-_L_i_s_t_1_, _+_E_l_e_m_, _+_L_i_s_t_2.


nntthh00((_?_I_n_d_e_x_, _?_L_i_s_t_, _?_E_l_e_m))
    Succeeds when the_I_n_d_e_x-th elementof _L_i_s_t unifieswith _E_l_e_m. Countingstarts at0.


nntthh11((_?_I_n_d_e_x_, _?_L_i_s_t_, _?_E_l_e_m))
    Succeeds when the_I_n_d_e_x-th elementof _L_i_s_t unifieswith _E_l_e_m. Countingstarts at1.


llaasstt((_?_E_l_e_m_, _?_L_i_s_t))
    Succeeds if _E_l_e_munifies withthe lastelement of_L_i_s_t. If _L_i_s_tis a properlist last/2
    is deterministic. If_L_i_s_t has anunbound tail,backtracking will cause_L_i_s_t togrow.


rreevveerrssee((_+_L_i_s_t_1_, _-_L_i_s_t_2))
    Reverse the orderof the elementsin _L_i_s_t_1 and unifythe result withthe elements of
    _L_i_s_t_2.


ffllaatttteenn((_+_L_i_s_t_1_, _-_L_i_s_t_2))
    Transform _L_i_s_t_1, possiblyholding lists aselements into a`flat' list byreplacing each
    list with itselements (recursively). Unifythe resultingflat list with_L_i_s_t_2. Example:

    ?- flatten([a, [b, [c, d], e]], X).

    X = [a, b, c, d, e]


lleennggtthh((_?_L_i_s_t_, _?_I_n_t))
    Succeeds if _I_n_trepresents thenumber of elementsof list_L_i_s_t. Can be usedto create
    a list holdingonly variables.


mmeerrggee((_+_L_i_s_t_1_, _+_L_i_s_t_2_, _-_L_i_s_t_3))
    _L_i_s_t_1 and _L_i_s_t_2 are lists, sortedto the standard order ofterms (see section 3.6).
    _L_i_s_t_3 will be unified withan ordered list holding boththe elements of _L_i_s_t_1 and
    _L_i_s_t_2. Duplicates arennoott removed.


33..2299 SSeett MMaanniippuullaattiioonn


iiss__sseett((_+_S_e_t))
    Succeeds if _S_e_tis aproper list (seeproper_list/1)without duplicates.


lliisstt__ttoo__sseett((_+_L_i_s_t_, _-_S_e_t))
    Unifies _S_e_t witha list holdingthe same elementsas _L_i_s_tin the sameorder. If _l_i_s_t
    contains duplicates, onlythe firstis retained. Seealso sort/2. Example:

    ?- list_to_set([a,b,a], X)

    X = [a,b]


iinntteerrsseeccttiioonn((_+_S_e_t_1_, _+_S_e_t_2_, _-_S_e_t_3))
    Succeeds if _S_e_t_3unifies with theintersection of _S_e_t_1and _S_e_t_2. _S_e_t_1 and_S_e_t_2 are
    lists without duplicates.They need notbe ordered.


ssuubbttrraacctt((_+_S_e_t_, _+_D_e_l_e_t_e_, _-_R_e_s_u_l_t))
    Delete all elementsof set`Delete' from `Set'and unifythe resulting setwith `Result'.


uunniioonn((_+_S_e_t_1_, _+_S_e_t_2_, _-_S_e_t_3))
    Succeeds if _S_e_t_3 unifieswith the unionof _S_e_t_1 and _S_e_t_2. _S_e_t_1and _S_e_t_2 are lists
    without duplicates. Theyneed not beordered.


ssuubbsseett((_+_S_u_b_s_e_t_, _+_S_e_t))
    Succeeds if allelements of_S_u_b_s_e_t are elementsof _S_e_tas well.


mmeerrggee__sseett((_+_S_e_t_1_, _+_S_e_t_2_, _-_S_e_t_3))
    _S_e_t_1 and_S_e_t_2 arelists withoutduplicates, sortedto thestandard orderofterms. _S_e_t_3
    is unified withan ordered listwithout duplicates holdingthe union ofthe elementsof
    _S_e_t_1 and _S_e_t_2.


33..3300 SSoorrttiinngg LLiissttss


ssoorrtt((_+_L_i_s_t_, _-_S_o_r_t_e_d))
    Succeeds if _S_o_r_t_e_dcan be unifiedwith a listholding the elementsof _L_i_s_t, sortedto
    the standard order ofterms (see section3.6).  Duplicatesare removed. Implemented
    by translating the input list into a temporary array, callingthe C-library function
    qsort(3) using PL_compare() for comparing theelements, after which the result
    is translated intothe resultlist.


mmssoorrtt((_+_L_i_s_t_, _-_S_o_r_t_e_d))
    Equivalent to sort/2,but doesnot remove duplicates.


kkeeyyssoorrtt((_+_L_i_s_t_, _-_S_o_r_t_e_d))
    _L_i_s_t isa listof Key-Valuepairs(e.g. termsof thefunctor `-'witharity 2). keysort/2
    sorts _L_i_s_t likemsort/2, but onlycompares the keys. Canbe used tosort terms not
    on standard order,but on anycriterion that canbe expressed ona multi-dimensional
    scale.  Sorting onmore than one criterioncan be done usingterms as keys, putting
    the first criterionas argument1, the secondas argument 2,etc. The orderof multiple
    elements that havethe same_K_e_y is notchanged.


pprreeddssoorrtt((_+_P_r_e_d_, _+_L_i_s_t_, _-_S_o_r_t_e_d))
    Sorts  similar to  sort/2, but  determines the order  of two  terms by calling
    _P_r_e_d(-_D_e_l_t_a, +_E_1, +_E_2).  This callmust unify _D_e_l_t_a with one of<, const> or =.
    If built-in predicate compare/3is used, the result isthe same as sort/2. See also
    keysort/2.


33..3311 FFiinnddiinngg aallll SSoolluuttiioonnss ttoo aa GGooaall


ffiinnddaallll((_+_V_a_r_, _+_G_o_a_l_, _-_B_a_g))
    Creates a list of theinstantiations _V_a_r gets successively on backtrackingover _G_o_a_l
    and unifies theresult with _B_a_g.Succeeds with anempty list if_G_o_a_l hasno solutions.
    findall/3 is equivalentto bagof/3 withall free variablesbound with theexistence
    operator (^), exceptthat bagof/3fails when goalhas nosolutions.


bbaaggooff((_+_V_a_r_, _+_G_o_a_l_, _-_B_a_g))
    Unify _B_a_gwith thealternatives of_V_a_r, if_G_o_a_lhas freevariables besidesthe onesharing
    with _V_a_r bagofwill backtrackover thealternatives ofthese freevariables, unifying_B_a_g
    with the correspondingalternatives of _V_a_r. Theconstruct +Var^Goal tellsbagof not
    to bind _V_a_rin _G_o_a_l. bagof/3fails if_G_o_a_l has nosolutions.

    The example belowillustrates bagof/3and the ^operator. The variablebindings are
    printed together onone lineto save paper.

    2 ?- listing(foo).

    foo(a, b, c).
    foo(a, b, d).
    foo(b, c, e).
    foo(b, c, f).
    foo(c, c, g).

    Yes
    3 ?- bagof(C, foo(A, B, C), Cs).

    A = a, B = b, C = G308, Cs = [c, d] ;
    A = b, B = c, C = G308, Cs = [e, f] ;
    A = c, B = c, C = G308, Cs = [g] ;

    No
    4 ?- bagof(C, A^foo(A, B, C), Cs).

    A = G324, B = b, C = G326, Cs = [c, d] ;
    A = G324, B = c, C = G326, Cs = [e, f, g] ;

    No
    5 ?-


sseettooff((_+_V_a_r_, _+_G_o_a_l_, _-_S_e_t))
    Equivalent to bagof/3,but sorts theresult usingsort/2 to geta sortedlist of alter-
    natives without duplicates.


33..3322 IInnvvookkiinngg PPrreeddiiccaatteess oonn aallll MMeemmbbeerrss ooff aa LLiisstt

Allthe predicatesin thissection calla predicateon allmembers ofa listor untilthe predicate
called fails. The predicateis called viacall/[2..], which implies commonarguments can be
put infront ofthe arguments obtainedfrom thelist(s). For example:

?- maplist(plus(1), [0, 1, 2], X).

X = [1, 2, 3]

we willphrase thisas \_P_r_e_d_i_c_a_t_e isapplied on..."


cchheecckklliisstt((_+_P_r_e_d_, _+_L_i_s_t))
    _P_r_e_d is appliedsuccessively on eachelement of_L_i_s_t until theend of thelist or _P_r_e_d
    fails. In thelatter case thechecklist/2 fails.


mmaapplliisstt((_+_P_r_e_d_, _?_L_i_s_t_1_, _?_L_i_s_t_2))
    Apply _P_r_e_d onall successive pairsof elements from_L_i_s_t_1 and _L_i_s_t_2. Fails if_P_r_e_d
    can not beapplied toa pair. Seethe example above.


ssuubblliisstt((_+_P_r_e_d_, _+_L_i_s_t_1_, _?_L_i_s_t_2))
    Unify _L_i_s_t_2 witha listof all elementsof _L_i_s_t_1to which _P_r_e_dapplies.


33..3333 FFoorraallll


ffoorraallll((_+_C_o_n_d_, _+_A_c_t_i_o_n))
    For all alternativebindings of _C_o_n_d_A_c_t_i_o_n canbe proven. The exampleverifies that
    all arithmetic statementsin thelist _Lare correct. Itdoes notsay whichis wrong ifone
    proves wrong.

    ?- forall(member(Result = Formula, [2 = 1 + 1, 4 = 2 * 2]),
                     Result =:= Formula).


33..3344 FFoorrmmaatttteedd WWrriittee

The current  version of SWI-Prolog  provides two formatted  write predicates.   The
first is writef/[1,2], which is compatible with Edinburgh C-Prolog.  The second is
format/[1,2], which is compatiblewith Quintus Prolog.  We hopethe Prolog commu-
nity will oncedefine a standard formatted write predicate. If you wantperformance use
format/[1,2] asthis predicate isdefined inC. Otherwise compatibilityreasons might tell
you whichpredicate touse.


33..3344..11 WWrriitteeff


wwrriittee__llnn((_+_T_e_r_m))
    Equivalent to write(Term), nl.


wwrriitteeff((_+_A_t_o_m))
    Equivalent to writef(Atom, []).


wwrriitteeff((_+_F_o_r_m_a_t_, _+_A_r_g_u_m_e_n_t_s))
    Formatted write. _F_o_r_m_a_t is anatom whose characters willbe printed. _F_o_r_m_a_t may
    contain certain special charactersequences which specifycertain formatting andsub-
    stitution actions. _A_r_g_u_m_e_n_t_sthen provides allthe termsrequired to beoutput.

    Escape sequences togenerate asingle special character:

             __________________________________________________
             | \n   |Outputa nemlinecharacter (see alsonl/[0,1])|
             | \l   |Outputa lineseparator (same as\n)         |
             | \r   |Outputa carriage-returncharacter (ASCII 13)|

             | \t   |Outputthe ASCIIcharacter TAB (9)          |
             | \\   |Thecharacter \is output                   |
             | \%   |Thecharacter %is output                   |
             | \nnn |where<_n_n_n> is an integer(1-3 digits) the character|
             |      |withASCII code<_n_n_n> isoutput (NB :<_n_n_n> isread|
             |______|asddeecciimmaall)________________________________|

    Note that \l, \nnnand \\ are interpreteddifferently when character-escapes arein
    effect. See section2.15.1.1.

    Escape sequences to includearguments from _A_r_g_u_m_e_n_t_s. Each time a% escape se-
    quence is foundin _F_o_r_m_a_tthe nextargument from _A_r_g_u_m_e_n_t_sis formattedaccording
    to the specification.

              _________________________________________________%t

              | %w  print/1 thenext item(mnemonic: term)      |    |

              | %q  |write/1thenext item                      |

              |     |writeq/1thenext item                     |
              | %d  |Write  the term,  ignoring operators.   See| also
              |     |write_term/2.    Mnemonic:    old  Edinburgh|
              | %p  |display/1.                               |

              |     |print/1thenext item(identical to %t)     |
              | %n  |Put thenext item asa character (i.e.it isan|ASCII
              |     |value)                                   |
              | %r  |Write the nextitem N timeswhere N is thesecond|
              |     |item (aninteger)                         |

              | %s  |Write thenext item asa String (soit must bea|list
              |     |of characters)                           |
              | %f  |Perform attyflush/0 (noitems used)       |
              | %Nc |Write thenext itemCentered in Ncolumns.  |
              | %Nl |Write thenext itemLeft justified inN columns.|
              | %Nr |Write thenext itemRight justified inN columns.|N
              |     |is adecimal numberwith atleast onedigit. Theitem|

              |_____|must_bean_atom,integer,_float_orstring.__|_


sswwrriitteeff((_-_S_t_r_i_n_g_, _+_F_o_r_m_a_t_, _+_A_r_g_u_m_e_n_t_s))
    Equivalent to writef/2, but \writes" the resulton _S_t_r_i_n_g instead of the current
    output stream. Example:

    ?- swritef(S, '%15L%w', ['Hello', 'World']).

    S = "Hello          World"


sswwrriitteeff((_-_S_t_r_i_n_g_, _+_F_o_r_m_a_t))
    Equivalent to swritef(String, Format, []).


33..3344..22 FFoorrmmaatt


ffoorrmmaatt((_+_F_o_r_m_a_t))
    Defined as `format(Format) :- format(Format, []).'


ffoorrmmaatt((_+_F_o_r_m_a_t_, _+_A_r_g_u_m_e_n_t_s))
    _F_o_r_m_a_t is anatom, list ofASCII values, ora Prolog string. _A_r_g_u_m_e_n_t_sprovides the
    arguments required bythe format specification. Ifonly one argument isrequired and
    this is nota listof ASCIIvalues the argumentneed notbe putin a list.Otherwise the
    arguments are putin alist.

    Special sequences startwith the tilde(~), followed by anoptional numeric argument,
    followed by a character describing the action to be undertaken.  A numericargu-
    ment is eithera sequenceof digits, representinga positivedecimal number, asequence
    `<_c_h_a_r_a_c_t_e_r>, representingthe ASCII valueof the character (onlyuseful for ~t)or
    a asterisk (*),in when thenumeric argument istaken from thenext argument ofthe
    argument list, whichshould bea positive integer.Actions are:

      ~  Outputthe tilde itself.

      a  Output thenext argument, whichshould be anatom. This option isequivalent
         toww. Compatibility reasonsonly.

      c  Outputthe nextargument asan ASCIIvalue. Thisargument shouldbe aninteger
         inthe range [0,..., 255](including 0 and255).

      d  Outputnext argumentas adecimal number. Itshould bean integer.If anumeric
         argumentis specified adot isinserted _a_r_g_u_m_e_n_t positionsfrom theright (useful
         fordoing fixedpointarithmetic withintegers, suchas handlingamountsof money).

      D  Sameas dd,but makeslarge valueseasier toread byinserting acomma everythree
         digitsleft to thedot orright.

      e  Output nextargument as afloating point numberin exponential notation. The
         numericargument specifiesthe precision.Default is6 digits. Exactrepresentation
         depends onthe C library function printf(). This function is invokedwith the
         format%.<_p_r_e_c_i_s_i_o_n>e.

      E  Equivalentto ee, butoutputs acapital E toindicate theexponent.

      f  Floatingpoint in non-exponentialnotation. See Clibrary functionprintf().

      g  Floatingpoint in eeor ffnotation, whichever isshorter.

      G  Floatingpoint in EEor ffnotation, whichever isshorter.

      i  Ignorenext argument ofthe argumentlist. Produces nooutput.

      k  Givethe next argumentto displayq/1(canonical write).

      n  Outputa newline character.

      N  Only output anewline if the last character output on thisstream was not a
         newline. Notproperly implementedyet.

      p  Givethe next argumentto print/1.

      q  Givethe next argumentto writeq/1.

      r  Print integerin radix thenumeric argument notation. Thus~16r prints its ar-
         gumenthexadecimal. The argumentshould bein the range[2;:::; 36]. Lowercase
         lettersare used fordigits above9.

      R  Sameas rr, butuses uppercase letters fordigits above9.

      s  Outputa string ofASCII charactersor a string(see string/1and section 3.23)
         fromthe next argument.

      t  Allremaining spacebetween 2tabs tops isdistributed equallyover ~tstatements
         betweenthe tabstops. Thisspace ispaddedwith spacesby default.If anargument
         issupplied this istaken tobe the ASCIIvalue ofthe character usedfor padding.
         This canbe used todo left orright alignment, centering, distributing,etc. See
         also~| and ~+to settab stops. Atabs top isassumed atthe start ofeach line.

      |  Seta tabstop onthe currentposition. Ifan argumentis suppliedset atabs topon
         theposition of thatargument. This willcause all ~t'sto bedistributed between
         theprevious and thistabs top.

      +  Seta tabs toprelative tothe current position.Further the sameas ~|.

      w  Givethe next argumentto write/1.

      W  Givethe nexttwoargument towrite_term/2. Thisoption isSWI-Prologspecific.

    Example:

    simple_statistics :-
        <obtain statistics>         % left to the user
        format('~tStatistics~t~72|~n~n'),
        format('Runtime: ~`.t ~2f~34|  Inferences: ~`.t ~D~72|~n',
                                                [RunT, Inf]),
        ....

    Will output

                                 Statistics

    Runtime: .................. 3.45  Inferences: .......... 60,345


ffoorrmmaatt((_+_S_t_r_e_a_m_, _+_F_o_r_m_a_t_, _+_A_r_g_u_m_e_n_t_s))
    As format/2, butwrite theoutput on thegiven _S_t_r_e_a_m.


ssffoorrmmaatt((_-_S_t_r_i_n_g_, _+_F_o_r_m_a_t_, _+_A_r_g_u_m_e_n_t_s))
    Equivalent to format/2, but \writes" the resulton _S_t_r_i_n_g instead of the current
    output stream. Example:

    ?- sformat(S, '~w~t~15|~w', ['Hello', 'World']).

    S = "Hello          World"


ssffoorrmmaatt((_-_S_t_r_i_n_g_, _+_F_o_r_m_a_t))
    Equivalent to `sformat(String, Format, []).'


33..3344..33 PPrrooggrraammmmiinngg FFoorrmmaatt


ffoorrmmaatt__pprreeddiiccaattee((_+_C_h_a_r_, _+_H_e_a_d))
    If asequence ~c (tilde,followed bysome character)is found,the formatderivatives will
    first check whetherthe user hasdefined a predicate tohandle the format. Ifnot, the
    built in formattingrules described aboveare used. _C_h_a_r iseither an asciivalue, or
    a one character atom,specifying the letter tobe (re)defined. _H_e_a_d is aterm, whose
    name and arityare usedto determinethe predicate tocall forthe redefinedformatting
    character. The first argumentto the predicateis the numericargument of theformat
    command, or theatom defaultif noargument is specified.The remainingarguments
    are filledfrom theargument list. Theexample belowredefines ~nto produce_A_r_g times
    return followed bylinefeed (soa (Grr.) DOSmachine is happywith theoutput).

    :- format_predicate(n, dos_newline(_Arg)).

    dos_newline(Arg) :-
            between(1, Ar, _), put(13), put(10), fail ; true.


ccuurrrreenntt__ffoorrmmaatt__pprreeddiiccaattee((_?_C_o_d_e_, _?_:_H_e_a_d))
    Enumerates alluser-defined formatpredicates. _C_o_d_e isthe charactercode ofthe format
    character. _H_e_a_d isunified with aterm withthe same nameand arityas the predicate.
    If the predicatedoes not reside inmodule user, _H_e_a_dis qualified withthe definition
    module of thepredicate.


33..3355 TTeerrmmiinnaall CCoonnttrrooll

The following predicatesform a simple access mechanismto the Unix termcap libraryto
provide terminalindependent I/O forscreen terminals. These predicatesare only available
on Unixmachines. The SWI-PrologWindows consolesaccepts the ANSIescape sequences.


ttttyy__ggeett__ccaappaabbiilliittyy((_+_N_a_m_e_, _+_T_y_p_e_, _-_R_e_s_u_l_t))
    Get the capabilitynamed _N_a_m_e from thetermcap library. See termcap(5)for the ca-
    pability names. _T_y_p_e specifiesthe type ofthe expected result,and is oneof string,
    number or bool. Stringresults are returnedas an atom,number result asan integer
    and boolresults asthe atomon oroff. If anoptioncannot befound thispredicate fails
    silently. The resultsare onlycomputed once. Successivequeries onthe samecapability
    are fast.


ttttyy__ggoottoo((_+_X_, _+_Y))
    Goto position (_X, _Y)on the screen.  Notethat the predicates line_count/2 and
    line_position/2 willnot have awell definedbehaviour whileusing this predicate.


ttttyy__ppuutt((_+_A_t_o_m_, _+_L_i_n_e_s))
    Put an atomvia the termcaplibrary function tputs(). Thisfunction decodespadding
    information in thestrings returnedby tty_get_capability/3and shouldbe usedto
    output these strings._L_i_n_e_s isthe numberof linesaffected by theoperation, or1 ifnot
    applicable (as inalmost allcases).


sseett__ttttyy((_-_O_l_d_S_t_r_e_a_m_, _+_N_e_w_S_t_r_e_a_m))
    Set the outputstream, used bytty_put/2and tty_goto/2to a specificstream. De-
    fault is user_output.


33..3366 OOppeerraattiinngg SSyysstteemm IInntteerraaccttiioonn


sshheellll((_+_C_o_m_m_a_n_d_, _-_S_t_a_t_u_s))
    Execute _C_o_m_m_a_n_d on the operating system. _C_o_m_m_a_n_d is given to the Bourne shell
    (/bin/sh). _S_t_a_t_u_s isunified with theexit statusof the command.

    On _W_i_n_3_2 systems, shell/[1,2] executesthe command using the CreateProcess()
    API and  waits for the command to terminate.  If the command ends with a &
    sign, the command is handed to the WinExec() API,which does not wait for the
    new task to terminate.   See also win_exec/2.  Please note that the CreatePro-
    cess() API doesnnoott implythe Windowscommand interpreter(command.exe on Win-
    dows 95/98 and cmd.exe onWindows-NT) and therefore commands built-into the
    command-interpreter can onlybe activatedusing the commandinterpreter. For exam-
    ple: 'command.exe /C copy file1.txt file2.txt'


sshheellll((_+_C_o_m_m_a_n_d))
    Equivalent to `shell(Command, 0)'.


sshheellll
    Start an interactive Unixshell. Default is /bin/sh,the environment variableSHELL
    overrides this default.Not available forWin32 platforms.


wwiinn__eexxeecc((_+_C_o_m_m_a_n_d_, _+_S_h_o_w))
    Win32 systems only.Spawns aWindows taskwithout waiting forits completion._S_h_o_w
    is either iconicor normaland dictatesthe initial statusof thewindow. The iconic
    option is notablyhandy tostart (DDE) servers.


ggeetteennvv((_+_N_a_m_e_, _-_V_a_l_u_e))
    Get environment variable.Fails silently ifthe variabledoes notexist. Please notethat
    environment variable namesare case-sensitiveon Unix systemsand case-insensitiveon
    Windows.


sseetteennvv((_+_N_a_m_e_, _+_V_a_l_u_e))
    Set environmentvariable. _N_a_m_e and_V_a_l_u_e shouldbe instantiatedto atomsor integers.
    The environment variablewill be passedto shell/[0-2]and can berequested using
    getenv/2. They alsoinfluence expand_file_name/2.


uunnsseetteennvv((_+_N_a_m_e))
    Remove environment variablefrom theenvironment.


uunniixx((_+_C_o_m_m_a_n_d))
    This predicate comes from the Quintuscompatibility library and provides a partial
    implementation thereof. Itprovides accesstosome operatingsystem featuresand unlike
    the namesuggests, isnot operatingsystem specific. Currentlyitis theonly wayto fetch
    the Prolog command-linearguments. Defined _C_o_m_m_a_n_d'sare below.

    ssyysstteemm((_+_C_o_m_m_a_n_d))
         Equivalentto calling shell/1.Use for compatibilityonly.

    sshheellll((_+_C_o_m_m_a_n_d))
         Equivalentto calling shell/1.Use for compatibilityonly.

    sshheellll
         Equivalentto calling shell/0.Use for compatibilityonly.

    ccdd
         Equivalentto calling chdir/1as chdir(~). Usefor compatibilityonly.

    ccdd((_+_D_i_r_e_c_t_o_r_y))
         Equivalentto calling chdir/1.Use for compatibilityonly.

    aarrggvv((_-_A_r_g_v))
         Unify_A_r_g_v with thelist of commandlinearguments providesto this Prologrun.
         Please notethat Prolog system-arguments andapplication arguments aresepa-
         ratedby --. Integerarguments arepassed asPrologintegers, floatarguments and
         Prologfloating point numbersand allother arguments asProlog atoms.

         A stand-aloneprogram coulduse the followingskeleton to handlecommand-line
         arguments. Seealso section2.10.2.3.

         main :-
                 unix(argv(Argv)),
                 append(_PrologArgs, [--|AppArgs], Argv), !,
                 main(AppArgs).


ggeett__ttiimmee((_-_T_i_m_e))
    Return the numberof secondsthat elapsed sincethe epochof Unix, 1January 1970,0
    hours. _T_i_m_e is afloating pointnumber. Its granularity issystem dependent. Onsun,
    this is 1/60of asecond.


ccoonnvveerrtt__ttiimmee((_+_T_i_m_e_, _-_Y_e_a_r_, _-_M_o_n_t_h_, _-_D_a_y_, _-_H_o_u_r_, _-_M_i_n_u_t_e_, _-_S_e_c_o_n_d_, _-_M_i_l_l_i_S_e_c_o_n_d_s))

    Convert a time stamp, provided by get_time/1, time_file/2, etc.  _Y_e_a_r isuni-
    fied with theyear, _M_o_n_t_hwith the monthnumber (January is1), _D_a_ywith the dayof
    the month (startingwith 1), _H_o_u_rwith the hour ofthe day (0{23),_M_i_n_u_t_e with the
    minute (0{59). _S_e_c_o_n_dwith thesecond (0{59)and_M_i_l_l_i_S_e_c_o_n_d withthe milliseconds
    (0{999). Note that thelatter might notbe accurate ormight always be0, depending
    on the timingcapabilities ofthe system. Seealso convert_time/2.


ccoonnvveerrtt__ttiimmee((_+_T_i_m_e_, _-_S_t_r_i_n_g))
    Convert a time-stamp asobtained though get_time/1 intoa textual representation
    using the C-library functionctime(). The value is returnedas a SWI-Prologstring
    object (see section3.23). See alsoconvert_time/8.


33..3377 FFiillee SSyysstteemm IInntteerraaccttiioonn


aacccceessss__ffiillee((_+_F_i_l_e_, _+_M_o_d_e))
    Succeeds if _F_i_l_eexists and canbe accessed bythis prolog processunder mode_M_o_d_e.
    _M_o_d_e is oneof theatoms read, write,append, exist,none or execute._F_i_l_e may
    also be thename of adirectory. Fails silentlyotherwise. access_file(File, none)
    simply succeeds withouttesting anything.

    If `Mode' iswrite orappend, thispredicate alsosucceeds if thefile doesnot existand
    the user haswrite-access tothe directory ofthe specifiedlocation.


eexxiissttss__ffiillee((_+_F_i_l_e))
    Succeeds when _F_i_l_eexists.  Thisdoes not implythe user hasread and/or writeper-
    mission for thefile.


ffiillee__ddiirreeccttoorryy__nnaammee((_+_F_i_l_e_, _-_D_i_r_e_c_t_o_r_y))
    Extracts the directory-part of _F_i_l_e. The resulting_D_i_r_e_c_t_o_r_y name ends with the
    directory separatorcharacter /. If_F_i_l_e isan atomthat doesnot contain anydirectory
    separator characters, theempty atom'' is returned.See also file_base_name/2.


ffiillee__bbaassee__nnaammee((_+_F_i_l_e_, _-_B_a_s_e_N_a_m_e))
    Extracts the filename part froma path specification. If _F_i_l_e does not containany
    directory separators, _F_i_l_eis returned.


ssaammee__ffiillee((_+_F_i_l_e_1_, _+_F_i_l_e_2))
    Succeeds if bothfilenames referto thesame physical file.That is, if_F_i_l_e_1 and_F_i_l_e_2
    are the same string orboth names exist andpoint to the same file(due to hard or
    symbolic links and/orrelative vs. absolutepaths).


eexxiissttss__ddiirreeccttoorryy((_+_D_i_r_e_c_t_o_r_y))
    Succeeds if _D_i_r_e_c_t_o_r_y exists. Thisdoes not imply theuser has read, searchand or
    write permission forthe directory.


ddeelleettee__ffiillee((_+_F_i_l_e))
    Unlink _F_i_l_e fromthe Unixfile system.


rreennaammee__ffiillee((_+_F_i_l_e_1_, _+_F_i_l_e_2))
    Rename _F_i_l_e_1 into_F_i_l_e_2. Currently filescannot bemoved across devices.


ssiizzee__ffiillee((_+_F_i_l_e_, _-_S_i_z_e))
    Unify _S_i_z_e withthe sizeof _F_i_l_e incharacters.


ttiimmee__ffiillee((_+_F_i_l_e_, _-_T_i_m_e))
    Unify the lastmodification time of_F_i_l_e with _T_i_m_e. _T_i_m_eis a floatingpoint number
    expressing the secondselapsed sinceJan 1, 1970.


aabbssoolluuttee__ffiillee__nnaammee((_+_F_i_l_e_, _-_A_b_s_o_l_u_t_e))
    Expand Unixfile specification intoan absolutepath. Userhome directoryexpansion (~
    and  <_u_s_e_r>) andvariable expansionisdone. The absolutepathis canonised:references
    to . and ..are deleted. SWI-Prolog uses absolutefile names to registersource files
    independent of thecurrent workingdirectory. See alsoabsolute_file_name/3.


aabbssoolluuttee__ffiillee__nnaammee((_+_S_p_e_c_, _+_O_p_t_i_o_n_s_, _-_A_b_s_o_l_u_t_e))
    Converts the givenfile specification intoan absolute path._O_p_t_i_o_n is alist of options
    to guide theconversion:

    eexxtteennssiioonnss((_L_i_s_t_O_f_E_x_t_e_n_s_i_o_n_s))
         List of  file-extensions  to try.    Default  is ''.    For each  extension,
         absolute_file_name/3will first add the extensionand then verify the con-
         ditionsimposed by theother options. Ifthe conditionfails, thenext extension of
         thelist is tried.Extensions may bespecified bothas ..ext orplain ext.

    aacccceessss((_M_o_d_e))
         Imposes thecondition access_file(_F_i_l_e, _M_o_d_e). _M_o_d_e ison of read,write, ap-
         pend,exist or none.See also access_file/2.

    ffiillee__ttyyppee((_T_y_p_e))
         Defines extensions.  Current  mapping: txt  implies [''], prolog implies
         ['.pl', ''], executableimplies ['.so', ''], qlfimplies ['.qlf', '']
         anddirectory implies [''].

    ffiillee__eerrrroorrss((_f_a_i_l_/_e_r_r_o_r))
         If error(default), throwand existence_error exceptionif thefile cannot be
         found. Iffail, staysilent.

    ssoolluuttiioonnss((_f_i_r_s_t_/_a_l_l))
         Iffirst (default),the predicatesleaves nochoice-point. Otherwisea choice-point
         willbe left andbacktracking mayyield more solutions.


iiss__aabbssoolluuttee__ffiillee__nnaammee((_+_F_i_l_e))
    True if _F_i_l_e specifies and absolute path-name. On Unix systems, this impliesthe
    path starts with a`/'. For Microsoft based systemsthis implies thepath starts with
    <_l_e_t_t_e_r>:. This predicate isintended to provide platform-independentchecking for
    absolute paths. Seealso absolute_file_name/2and prolog_to_os_filename/2.


ffiillee__nnaammee__eexxtteennssiioonn((_?_B_a_s_e_, _?_E_x_t_e_n_s_i_o_n_, _?_N_a_m_e))
    This predicate isused toadd, remove ortest filenameextensions. The mainreason for
    its introduction is todeal with differentfilename properties ina portable manner. If
    the file systemis case-insensitive,testing for anextension will bedone case-insensitive
    too. _E_x_t_e_n_s_i_o_n maybe specified withor withouta leading dot(.). If an_E_x_t_e_n_s_i_o_n
    is generated, itwill nothave a leadingdot.


eexxppaanndd__ffiillee__nnaammee((_+_W_i_l_d_C_a_r_d_, _-_L_i_s_t))
    Unify _L_i_s_t with asorted list offiles or directoriesmatching _W_i_l_d_C_a_r_d. The normal
    Unix wildcard constructs`?', `*', `[...]' and`{...}' arerecognised. The interpreta-
    tion of `{...}' isinterpreted slightly differentfrom the Cshell (csh(1)). The comma
    separated argument canbe arbitrary patterns,including `{...}' patterns. Theempty
    pattern is legalas well: `\{.pl,\}'matches either`.pl' or theempty string.

    Before expanding wildchards,the construct$var is expandedto thevalue of theenvi-
    ronment variable_v_a_r anda possible leading~ characteris expandedto theuser's home
    directory..


pprroolloogg__ttoo__ooss__ffiilleennaammee((_?_P_r_o_l_o_g_P_a_t_h_, _?_O_s_P_a_t_h))
    Converts between theinternal Prologpathname conventions andthe operating-system
    pathname conventions. Theinternal conventions areUnix andthis predicatesis equiv-
    alent to =/2(unify) on Unix systems. OnDOS systems itwill change thedirectory-
    separator, limitthe filename lengthmap dots,except forthe lastone, ontounderscores.


rreeaadd__lliinnkk((_+_F_i_l_e_, _-_L_i_n_k_, _-_T_a_r_g_e_t))
    If _F_i_l_e pointsto asymbolic link,unify _L_i_n_k withthe valueof thelink and _T_a_r_g_e_tto
    the filethe linkis pointingto. _T_a_r_g_e_t pointsto afile, directoryor non-existingentryin
    the file system,but neverto a link.Fails if_F_i_l_e is nota link. Failsalways onsystems
    that do notsupport symboliclinks.


ttmmpp__ffiillee((_+_B_a_s_e_, _-_T_m_p_N_a_m_e))
    Create a namefor a temporaryfile. _B_a_s_e is anidentifier forthe category offile. The
    _T_m_p_N_a_m_e is guaranteedto be unique.If the systemhalts, itwill automatically remove
    all created temporaryfiles.


cchhddiirr((_+_P_a_t_h))
    Change working directoryto _P_a_t_h.


33..3388 MMuullttii--tthhrreeaaddiinngg ((aallpphhaa ccooddee))

TThhee ffeeaattuurreess ddeessccrriibbeedd iinn tthhiiss sseeccttiioonn aarree oonnllyy eennaabblleedd  oonn UUnniixx ssyysstteemmss
pprroovviiddiinngg  PPOOSSIIXX tthhrreeaaddss  aanndd  iiff tthhee  ssyysstteemm  iiss ccoonnffiigguurreedd  uussiinngg  tthhee
--enable-mt ooppttiioonn..   SSWWII--PPrroolloogg mmuullttii--tthheeaaddiinngg ssuuppppoorrtt iiss  eexxppeerriimmeennttaall
aanndd iinn ssoommee aarreeaass nnoott ssaaffee..

SWI-Prolog multithreadingis based on standardC-language multithreading support. It is
notlike _P_a_r_L_o_gor otherparalel implementationsof theProlog language.Prolog threadshave
their ownstacks andonly share theProlog _h_e_a_p: predicates,records, flags andother global
non-backtrackable data. SWI-Prologthread support isdesigned with thefollowing goals in
mind.

  o _M_u_l_t_i_-_t_h_r_e_a_d_e_d _s_e_r_v_e_r _a_p_p_l_i_c_a_t_i_o_n_s
    Todays computing services oftenfocus on (internet) serverapplications.  Suchappli-
    cations often haveneed for communication betweenservices and/or fastnon-blocking
    service to multiple concurrentclients.  Theshared heap providesfast communication
    and thread creationis relatively cheap(A Pentium-II/450can create andjoin approx.
    10,000 threads persecond onLinux 2.2).

  o _I_n_t_e_r_a_c_t_i_v_e _a_p_p_l_i_c_a_t_i_o_n_s
    Interactive applications oftenneed to performextensive computation. If suchcompu-
    tations are executedin anew thread,the mainthread canprocess events andallow the
    user to cancelthe ongoingcomputation. User interfaces canalso usemultiple threads,
    each thread dealingwith inputfrom a distinctgroup ofwindows.

  o _N_a_t_u_r_a_l _i_n_t_e_g_r_a_t_i_o_n _w_i_t_h _f_o_r_e_i_g_n _c_o_d_e
    Each Prologthread runsin aC-thread, automatically makingthem cooperatewith _M_T_-
    _s_a_f_e foreign-code. Inaddition, anyforeign thread cancreate itsown Prologengine for
    dealing with callingProlog fromC-code.


tthhrreeaadd__ccrreeaattee((_:_G_o_a_l_, _-_I_d_, _+_O_p_t_i_o_n_s))
    Create a newProlog thread(and underlyingC-thread) and startit byexecuting _G_o_a_l.
    If the threadis createdsuccesfully, thethread-identifier of thecreated threadis unified
    to _I_d. _O_p_t_i_o_n_sis a listof options. Currentlydefined optionsare:

    llooccaall((_K_-_B_y_t_e_s))
         Setthe limitto whichthe localstack ofthis threadmay grow. Ifomited, thelimit
         ofthe calling threadis used. Seealso the-L commandline option.

    gglloobbaall((_K_-_B_y_t_e_s))
         Set thelimit to whichthe global stackof this thread maygrow. If omited, the
         limitof the callingthread isused. See alsothe -G commandlineoption.

    ttrraaiill((_K_-_B_y_t_e_s))
         Setthe limitto whichthe trail stackof thisthread maygrow. Ifomited, the limit
         ofthe calling threadis used. Seealso the-T commandline option.

    aarrgguummeenntt((_K_-_B_y_t_e_s))
         Setthe limitto which theargument stackof thisthread maygrow. If omited,the
         limitof the callingthread isused. See alsothe -A commandlineoption.

    aalliiaass((_A_l_i_a_s_N_a_m_e))
         Associate an`alias-name' with thethread. This named maybe used torefer to
         thethread and remainsvalid untilthe thread isjoined (seethread_join/2).

    ddeettaacchheedd((_B_o_o_l))
         If false (default),  the thread can  be waited for  using thread_join/2.
         thread_join/2must be called on thisthread to reclaim the allresources as-
         sociated tothe thread. If true,the system willreclaim all associatedresources
         automaticallyafter thethread finishes. Pleasenot thatthreadidentifiers arefreed
         forreuse after adetached threadfinishes or anormal threadhas been joined.

    The _G_o_a_l argumentis _c_o_p_i_e_d tothe newProlog engine. This impliesfurther instan-
    tiation of thisterm in either threaddoes not haveconsequences for theother thread:
    Prolog threads donot sharedata from theirstacks.


tthhrreeaadd__sseellff((_-_I_d))
    Get the Prologthread identifier ofthe running thread. Ifthe thread hasan alias,the
    alias-name is returned.


ccuurrrreenntt__tthhrreeaadd((_?_I_d_, _?_S_t_a_t_u_s))
    Enumerates  identifiers  and status  of all  currently known  threads.   Calling
    current_thread/2 does not influence anythread.  See also thread_join/2.  For
    threads that havean alias-name, thisname is returnedin _I_dinstead of thenumerical
    thread identifier. _S_t_a_t_u_sis one of:

    rruunnnniinngg
         The threadis running. This is the initialstatus of a thread. Please notethat
         threatswaiting for somethingare consideredrunning too.

    ffaallssee
         The_G_o_a_l of thethread hasbeen completed andfailed.

    ttrruuee
         The_G_o_a_l of thethread hasbeen completed andsucceeded.

    eexxiitteedd((_T_e_r_m))
         The_G_o_a_l ofthe thread hasbeen terminatedusing thread_exit/1with_T_e_r_m as
         argument.

    eexxcceeppttiioonn((_T_e_r_m))
         The _G_o_a_lof thethread has beenterminated due toan uncaught exception(see
         throw/1and catch/3).


tthhrreeaadd__jjooiinn((_+_I_d_, _-_S_t_a_t_u_s))
    Wait for the terminationof thread with given _I_d. Then unifythe result-status (see
    thread_exit/1) of thethread with _S_t_a_t_u_s. Afterthis call, _I_dbecomes invalid and
    all resources associatedwith thethread are reclaimed.See also current_thread/2.

    A thread thathas beencompleted withoutthread_join/2 beingcalled onit ispartly
    reclaimed: the Prologstacks are releasedand theC-thread is destroyed.A smalldata-
    structure represening theexit-status of thethread isretained until thread_join/2is
    called on thethread.


tthhrreeaadd__eexxiitt((_+_T_e_r_m))
    Terminates the threadimmediately, leavingexited(_T_e_r_m) as result-state.The Prolog
    stacks and C-threadare reclaimed.


tthhrreeaadd__aatt__eexxiitt((_:_G_o_a_l))
    Run _G_o_a_l afterthe executionof thisthread hasterminated. This isto becompared to
    at_halt/1, butonly forthe currentthread. These hooksare ranregardless ofwhy the
    execution of thethread hasbeen completed. Asthese hooksare run,the return-codeis
    already available throughcurrent_thread/2.


33..3388..11 TThhrreeaadd ccoommmmuunniiccaattiioonn

Prolog threads canexchange data using dynamic predicates, databaserecords, and other
globally shareddata. In addition,they can sendmessages to eachother. If athreads needs
to waitfor anotherthread untilthat threadhas producedsome data,using onlythe database
forces thewaiting threadto poll thedatabase continuously. Waitingfor amessage suspends
the threadexecution untilthe message hasarrived inits message queue.


tthhrreeaadd__sseenndd__mmeessssaaggee((_+_T_h_r_e_a_d_I_d_, _+_T_e_r_m))
    Place _T_e_r_min themessage queueof theindicatedthread (whichcan evenbe themessage
    queue of itself(see thread_self/1). Any termcan be placedin amessage queue,but
    note that theterm iscopied to toreceiving threadand variable-bindings arethus lost.
    This call returnsimmediately.


tthhrreeaadd__ggeett__mmeessssaaggee((_?_T_e_r_m))
    Examines thethread message-queue andif necessaryblocks executionuntil aterm that
    unifies to _T_e_r_m arrives inthe queue. After a term from thequeue has been unified
    unified to _T_e_r_m,this termis deleted fromthe queueand this predicatereturns.

    Please note that not-unifyingmessages remain in thequeue. After the following has
    been executed,thread 1has the termb(_g_n_u) inits queueand continuesexecution using
    _A is gnat.

       <thread 1>
       thread_get_message(a(A)),

       <thread 2>
       thread_send_message(b(gnu)),
       thread_send_message(a(gnat)),

    See also thread_peek_message/1.


tthhrreeaadd__ppeeeekk__mmeessssaaggee((_?_T_e_r_m))
    Examines the thread message-queueand compares thequeued terms with_T_e_r_m until
    one unifies orthe endof thequeue has beenreached. In thefirst casethe callsucceeds
    (possibly instantiating _T_e_r_m.If no termfrom thequeue unifies thiscall fails.


tthhrreeaadd__ssiiggnnaall((_+_T_h_r_e_a_d_I_d_, _:_G_o_a_l))
    Make thread _T_h_r_e_a_d_I_d execute _G_o_a_l at the firstopportunity.  In the current im-
    plementation, this implies at the firstpass through the _C_a_l_l_-_p_o_r_t. The predicate
    thread_signal/2 itself places_G_o_a_l into the signalled-thread'ssignal queue andre-
    turns immediately.

    Signals (interrupts) do notcooperate well with the worldof multi-threading, mainly
    because the statusof mutexescannot beguaranteed easily.At the call-port,the Prolog
    virtual machine holdsno locksand therefore theasynchronous executionis safe.

    _G_o_a_l can be anyvalid Prolog goal, includingthrow/1 to make thereceiving thread
    generate an exceptionand trace/0to start tracingthe receivingthread.


33..3388..22 TThhrreeaadd ssyynncchhrroonniissaattiioonn

All internalProlog operations arethread-safe. This impliestwo Prolog threadscan operate
on the samedynamic predicate without corruptingthe consistency of thepredicate.  This
section dealswith user-level_m_u_t_e_x_e_s (called_m_o_n_i_t_o_r_s inADA or_c_r_i_t_i_c_a_l_-_s_e_c_t_i_o_n_s by
Microsoft). Amutex isa MMUUTTualEEXXclusive device,which impliesat mostone threadcan _h_o_l_d
a mutex.

Mutexesare usedto realiserelated updatesto theProlog database.With `related',we referto
the situationwhere a`transaction' implies twoor morechanges to theProlog database. For
example, wehave apredicate address/2, representingthe addressof aperson and wewant
to changethe address by retractingthe old andasserting the new address. Betweenthese
two operationsthe database is invalid: this personhas either noaddress or two addresses
(depending onthe assert/retractorder).

Here ishow torealise a correctupdate:

:- initialization
        mutex_create(addressbook).

change_address(Id, Address) :-
        mutex_lock(addressbook),
        retractall(address(Id, _)),
        asserta(address(Id, Address)),
        mutex_unlock(addressbook).


mmuutteexx__ccrreeaattee((_?_M_u_t_e_x_I_d))
    Create a mutex. if_M_u_t_e_x_I_d is anatom, a_n_a_m_e_d mutex iscreated. If it isa variable,
    an anonymous mutexreference isreturned. Thereis no limitto thenumber ofmutexes
    that can becreated.


mmuutteexx__ddeessttrrooyy((_+_M_u_t_e_x_I_d))
    Destroy a mutex.After thiscall, _M_u_t_e_x_I_d becomesinvalid andfurther referencesyield
    an existence_errorexception.


mmuutteexx__lloocckk((_+_M_u_t_e_x_I_d))
    Lock the mutex.Prolog mutexesare _r_e_c_u_r_s_i_v_e mutexes:they canbe locked multiple
    times by the samethread. Only after unlockingit as many timesas it islocked, the
    mutex becomes availablefor lockingby otherthreads. If anotherthread haslocked the
    mutex the callingthread issuspended until tomutex isunlocked.

    If _M_u_t_e_x_I_d is anatom, and thereis no current mutexwith that name,the mutex is
    created automatically usingmutex_create/1. This implies namedmutexes need not
    be declared explicitly.

    Please note thatlocking and unlockingmutexes should bepaired carefully. Especially
    make sure to unlockmutexes even if the protectedcode fails or raisesan exception.
    For most common cases usewith_mutex/2, wich provides asafer way for handling
    prolog-level mutexes.


mmuutteexx__ttrryylloocckk((_+_M_u_t_e_x_I_d))
    As mutex_lock/1, but ifthe mutex is held byanother thread, this predicates fails
    immediately.


mmuutteexx__uunnlloocckk((_+_M_u_t_e_x_I_d))
    Unlock the mutex. Thiscan only becalled if themutex is heldby the callingthread.
    If this isnot thecase, a permission_errorexceptionis raised.


mmuutteexx__uunnlloocckk__aallll
    Unlock all mutexesheld by thecurrent thread. Thiscall is especiallyuseful tohandle
    thread-termination using abort/0or exceptions. Seealso thread_signal/2.


ccuurrrreenntt__mmuutteexx((_?_M_u_t_e_x_I_d_, _?_T_h_r_e_a_d_I_d_, _?_C_o_u_n_t))
    Enumerates all existing mutexes. If themutex is held bysome thread, _T_h_r_e_a_d_I_d is
    unified with theidentifier of teholding thread and_C_o_u_n_t with therecursive count of
    the mutex. Otherwise,_T_h_r_e_a_d_I_d is []and _C_o_u_n_tis 0.


wwiitthh__mmuutteexx((_+_M_u_t_e_x_I_d_, _:_G_o_a_l))
    Execute _G_o_a_lwhile holding_M_u_t_e_x_I_d. If _G_o_a_lleaves choicepointes,these aredestroyed
    (as in once/1). The mutexis unlocked regardlessof whether _G_o_a_lsucceeds, fails or
    raises an exception. An exception thrownby _G_o_a_l is re-thrownafter the mutex has
    been successfully unlocked.See also mutex_create/2.

    Although described inthe thread-section, thispredicate is alsoavailable inthe single-
    threaded version, whereit behavessimply as once/1.


33..3388..33 TThhrreeaadd--ssuuppppoorrtt lliibbrraarryy((tthhrreeaadduuttiill))

This library definesa couple of useful predicatesfor demonstrating and debugging multi-
threaded applications.This library iscertainly notcomplete.


tthhrreeaaddss
    Lists all current threadsand their status. In addition, all `zombie'threads (finished
    threads that arenot detached,nor waited for)are joinedto reclaim theirresources.


iinntteerraaccttoorr
    Create a new console and run the Prolog toplevel in this new console.  See also
    attach_console/0.


aattttaacchh__ccoonnssoollee
    If the current thread has noconsole attached yet, attach one andredirect the user
    streams (input,output, anderror) tothe new consolewindow. Theconsole isan xterm
    application. For thisto work,you shouldbe runningX-windows andyour xtermshould
    know the -Sccn.

    This predicate hasa coupleof useful applications. Oneis toseparate (debugging) I/O
    of different threads.  Anotheris to start debugging a threadthat is running in the
    background.  Ifthread 10 is running,the following sequencestarts the tracer onthis
    thread:

    ?- thread_signal(10, (attach_console, trace)).


33..3388..44 SSttaattuuss ooff tthhee tthhrreeaadd iimmpplleemmeennttaattiioonn

It is assumedthat the basic Prolog executionis thread-safe.  Variousproblems are to be
expected though,both dead-locksas well asnot-thread-safe codein builtin-predicates.


33..3399 UUsseerr TToopplleevveell MMaanniippuullaattiioonn


bbrreeaakk
    Recursively start anew Prologtop level. This Prologtop levelhas its ownstacks, but
    shares theheap withall breakenvironments andthe toplevel. Debuggingis switchedoff
    on entering abreak andrestored on leavingone. Thebreak environment isterminated
    by typing thesystem's end-of-filecharacter(control-D). Ifthe -t toplevelcommand
    line option is giventhis goal isstarted instead of enteringthe default interactivetop
    level (prolog/0).


aabboorrtt
    Abort the Prologexecution and starta new toplevel. If the-t toplevel command
    line options isgiven this goalis started insteadof entering thedefault interactive top
    level.  Breakenvironments are abortedas well. All open filesexcept for theterminal
    related files areclosed. The input-and outputstream again refersto _u_s_e_r.

    In the single-threadedversion abort/0is implemented usinga C-longjmp()call, after
    which the Prolog stacksare emptied, relevantreference-counts and someother global
    data is reset, after which the system isrestarted.  This approach allows Prolog to
    recover frominternal consistencyproblems suchas garbage-collectionerrors. Themulti-
    threaded version implements abort/0 by generationan exception $aborted.  This
    approach is less secureif the systemis in an unhealthystate, but required toensure
    consistency of theother threadsas well asmutexes.


hhaalltt
    Terminate Prologexecution. Open filesare closedand ifthe commandline option-tty
    is notactive theterminal status (seeUnix stty(1))is restored.Hooks maybe registered
    both in Prolog and in foreign code. Prolog hooks are registeredusing at_halt/1.
    halt/0 is equivalentto halt(0).


hhaalltt((_+_S_t_a_t_u_s))
    Terminate Prolog executionwith givenstatus. Status isan integer. Seealso halt/0.


pprroolloogg
    This goal starts the defaultinteractive top level. Queries are read from thestream
    user_input.  See also the history prolog_flag (current_prolog_flag/2).  The
    prolog/0 predicate is terminated(succeeds) by typing theend-of-file character (On
    most systems control-D).

Thefollowing twohooks allowfor expandingqueries andhandling theresult ofaquery. These
hooks areused bythe toplevel variableexpansion mechanismdescribed in section2.8.


eexxppaanndd__qquueerryy((_+_Q_u_e_r_y_, _-_E_x_p_a_n_d_e_d_, _+_B_i_n_d_i_n_g_s_, _-_E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s))
    Hook inmodule user,normally notdefined. _Q_u_e_r_yand _B_i_n_d_i_n_g_srepresents thequery
    read from theuser andthe namesof thefree variablesas obtainedusing read_term/3.
    If this predicate succeeds, itshould bind _E_x_p_a_n_d_e_d and_E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s to the
    query and bindings to be executed by thetoplevel.  This predicate is used bythe
    toplevel (prolog/0). Seealso expand_answer/2and term_expansion/2.


eexxppaanndd__aannsswweerr((_+_B_i_n_d_i_n_g_s_, _-_E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s))
    Hook in moduleuser, normally notdefined. Expand the resultof a successfullyexe-
    cuted toplevel query. _B_i_n_d_i_n_g_sis the query<_N_a_m_e>= <_V_a_l_u_e>binding listfrom the
    query. _E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s mustbe unifiedwith thebindings thetoplevelshould print.


33..4400 CCrreeaattiinngg aa PPrroottooccooll ooff tthhee UUsseerr IInntteerraaccttiioonn

SWI-Prolog offersthe possibility to logthe interaction with theuser on a file. All Prolog
interaction, includingwarnings andtracer output, arewritten onthe protocol file.


pprroottooccooll((_+_F_i_l_e))
    Start protocollingon file_F_i_l_e. If thereis alreadya protocolfile openthen closeit first.
    If _F_i_l_e existsit istruncated.


pprroottooccoollaa((_+_F_i_l_e))
    Equivalent to protocol/1,but doesnot truncate the_F_i_l_e ifit exists.


nnoopprroottooccooll
    Stop making aprotocol ofthe user interaction.Pending output isflushed onthe file.


pprroottooccoolllliinngg((_-_F_i_l_e))
    Succeeds ifa protocolwas startedwith protocol/1or protocola/1 andunifies _F_i_l_e
    with the currentprotocol outputfile.


33..4411 DDeebbuuggggiinngg aanndd TTrraacciinngg PPrrooggrraammss


ttrraaccee
    Start the tracer. trace/0 itself cannotbe seen in thetracer.  Notethat the Prolog
    toplevel treats trace/0special; itmeans `trace thenext goal'.


ttrraacciinngg
    Succeeds when thetracer is currentlyswitched on. tracing/0 itself cannot be seen
    in the tracer.


nnoottrraaccee
    Stop the tracer.notrace/0 itself cannotbe seenin the tracer.


ttrraaccee((_+_P_r_e_d))
    Equivalent to trace(Pred, +all).


ttrraaccee((_+_P_r_e_d_, _+_P_o_r_t_s))
    Put a trace-pointon all predicatessatisfying the predicatespecification _P_r_e_d. _P_o_r_t_s
    is a listof portnames (call,redo, exit,fail). The atom allrefers toall ports. If
    the port ispreceded bya -sign the trace-pointis clearedfor theport. If itis preceded
    by a +the trace-pointis set.

    The predicate trace/2activates debugmode (seedebug/0). Each timea port(of the
    4-port model) ispassed thathas atrace-point set thegoal isprinted aswith trace/0.
    Unlike trace/0 however,the execution is continuedwithout asking forfurther infor-
    mation. Examples:

        ?- trace(hello).         Trace allports of hellowith anyarity in any
                                 module.
        ?- trace(foo/2, +fail).  Trace failuresof foo/2in any module.
        ?- trace(bar/1, -all).   Stop tracingbar/1.

    The predicate debugging/0shows allcurrently defined trace-points.


nnoottrraaccee((_+_G_o_a_l))
    Call _G_o_a_l, butsuspend thedebugger while _G_o_a_lis executing. Thecurrent implemen-
    tation cuts the choicepointsof _G_o_a_l after successfulcompletion. See once/1. Later
    implementations may havethe samesemantics as call/1.


ddeebbuugg
    Start debugger (stopat spypoints).


nnooddeebbuugg
    Stop debugger (donot trace,nor stop atspy points).


ddeebbuuggggiinngg
    Print debug statusand spypoints on currentoutput stream.


ssppyy((_+_P_r_e_d))
    Put a spy pointon all predicates meetingthe predicate specification _P_r_e_d. See sec-
    tion 3.4.


nnoossppyy((_+_P_r_e_d))
    Remove spy pointfrom allpredicates meeting thepredicate specification_P_r_e_d.


nnoossppyyaallll
    Remove all spypoints fromthe entire program.


lleeaasshh((_?_P_o_r_t_s))
    Set/query leashing (ports whichallow for user interaction). _P_o_r_t_s is oneof _+_N_a_m_e,
    _-_N_a_m_e, _?_N_a_m_e ora list ofthese. _+_N_a_m_e enablesleashing on thatport, _-_N_a_m_e disables
    it and _?_N_a_m_esucceeds or failsaccording to thecurrent setting. Recognised portsare:
    call, redo, exit, fail andunify. The special shorthand allrefers to all ports,
    full refers to allports except forthe unify port(default). half refers to thecall,
    redo and failport.


vviissiibbllee((_+_P_o_r_t_s))
    Set the portsshown bythe debugger. Seeleash/1 for adescription ofthe portspeci-
    fication. Default isfull.


uunnkknnoowwnn((_-_O_l_d_, _+_N_e_w))
    Unify _O_l_d withthe current valueof theunknown system flag. Onsuccess _N_e_wwill be
    used to specifythe newvalue. _N_e_wshould be instantiatedto eitherfail ortrace and
    determines the interpreters actionwhen an undefinedpredicate which isnot declared
    dynamic is encountered(see dynamic/1).fail impliesthe predicate justfails silently.
    trace implies the traceris started. Default is trace. The unknownflag is local to
    each moduleand unknown/2is moduletransparent. Using itas adirective ina module
    file will only changethe unknown flag forthat module.  Usingthe :/2 construct the
    behaviour on trapping anundefined predicate can bechanged for anymodule.  Note
    that ifthe unknownflag foramodule equalsfail thesystem willnot callexception/3
    and will nnootttry to resolvethe predicate viathe dynamic librarysystem. The system
    will still tryto importthe predicate fromthe publicmodule.


ssttyyllee__cchheecckk((_+_S_p_e_c))
    Set style checking options.  _S_p_e_cis either +<_o_p_t_i_o_n>, -<_o_p_t_i_o_n>, ?<_o_p_t_i_o_n>or a
    list of such options. +<_o_p_t_i_o_n>setsa style checkingoption, -<_o_p_t_i_o_n>clears it and
    ?<_o_p_t_i_o_n>succeeds orfailsaccording tothe currentsetting. consult/1and derivatives
    resets thestyle checkingoptions totheirvalue beforeloading thefile. If_forexample_a
    file containing longatoms shouldbe loaded theuser canstart the filewith:

    :- style_check(-atom).

    Currently available optionsare:

     __________________________________________________________________
     |_Name__________|DefaultD|escription______________________________||singletonon|  ||

     |                       read_clause/1(used byconsult/1) warnsonvari-|             ||
     |                       ables only appearingonce in a term(clause)|which          ||
     ||atom          | on   |have aname notstarting with anunderscore. ||              ||

     |               |      |read/1and derivativeswill producean errormessage|
     |               |      |on quotedatoms orstrings longer than5 lines.|

     | dollar        | off   |Accept dollaras alower casecharacter, thusavoiding|
     |               |       |the needfor quotingatoms withdollar signs.|System
     |               |       |maintenance useonly.                     |
     | discontiguous | on   |Warn ifthe clauses for apredicate are nottogether|
     |               |      |in thesame sourcefile.                    |
     | string        | off   |Backward compatibility.  See the prolog-flag|dou-
     |_______________|_______|ble_quotes(current_prolog_flag/2)._______|


33..4422 OObbttaaiinniinngg RRuunnttiimmee SSttaattiissttiiccss


ssttaattiissttiiccss((_+_K_e_y_, _-_V_a_l_u_e))
    Unify system statisticsdetermined by_K_e_y with _V_a_l_u_e.The possible keysare givenin
    the table 3.2.
   __________________________________________________________________
   | agc             |Number of atom garbage-collections performed  |
   | agc_gained      |Number of atoms removed                       |
   | agc_time        |Time spent in atom garbage-collections        |
   | cputime         |(User) cpu  time since  Prolog was  started in|
   |                 |seconds                                       |
   | inferences      |Total number of  passes via the  call and redo|
   |                 |ports since Prolog was started.               |

   | heap            |Estimated  total   size   of  the   heap  (see|
   |                 |section 2.16.1.1)                             |
   | heapused        |Bytes heap in use by Prolog.                  |
   | heaplimit       |Maximum   size   of   the   heap   (see   sec-|
   |                 |tion 2.16.1.1)                                |
   | local           |Allocated size of the local stack in bytes.   |
   | localused       |Number of bytes in use on the local stack.    |

   | locallimit      |Size to  which the  local stack  is allowed to|
   |                 |grow                                          |
   | global          |Allocated size of the global stack in bytes.  |
   | globalused      |Number of bytes in use on the global stack.   |
   | globallimit     |Size to which  the global stack  is allowed to|
   |                 |grow                                          |
   | trail           |Allocated size of the trail stack in bytes.   |
   | trailused       |Number of bytes in use on the trail stack.    |

   | traillimit      |Size to  which the  trail stack  is allowed to|
   |                 |grow                                          |
   | atoms           |Total number of defined atoms.                |
   | functors        |Total number of defined name/arity pairs.     |
   | predicates      |Total number of predicate definitions.        |
   | modules         |Total number of module definitions.           |
   | codes           |Total amount of byte codes in all clauses.    |

   | threads         |MT-version:  number of active threads         |
   | threads_created |MT-version:  number of created threads        |
   | threads_cputime |MT-version:  seconds CPU time used by finished|
   |_________________|threads_______________________________________|_

                   Table 3.2:  Keys for statistics/2


ssttaattiissttiiccss
    Display a tableof systemstatistics on thecurrent outputstream.


ttiimmee((_+_G_o_a_l))
    Execute _G_o_a_l just like once/1 (i.e.leaving no choice points), but printused time,
    number of logical inferences andthe average number of_l_i_p_s (logical inferences per
    second). Note thatSWI-Prolog countsthe actual executednumber ofinferences rather
    than the number ofpasses through the call-and redo ports ofthe theoretical 4-port
    model.


33..4433 FFiinnddiinngg PPeerrffoorrmmaannccee BBoottttlleenneecckkss

SWI-Prolog offersa statisticalprogram profilersimilar to Unixprof(1) forC andsome other
languages. A profiler is usedas an aid tofind performance pigs inprograms.  Itprovides
information onthe timespent in thevarious Prologpredicates.

The profileris based on theassumption that if wemonitor the functionson the execution
stack ontime intervalsnot correlatedto theprogram's executionthe numberof timeswe find
a procedureon the environmentstack is a measureof the timespent in thisprocedure.  It
is implementedby callinga procedure eachtime sliceProlog is active.This procedure scans
the localstack andeither justcounts the procedureon topof this stack(plain profiling)or
all procedureson the stack(cumulative profiling). Toget accurate resultseach procedure
one isinterested inshould have areasonable number ofcounts. Typically aminute runtime
will sufficeto geta rough overviewof themost expensive procedures.


pprrooffiillee((_+_G_o_a_l_, _+_S_t_y_l_e_, _+_N_u_m_b_e_r))
    Execute _G_o_a_l just like time/1.  Collect profiling statistics accordingto style (see
    profiler/2) and showthe top_N_u_m_b_e_r procedures onthe currentoutput stream (see
    show_profile/1). The resultsare kept inthe database untilreset_profiler/0 or
    profile/3 is called andcan be displayedagain with show_profile/1. profile/3
    is the normalway toinvoke the profiler. Thepredicates beloware low-level predicates
    that can beused forspecial cases.


sshhooww__pprrooffiillee((_+_N_u_m_b_e_r))
    Show the collectedresults of theprofiler. Stops the profiler firstto avoid interference
    from show_profile/1. Itshows the top_N_u_m_b_e_r predicates accordingthe percentage
    cpu-time used.


pprrooffiilleerr((_-_O_l_d_, _+_N_e_w))
    Query or changethe status ofthe profiler. Thestatus is oneof off, plainor cumu-
    lative.  plainimplies the timeused by children ofa predicate isnot added to the
    time of thepredicate. Forstatus cumulative thetime ofchildren isadded (exceptfor
    recursive calls). Cumulativeprofiling impliesthe stackis scannedup tothe topon each
    time sliceto findall activepredicates. This impliestheoverhead growswith thenumber
    of active frames onthe stack. Cumulative profilingstarts debugging mode todisable
    tail recursion optimisation, whichwould otherwise remove thenecessary parent envi-
    ronments. Switching status fromplain tocumulative resets theprofiler. Switching
    to and fromstatus offdoes notreset the collectedstatistics, thusallowing tosuspend
    profiling for certainparts ofthe program.


rreesseett__pprrooffiilleerr
    Switches the profilerto offand clears allcollected statistics.


pprrooffiillee__ccoouunntt((_+_H_e_a_d_, _-_C_a_l_l_s_, _-_P_r_o_m_i_l_a_g_e))
    Obtain profile statisticsof the predicatespecified by_H_e_a_d. _H_e_a_d is anatom for pred-
    icates with arity0 or a termwith the samename and arityas the predicaterequired
    (see current_predicate/2). _C_a_l_l_sis unified withthe number of`calls' and `redos'
    while the profilerwas active. _P_r_o_m_i_l_a_g_eis unifiedwith the relativenumber ofcounts
    the predicate wasactive (cumulative)or on topof thestack (plain). _P_r_o_m_i_l_a_g_eis
    an integer between0 and1000.


33..4444 MMeemmoorryy MMaannaaggeemmeenntt

Note: limit_stack/2 andtrim_stacks/0 have noeffect on machines that donot offer
dynamic stack expansion. On these machinesthese predicates simply succeedto improve
portability.


ggaarrbbaaggee__ccoolllleecctt
    Invoke the global-and trail stackgarbage collector. Normally thegarbage collector is
    invoked automatically if necessary. Explicitinvocation might be usefulto reduce the
    need for garbage collectionsin time critical segmentsof the code. After thegarbage
    collection trim_stacks/0is invoked torelease thecollected memoryresources.


ggaarrbbaaggee__ccoolllleecctt__aattoommss
    Reclaim unused atoms.Normally invokedafter agc_margin(a prologflag) atomshave
    been created.


lliimmiitt__ssttaacckk((_+_K_e_y_, _+_K_b_y_t_e_s))
    Limit one of thestack areas to thespecified value. _K_e_y is oneof local, global or
    trail.  Thelimit is aninteger, expressing the desiredstack limit in Kbytes. If the
    desired limitis smallerthan thecurrently usedvalue, thelimit isset tothe nearestlegal
    value above thecurrently usedvalue. If thedesired value islarger thanthe maximum,
    the maximum istaken. Finally, ifthe desiredvalue iseither 0 orthe atomunlimited
    the limit isset to itsmaximum. The maximum andinitial limit isdetermined by the
    command line options-L, -Gand -T.


ttrriimm__ssttaacckkss
    Release stack memoryresources thatare not inuse atthis moment,returning them to
    the operating system. Trim stackis a relativelycheap call. It can beused to release
    memory resourcesin a backtrackingloop, wherethe iterationsrequire typicallyseconds
    of execution timeand very different,potentially large,amounts of stackspace. Such a
    loop should bewritten asfollows:

    loop :-
            generator,
                trim_stacks,
                potentially_expensive_operation,
            stop_condition, !.

    The prolog toplevel loop iswritten thisway, reclaiming memoryresources afterevery
    user query.


ssttaacckk__ppaarraammeetteerr((_+_S_t_a_c_k_, _+_K_e_y_, _-_O_l_d_, _+_N_e_w))
    Query/set a parameterfor theruntime stacks. _S_t_a_c_kis oneof local,global, trail
    or argument. Thetable belowdescribes the_K_e_y/_V_a_l_u_e pairs. Oldis firstunified with
    the current value.

             __________________________________________________
             | limit    |Maximum sizeof thestack inbytes            |
             |_min_free_|Minimum_freespace_atentry_offoreign_predicate_|

    This predicateis currentlyonly availableon versionsthatuse thestack-shifter toenlarge
    the runtime stackswhen necessary. It'sdefinition issubject to change.


33..4455 WWiinnddoowwss DDDDEE iinntteerrffaaccee

The predicates inthis section deal with MS-Windows`Dynamic Data Exchange' or DDE
protocol. A WindowsDDE conversation isa form of interprocesscommunication based on
sending reservedwindow-events betweenthe communicating processes.

See alsosection 5.4for loading WindowsDLL's intoSWI-Prolog.


33..4455..11 DDDDEE cclliieenntt iinntteerrffaaccee

TheDDE clientinterface allowsProlog totalk toDDE serverprograms. We willdemonstrate
theuse ofthe DDEinterface usingthe WindowsPROGMAN(Program Manager)application:

1 ?- open_dde_conversation(progman, progman, C).

C = 0
2 ?- dde_request(0, groups, X)

--> Unifies X with description of groups

3 ?- dde_execute(0, '[CreateGroup("DDE Demo")]').

Yes

4 ?- close_dde_conversation(0).

Yes

For details oninteracting with progman, usethe SDK online manualsection on the Shell
DDE interface.See also theProlog library(progman),which maybe used towrite simple
Windows setupscripts inProlog.


ooppeenn__ddddee__ccoonnvveerrssaattiioonn((_+_S_e_r_v_i_c_e_, _+_T_o_p_i_c_, _-_H_a_n_d_l_e))
    Open aconversation witha serversupporting thegiven servicename andtopic (atoms).
    If successful,_H_a_n_d_l_e maybe usedto sendtransactions tothe server.If nowilling server
    is found thispredicate failssilently.


cclloossee__ddddee__ccoonnvveerrssaattiioonn((_+_H_a_n_d_l_e))
    Close the conversation associated with_H_a_n_d_l_e.  Allopened conversations should be
    closed when they'reno longer needed,although the systemwill close anythat remain
    open on processtermination.


ddddee__rreeqquueesstt((_+_H_a_n_d_l_e_, _+_I_t_e_m_, _-_V_a_l_u_e))
    Request a value fromthe server. _I_t_e_m isan atom that identifiesthe requested data,
    and _V_a_l_u_e will bea string (CF_TEXT data in DDEparlance) representing that data,
    if the requestis successful. If unsuccessful,_V_a_l_u_e will beunified with aterm of form
    error(<_R_e_a_s_o_n>), identifyingthe problem. This calluses SWI-Prolog stringobjects
    to return the value rather then atoms to reducethe load on the atom-space.  See
    section 3.23 fora discussionon this datatype.


ddddee__eexxeeccuuttee((_+_H_a_n_d_l_e_, _+_C_o_m_m_a_n_d))
    Request theDDE serverto executethegiven command-string. Succeedsifthe command
    could be executedand failswith error messageotherwise.


ddddee__ppookkee((_+_H_a_n_d_l_e_, _+_I_t_e_m_, _+_C_o_m_m_a_n_d))
    Issue aPOKE commandto theserver onthe specified_I_t_e_m. Command ispassed asdata
    of type CF_TEXT.


33..4455..22 DDDDEE sseerrvveerr mmooddee

The (autoload)library(dde) defines primitivesto realise simpleDDE server applications
in SWI-Prolog.These featuresare providedas ofversion 2.0.6 andshould beregarded proto-
types. TheC-part ofthe DDEserver canhandle somemoreprimitives, soif youneed features
not providedby thisinterface, please studylibrary(dde).


ddddee__rreeggiisstteerr__sseerrvviiccee((_+_T_e_m_p_l_a_t_e_, _+_G_o_a_l))
    Register a serverto handle DDErequest orDDE execute requestsfrom otherapplica-
    tions. To registera service fora DDErequest, _T_e_m_p_l_a_t_e isof theform:

         +Service(+Topic,+Item, +Value)

    _S_e_r_v_i_c_e is thename ofthe DDEservice provided (likeprogman inthe clientexample
    above). _T_o_p_i_c is eitheran atom, indicating_G_o_a_l only handlesrequests on thistopic
    or avariable that alsoappears in_G_o_a_l. _I_t_e_mand _V_a_l_u_eare variablesthat also appear
    in _G_o_a_l.

    The example belowregisters the Prologcurrent_prolog_flag/2predicate to beac-
    cessible from other applications. Therequest may be givenfrom the same Prologas
    well as fromanother application.

    ?- dde_register_service(prolog(current_prolog_flag, F, V),
                            current_prolog_flag(F, V)).

    ?- open_dde_conversation(prolog, current_prolog_flag, Handle),
       dde_request(Handle, home, Home),
       close_dde_conversation(Handle).

    Home = '/usr/local/lib/pl-2.0.6/'

    Handling DDE execute requestsis very similar. In this casethe template isof the
    form:

         +Service(+Topic,+Item)

    Passing a _V_a_l_u_eargument is notneeded as executerequests either succeedor fail. If
    _G_o_a_l fails, a`not processed'is passed backto thecaller of theDDE request.


ddddee__uunnrreeggiisstteerr__sseerrvviiccee((_+_S_e_r_v_i_c_e))
    Stop responding to_S_e_r_v_i_c_e. If Prolog ishalted, it willautomatically call thison all
    open services.


ddddee__ccuurrrreenntt__sseerrvviiccee((_-_S_e_r_v_i_c_e_, _-_T_o_p_i_c))
    Find currently registeredservices andthe topics servedon them.


ddddee__ccuurrrreenntt__ccoonnnneeccttiioonn((_-_S_e_r_v_i_c_e_, _-_T_o_p_i_c))
    Find currently openconversations.


33..4466 MMiisscceellllaanneeoouuss


ddwwiimm__mmaattcchh((_+_A_t_o_m_1_, _+_A_t_o_m_2))
    Succeeds if _A_t_o_m_1matches _A_t_o_m_2in `DoWhat IMean' sense. Both_A_t_o_m_1 and_A_t_o_m_2
    may also beintegers orfloats. The twoatoms match if:

      o  Theyare identical

      o  Theydiffer by onecharacter (spy spu)

      o  Onecharacter is inserted/deleted(debug deug)

      o  Twocharacters are transposed(trace tarce)

      o  `Sub-words'are glued differently(existsfile existsFile  exists_file)

      o  Twoadjacent sub wordsare transposed(existsFile  fileExists)


ddwwiimm__mmaattcchh((_+_A_t_o_m_1_, _+_A_t_o_m_2_, _-_D_i_f_f_e_r_e_n_c_e))
    Equivalent to dwim_match/2,but unifies _D_i_f_f_e_r_e_n_c_e with anatom identifying the
    the difference between_A_t_o_m_1 and_A_t_o_m_2. The return valuesare (inthe same orderas
    above): equal, mismatched_char,inserted_char, transposed_char, separated
    and transposed_word.


wwiillddccaarrdd__mmaattcchh((_+_P_a_t_t_e_r_n_, _+_S_t_r_i_n_g))
    Succeeds if _S_t_r_i_n_g matchesthe wildcard pattern_P_a_t_t_e_r_n. _P_a_t_t_e_r_n is very similar
    the the Unixcsh patternmatcher. The patternsare given below:

     ?      Matches one arbitrarycharacter.
     *      Matches any numberof arbitrarycharacters.
     [...]  Matches one ofthe charactersspecified between thebrackets. <_c_h_a_r_1>-<_c_h_a_r_2>indicates arange.
     {...}  Matches any ofthe patternsof the commaseparated listbetween the braces.

    Example:

    ?- wildcard_match('[a-z]*.{pro,pl}[%~]', 'a_hello.pl%').

    Yes


ggeennssyymm((_+_B_a_s_e_, _-_U_n_i_q_u_e))
    Generate a uniqueatom frombase _B_a_s_eand unifyit with _U_n_i_q_u_e._B_a_s_e should bean
    atom.  Thefirst call willreturn <_b_a_s_e>1, the next<_b_a_s_e>2,etc.  Notethat this isno
    warrant that theatom isunique in thesystem.


sslleeeepp((_+_T_i_m_e))
    Suspend execution _T_i_m_eseconds. _T_i_m_e iseither afloating pointnumber or aninteger.
    Granularity is dependent on thesystem's timer granularity. A negative time causes
    the timer toreturn immediately. Onmost non-realtimeoperating systemswe can only
    ensure execution issuspended foraatt lleeaasstt _T_i_m_e seconds.


CChhaapptteerr 44..  UUSSIINNGG MMOODDUULLEESS


44..11 WWhhyy UUssiinngg MMoodduulleess??

In traditionalProlog systemsthe predicatespace wasflat. This approachis notvery suitable
for thedevelopment oflarge applications,certainly notif theseapplications aredeveloped by
more thanone programmer.In many cases,the definitionof aProlog predicaterequires sub-
predicatesthat areintended onlyto completethe definitionof themain predicate.With aflat
and globalpredicate spacethese support predicateswill bevisible from theentire program.

For this reason, itis desirable that each source modulehas it's own predicate space. A
module consistsof adeclaration for it'sname, it's _p_u_b_l_i_c _p_r_e_d_i_c_a_t_e_sand the predicates
themselves. Thisapproach allowthe programmerto useshort (local)names forsupport pred-
icates withoutworrying about nameconflicts withthe support predicatesof other modules.
The moduledeclaration alsomakes explicit whichpredicates aremeant forpublic usage and
which forprivate purposes. Finally,using the moduleinformation, cross referenceprograms
can indicatepossible problemsmuch better.


44..22 NNaammee--bbaasseedd vveerrssuuss PPrreeddiiccaattee--bbaasseedd MMoodduulleess

Twoapproaches torealize amodule systemare commonlyusedin Prologand otherlanguages.
The firstone isthe _n_a_m_e _b_a_s_e_dmodule system. Inthese systems,each atom readis tagged
(normallyprefixed) withthe modulename, withthe exceptionof thoseatoms thatare defined
_p_u_b_l_i_c. Inthe second approach,each moduleactually implements itsown predicatespace.

A criticalproblem with usingmodules in Prolog isintroduced by themeta-predicates that
transform betweenProlog dataand Prolog predicates.Consider the casewhere wewrite:

:- module(extend, [add_extension/3]).

add_extension(Extension, Plain, Extended) :-
        maplist(extend_atom(Extension), Plain, Extended).

extend_atom(Extension, Plain, Extended) :-
        concat(Plain, Extension, Extended).

Inthis casewe wouldlike maplistto callextend_atom/3in themoduleextend. A namebased
module systemwill dothis correctly.It willtag theatom extend_atomwith themodule and
maplist will usethis to construct thetagged term extend_atom/3.  Aname based module
however, willnot onlytag theatoms that willeventually beused to referto apredicate, but
aallll atomsthat are notdeclared public. So,with a namebased module systemalso datais
local tothe module. Thisintroduces anotherserious problem:

:- module(action, [action/3]).

action(Object, sleep, Arg) :- ....
action(Object, awake, Arg) :- ....

:- module(process, [awake_process/2]).

awake_process(Process, Arg) :-
        action(Process, awake, Arg).

This code usesa simple object-oriented implementationtechnique were atoms areused as
method selectors. Using aname based module system,this code will notwork, unless we
declare the selectorspublic atoms in allmodules that use them. Predicate based module
systems donot requireparticular precautions forhandling thiscase.

Itappears wehave tochoose eithertohave localdata, orto havetroublewith meta-predicates.
Probably itis bestto choose forthe predicate basedapproach asnovice users willnot often
write genericmeta-predicates that have tobe used across multiplemodules, but arelikely
to writeprograms that passdata aroundacross modules. Experienced Prologprogrammers
should beable todeal with thecomplexities ofmeta-predicates in apredicate basedmodule
system.


44..33 DDeeffiinniinngg aa MMoodduullee

Modules normallyare created by loadinga _m_o_d_u_l_e  _f_i_l_e. A modulefile is afile holding
a module/2directive as itsfirst term. The module/2directive declares thename and the
public (i.e.externally visible)predicates ofthe module. Therest ofthe fileis loaded intothe
module. Belowis an exampleof amodule file, definingreverse/2.

:- module(reverse, [reverse/2]).

reverse(List1, List2) :-
        rev(List1, [], List2).

rev([], List, List).
rev([Head|List1], List2, List3) :-
        rev(List1, [Head|List2], List3).


44..44 IImmppoorrttiinngg PPrreeddiiccaatteess iinnttoo aa MMoodduullee

Asexplained before,in thepredicatebased approachadapted bySWI-Prolog, eachmodulehas
it's ownpredicate space. InSWI-Prolog, a moduleinitially is completelyempty. Predicates
can beadded toa module byloading amodule file asdemonstrated in theprevious section,
using assertor by_i_m_p_o_r_t_i_n_g them fromanother module.

Two mechanisms for importing predicates explicitly  from another module exist.  The
use_module/[1,2]predicates loada module fileand import(part ofthe) public predicates
of thefile. The import/1predicate importsany predicate fromany module.


uussee__mmoodduullee((_+_F_i_l_e))
    Load thefile(s) specified with_F_i_l_e justlike ensure_loaded/1. The filesshould allbe
    module files. Allexported predicatesfrom theloaded filesare importedinto thecontext
    module. The differencebetween this predicateand ensure_loaded/1becomes appar-
    ent if the fileis already loadedinto another module. In thiscase ensure_loaded/1
    does nothing;use_modulewill importall publicpredicates ofthemodule intothe current
    context module.


uussee__mmoodduullee((_+_F_i_l_e_, _+_I_m_p_o_r_t_L_i_s_t))
    Load the filespecified with_F_i_l_e (only onefile isaccepted). _F_i_l_e shouldbe a module
    file.  _I_m_p_o_r_t_L_i_s_t isa list of name/arity pairsspecifying the predicates thatshould
    be imported from theloaded module. If a predicateis specified thatis not exported
    from the loadedmodule a warningwill be printed. Thepredicate will neverthelessbe
    imported to simplifydebugging.


iimmppoorrtt((_+_H_e_a_d))
    Import predicate_H_e_a_d intothe currentcontext module. _H_e_a_dshould specifythe source
    module using the <_m_o_d_u_l_e>:<_t_e_r_m>construct. Notethat predicates are normallyim-
    ported usingone ofthe directivesuse_module/[1,2]. import/1is meantforhandling
    imports into dynamicallycreated modules.

It wouldbe ratherinconvenient to haveto importeach predicate referredto bythe module,
including thesystem predicates. For thisreason each moduleis assigned a_d_e_f_a_u_l_t  _m_o_d_-
_u_l_e. All predicates in thedefault module are availablewithout extra declarations. Their
definition howevercan beoverruled inthe localmodule. Thisschedule isimplemented by the
exception handlingmechanism of SWI-Prolog: ifan undefined predicateexception is raised
for apredicate insome module,the exceptionhandler firsttries toimport thepredicate from
the module'sdefault module. Onsuccess, normalexecution is resumed.


44..44..11 RReesseerrvveedd MMoodduulleess

SWI-Prolog containstwo specialmodules. The firstone isthe modulesystem. This module
contains all built-inpredicates described in this manual. Module system has no default
module assignedto it. The secondspecial module isthe module user. Thismodule forms
theinitial workingspace ofthe user. Initiallyitis empty. Thedefault moduleof moduleuser
is system,making allbuilt-in predicate definitionsavailable as defaults.Built-in predicates
thus canbe overruledby defining themin moduleuser before theyare used.

All othermodules defaultto moduleuser. This impliesthey canuse allpredicates imported
into userwithout explicitlyimporting them.


44..55 UUssiinngg tthhee MMoodduullee SSyysstteemm

Thecurrent structureof themodulesystem hasbeen designedwith somespecificorganisations
for largeprograms inmind. Manylarge programs definea basiclibrary layeron topof which
the actualprogram itself isdefined. The module user,acting asthe default modulefor all
other modulesof the program canbe used to distributethese definitions over allprogram
module withoutintroducing the need toimport this commonlayer each timeexplicitly.  It
can alsobe used toredefine built-in predicatesif this is requiredto maintain compatibility
to someother Prologimplementation. Typically, theloadfile ofa large applicationlooks like
this:

:- use_module(compatibility).   % load XYZ prolog compatibility

:- use_module(                  % load generic parts
        [ error                 % errors and warnings
        , goodies               % general goodies (library extensions)
        , debug                 % application specific debugging
        , virtual_machine       % virtual machine of application
        , ...                   % more generic stuff
        ]).

:- ensure_loaded(
        [ ...                   % the application itself
        ]).

The `use_module' declarations will import thepublic predicates from the genericmodules
into theuser module. The `ensure_loaded' directive loads themodules that constitutethe
actual application. It is assumed these modulesimport predicates from each otherusing
use_module/[1,2]as faras necessary.

In combination withthe object-oriented schema described belowit is possible to definea
neat modulararchitecture. Thegeneric codedefines generalutilities andthe messagepassing
predicates (invoke/3 inthe example below).  Theapplication modules define classes that
communicate usingthe messagepassing predicates.


44..55..11 OObbjjeecctt OOrriieenntteedd PPrrooggrraammmmiinngg

Anothertypical wayto usethe modulesystem isfor definingclasses withinan objectoriented
paradigm. Theclass structureand themethods ofa classcan be definedin amodule andthe
explicit module-boundaryoverruling describes in section4.6.2 can byused by the message
passing codeto invokethe behaviour. Anoutline of thismechanism isgiven below.

%       Define class point

:- module(point, []).           % class point, no exports

%        name           type,           default access
%                                       value

variable(x,             integer,        0,      both).
variable(y,             integer,        0,      both).

%         method name   predicate name  arguments

behaviour(mirror,       mirror,         []).

mirror(P) :-
        fetch(P, x, X),
        fetch(P, y, Y),
        store(P, y, X),
        store(P, x, Y).

The predicatesfetch/3 andstore/3 arepredicates thatchange instancevariables ofinstances.
The figurebelow indicateshow message passingcan easilybe implemented:

%       invoke(+Instance, +Selector, ?ArgumentList)
%       send a message to an instance

invoke(I, S, Args) :-
        class_of_instance(I, Class),
        Class:behaviour(S, P, ArgCheck), !,
        convert_arguments(ArgCheck, Args, ConvArgs),
        Goal =.. [P|ConvArgs],
        Class:Goal.

The construct<_M_o_d_u_l_e>:<_G_o_a_l> explicitly calls _G_o_a_lin module _M_o_d_u_l_e. It isdiscussed in
more detailin section3.8.


44..66 MMeettaa--PPrreeddiiccaatteess iinn MMoodduulleess

Asindicated inthe introduction,the problemwith apredicatebased modulesystem liesin the
difficulty tofind thecorrect predicatefrom aProlog term. Thepredicate `solution(Solution)'
can existin more thanone module, but`assert(solution(4))' insome module issupposed to
refer tothe correctversion of solution/1.

Various approaches arepossible to solve this problem. One is toadd an extra argument
to allpredicates (e.g. `assert(Module, Term)'). Anotheris to tag theterm somehow toin-
dicate whichmodule is desired(e.g. `assert(Module:Term)'). Both approaches arenot very
attractive asthey makethe userresponsible forchoosing thecorrect module,inviting unclear
programming byasserting in othermodules. The predicateassert/1 is supposedto assert
inthe moduleit iscalled fromand shoulddo sowithout beingtold explicitly. Forthis reason,
the notion_c_o_n_t_e_x_t _m_o_d_u_l_e hasbeen introduced.


44..66..11 DDeeffiinniittiioonn aanndd CCoonntteexxtt MMoodduullee

Each predicateof the programis assigneda module, calledit's _d_e_f_i_n_i_t_i_o_n _m_o_d_u_l_e. The
definition moduleof a predicateis always themodule in whichthe predicate wasoriginally
defined. Eachactive goal inthe Prologsystem has a_c_o_n_t_e_x_t _m_o_d_u_l_e assignedto it.

The contextmodule is usedto find predicatesfrom aProlog term. By default,this module
is thedefinition moduleof thepredicate running thegoal. Formeta-predicates however, this
is the contextmodule of the goalthat invoked them. We call this _m_o_d_u_l_e___t_r_a_n_s_p_a_r_e_n_t
in SWI-Prolog. Inthe `using maplist'example above, thepredicate maplist/3 isdeclared
module_transparent. Thisimplies the contextmodule remains extend,the context module
of add_extension/3. This waymaplist/3 candecide tocall extend_atomin moduleextend
rather thanin it'sown definition module.

All built-in predicates that  refer to predicates via a Prolog  term are declared mod-
ule_transparent.Below is thecode definingmaplist.

:- module(maplist, maplist/3).

:- module_transparent maplist/3.

%       maplist(+Goal, +List1, ?List2)
%       True if Goal can successfully be applied to all succes-
sive pairs
%       of elements of List1 and List2.

maplist(_, [], []).
maplist(Goal, [Elem1|Tail1], [Elem2|Tail2]) :-
        apply(Goal, [Elem1, Elem2]),
        maplist(Goal, Tail1, Tail2).


44..66..22 OOvveerrrruulliinngg MMoodduullee BBoouunnddaarriieess

The mechanismabove issufficient tocreate anacceptable modulesystem. Thereare however
cases inwhich wewould liketo beable tooverrule this schemaand explicitlycall apredicate
insome moduleor assertexplicitly insome module. Thefirst isuseful toinvoke goalsin some
module fromthe user's toplevelor to implementa object-oriented system(see above). The
latter isuseful tocreate and modify_d_y_n_a_m_i_c _m_o_d_u_l_e_s (seesection 4.7).

For thispurpose, the reserved term:/2 has been introduced. All built-inpredicates that
transform a term into apredicate reference will check whether this term is ofthe form
`<_M_o_d_u_l_e>:<_T_e_r_m>'. Ifso, the predicateis searchedfor in_M_o_d_u_l_e insteadof thegoal's context
module. The: operator maybe nested,in which casethe inner-mostmodule isused.

The specialcalling construct<_M_o_d_u_l_e>:<_G_o_a_l>pretends _G_o_a_lis called from_M_o_d_u_l_e instead
of thecontext module. Examples:

?- assert(world:done).  % asserts done/0 into module world
?- world:assert(done).  % the same
?- world:done.          % calls done/0 in module world


44..77 DDyynnaammiicc MMoodduulleess

So far, wediscussed modules that were createdby loading a module-file. These modules
have beenintroduced on facilitatethe development of largeapplications. The modules are
fully definedat load-time ofthe applicationand normally willnot change duringexecution.
Having thenotion ofa set ofpredicates asa self-contained worldcan beattractive for other
purposes aswell. Forexample, assumean application thatcan reasonabout multipleworlds.
It isattractive tostore thedata of aparticular worldin amodule, sowe extract information
from aworld simplyby invoking goalsin thisworld.

Dynamicmodules caneasily becreated. Any built-inpredicatethat triesto locatea predicate
in aspecific modulewill create thismodule asa side-effect ifit didnot yetexist. Example:

?- assert(world_a:consistent),
   world_a:unknown(_, fail).

These callscreate a modulecalled `world_a'and make thecall `world_a:consistent'succeed.
Undefined predicateswill notstart thetracer orautoloader forthis module(see unknown/2).

Import andexport fromdynamically createdworld is arrangedvia thepredicates import/1
and export/1:

?- world_b:export(solve(_,_)).          % exports solve/2 from world_b
?- world_c:import(world_b:solve(_,_)).  % and import it to world_c


44..88 MMoodduullee HHaannddlliinngg PPrreeddiiccaatteess

This sectiongives thepredicate definitions forthe remaining built-inpredicates thathandle
modules.


::-- mmoodduullee((_+_M_o_d_u_l_e_, _+_P_u_b_l_i_c_L_i_s_t))
    This directive can onlybe used as thefirst term of asource file. It declares the file
    to be a_m_o_d_u_l_e _f_i_l_e, defining _M_o_d_u_l_eand exporting thepredicates of_P_u_b_l_i_c_L_i_s_t.
    _P_u_b_l_i_c_L_i_s_t is alist ofname/arity pairs.


mmoodduullee__ttrraannssppaarreenntt _+_P_r_e_d_s
    _P_r_e_d_s is a comma separated listof name/arity pairs (like dynamic/1). Each goal
    associated with a transparent declaredpredicate will inherit the_c_o_n_t_e_x_t   _m_o_d_u_l_e
    from its parentgoal.


mmeettaa__pprreeddiiccaattee _+_H_e_a_d_s
    This predicate isdefined in library(quintus)and provides a partialemulation of the
    Quintus predicate. Seesection 4.9.1 fordetails.


ccuurrrreenntt__mmoodduullee((_-_M_o_d_u_l_e))
    Generates all currentlyknown modules.


ccuurrrreenntt__mmoodduullee((_?_M_o_d_u_l_e_, _?_F_i_l_e))
    Is trueif _F_i_l_e isthe filefrom which_M_o_d_u_l_e wasloaded. _F_i_l_eis theinternal canonical
    filename. See alsosource_file/[1,2].


ccoonntteexxtt__mmoodduullee((_-_M_o_d_u_l_e))
    Unify _M_o_d_u_l_e withthe context moduleof thecurrent goal. context_module/1itself
    is transparent.


eexxppoorrtt((_+_H_e_a_d))
    Add apredicate tothe publiclist ofthe context module.This impliesthe predicatewill
    be imported intoanother moduleif thismodule is importedwith use_module/[1,2].
    Note that predicatesare normally exportedusing the directivemodule/2. export/1
    is meant tohandle exportfrom dynamically createdmodules.


eexxppoorrtt__lliisstt((_+_M_o_d_u_l_e_, _?_E_x_p_o_r_t_s))
    Unifies _E_x_p_o_r_t_s with alist of terms. Each termhas the nameand arity of apublic
    predicate of _M_o_d_u_l_e.  Theorder of the terms in _E_x_p_o_r_t_s isnot defined.  See also
    predicate_property/2.


ddeeffaauulltt__mmoodduullee((_+_M_o_d_u_l_e_, _-_D_e_f_a_u_l_t))
    Succesively unifies _D_e_f_a_u_l_t withthe module namesfrom which acall in _M_o_d_u_l_eat-
    tempts touse thedefinition. For themodule user,thiswill generateuser andsystem.
    For any othermodule, thiswill generate themodule itself,followed by userand sys-
    tem.


mmoodduullee((_+_M_o_d_u_l_e))
    The call module(Module)may be usedto switch thedefault workingmodule for the
    interactive toplevel (seeprolog/0). This may be usedto when debugginga module.
    The example belowlists theclauses of file_of_label/2in the moduletex.

    1 ?- module(tex).

    Yes
    tex: 2 ?- listing(file_of_label/2).
    ...


44..99 CCoommppaattiibbiilliittyy ooff tthhee MMoodduullee SSyysstteemm

The principlesbehind the modulesystem of SWI-Prologdiffer in anumber of aspectsfrom
the QuintusProlog modulesystem.

  o The SWI-Prolog modulesystem allowsthe user toredefine systempredicates.

  o All predicatesthat areavailable inthe systemand usermodules arevisible inallother
    modules as well.

  o Quintus  has  the `meta_predicate/1'  declaration were  SWI-Prolog  has the
    module_transparent/1 declaration.

The meta_predicate/1declarationcauses the compilerto tagarguments thatpass module
sensitive information with themodule using the :/2 operator. This approach has some
disadvantages:

  o Changing a meta_predicatedeclaration implies all predicates ccaalllliinnggthe predicate
    need to bereloaded. This cancause seriousconsistency problems.

  o It does nothelp fordynamically defined predicatescalling modulesensitive predicates.

  o It slows downthe compiler(at least inthe SWI-Prologarchitecture).

  o At least within theSWI-Prolog architecture therun-time overhead islarger than the
    overhead introduced bythe transparentmechanism.

Unfortunatelythe transparentpredicate approachalso hassome disadvantages. Ifa predicate
A passesmodule sensitive informationto a predicateB, passing thesame information toa
module sensitivesystem predicateboth A andB should bedeclared transparent. Usingthe
Quintusapproach onlyA needsto betreated special(i.e. declaredwith meta_predicate/1).
Asecond problemarises ifthebody ofa transparentpredicate usesmodulesensitive predicates
for whichit wants torefer toits own module. Supposewe wantto define findall/3using
assert/1 andretract/1. The examplein figure4.1 gives thesolution.
:- module(findall, [findall/3]).

:- dynamic
        solution/1.

:- module_transparent
        findall/3,
        store/2.

findall(Var, Goal, Bag) :-
        assert(findall:solution('$mark')),
        store(Var, Goal),
        collect(Bag).

store(Var, Goal) :-
        Goal,                   % refers to context module of

                                % caller of findall/3
        assert(findall:solution(Var)),
        fail.
store(_, _).

collect(Bag) :-
        ...,

                  Figure 4.1:  findall/3 using modules


44..99..11 EEmmuullaattiinngg meta_predicate/1

The Quintus meta_predicate/1directive can in many cases be replaced by the trans-
parent declaration.  Below is the definition of meta_predicate/1as available from li-
brary(quintus).

:- op(1150, fx, (meta_predicate)).

meta_predicate((Head, More)) :- !,
        meta_predicate1(Head),
        meta_predicate(More).
meta_predicate(Head) :-
        meta_predicate1(Head).

meta_predicate1(Head) :-
        Head =.. [Name|Arguments],
        member(Arg, Arguments),
        module_expansion_argument(Arg), !,
        functor(Head, Name, Arity),
        module_transparent(Name/Arity).
meta_predicate1(_).             % just a mode declaration

module_expansion_argument(:).
module_expansion_argument(N) :- integer(N).

Thediscussion aboveabout theproblems withthe transparentmechanism showthe twocases
in whichthis simpletransformation does notwork.


CChhaapptteerr 55..  FFOORREEIIGGNN LLAANNGGUUAAGGEE IINNTTEERRFFAACCEE

SWI-Prolog offersa powerful interface toC [Kernighan &Ritchie, 1978]. The maindesign
objectivesof theforeign languageinterfaceare flexibilityand performance.A foreignpredicate
is a C-functionthat has the samenumber of arguments as thepredicate represented.  C-
functionsare providedto analysethe passedterms, convertthem tobasicC-types aswell asto
instantiate argumentsusing unification. Non-deterministicforeign predicates aresupported,
providing theforeign functionwith a handleto controlbacktracking.

C cancall Prolog predicates,providing both an queryinterface and aninterface to extract
multiplesolutions froman non-deterministicProlog predicate.There isno limitto thenesting
of Prologcalling C, callingProlog, etc. It is alsopossible to writethe `main' inC and use
Prolog asan embeddedlogical engine.


55..11 OOvveerrvviieeww ooff tthhee IInntteerrffaaccee

A specialinclude filecalled SWI-Prolog.hshould beincluded witheach C-sourcefile thatis
tobe loadedvia theforeign interface. Theinstallation processinstallsthis filein thedirectory
include inthe SWI-Prolog home directory(?- current_prolog_flag(home, Home).).
This C-header file definesvarious data types, macros and functions that canbe used to
communicate with SWI-Prolog. Functions and macros can be dividedinto the following
categories:

  o Analysing Prolog terms

  o Constructing new terms

  o Unifying terms

  o Returning control informationto Prolog

  o Registering foreign predicateswith Prolog

  o Calling Prolog fromC

  o Recorded database interactions

  o Global actions onProlog (halt,break, abort, etc.)


55..22 LLiinnkkiinngg FFoorreeiiggnn MMoodduulleess

Foreign modules maybe linked to Prolog in threeways.  Using _s_t_a_t_i_c  _l_i_n_k_i_n_g, the
extensions, asmall descriptionfile andthe basicSWI-Prolog objectfile arelinked togetherto
forma newexecutable. Using_d_y_n_a_m_i_c _l_i_n_k_i_n_g, theextensions arelinkedto ashared library
(.so fileon most Unixsystems) or dynamic-linklibrary (.DLL fileon Microsoft platforms)
and loadedinto thethe running Prologprocess..


55..22..11 WWhhaatt lliinnkkiinngg iiss pprroovviiddeedd??

The _s_t_a_t_i_c  _l_i_n_k_i_n_g schema can be usedon all versions of SWI-Prolog. Whether or
not dynamiclinking issupported canbe deducedfrom theprolog-flag open_shared_object
(see current_prolog_flag/2). Ifthis prolog-flagyields true,open_shared_object/2and
related predicates aredefined.  See section 5.4for a suitable high-level interface tothese
predicates.


55..22..22 WWhhaatt kkiinndd ooff llooaaddiinngg sshhoouulldd II bbee uussiinngg??

All describedapproaches havetheir advantagesand disadvantages. Staticlinking isportable
and allowsfor debuggingon all platforms. Itis relatively cumbersomeand thelibraries you
need topass tothe linkermay varyfrom system tosystem, thoughthe utilityprogram plld
described insection 5.7often hides theseproblems fromthe user.

Loading shared objects (DLL files on Windows) providessharing and protection and is
generally the best choice.  If a saved-stateis created using qsave_program/[1,2], an
initialization/1 directivemay beused to loadthe appropriatelibrary at startup.

Note thatthe definition ofthe foreign predicatesis the same,regardless of thelinking type
used.


55..33 DDyynnaammiicc LLiinnkkiinngg ooff sshhaarreedd lliibbrraarriieess

The interface definedin this section allows theuser to load shared libraries(.so files on
most Unixsystems, .dll fileson Windows). This interfaceis portable toWindows as well
as toUnix machinesproviding dlopen(2)(Solaris, Linux,FreeBSD, Irixand manymore) or
shl_open(2)(HP/UX). Itis advised touse thepredicates from section5.4 inyour applica-
tion.


ooppeenn__sshhaarreedd__oobbjjeecctt((_+_F_i_l_e_, _-_H_a_n_d_l_e))
    _F_i_l_e  is  the  name of  a  .so  file (see  your  C  programmers documenta-
    tion  on  how to  create  a .so  file).    This file  is  attached to  the cur-
    rent  process  and  _H_a_n_d_l_e  is  unified  with a  handle  to  the  shared  ob-
    ject.  Equivalent to open_shared_object(File, [global], Handle).  See also
    load_foreign_library/[1,2].


ooppeenn__sshhaarreedd__oobbjjeecctt((_+_F_i_l_e_, _+_O_p_t_i_o_n_s_, _-_H_a_n_d_l_e))
    As open_shared_object/2,but allowsfor additional flagsto be passed. _O_p_t_i_o_n_sis
    a list of atoms. now implies the symbolsare resolved immediately rather thanlazy
    (default). global implies symbolsof theloaded object arevisible while loadingother
    shared objects (bydefault theyare local). Notethat these flagsmay notbe supported
    by your operatingsystem. Check thedocumentation ofdlopen() or equivalenton your
    operating system. Unsupportedflags are silentlyignored.


cclloossee__sshhaarreedd__oobbjjeecctt((_+_H_a_n_d_l_e))
    Detach the sharedobject identifiedby _H_a_n_d_l_e.


ccaallll__sshhaarreedd__oobbjjeecctt__ffuunnccttiioonn((_+_H_a_n_d_l_e_, _+_F_u_n_c_t_i_o_n))
    Call the named function in theloaded shared library.  Thefunction is called with-
    out arguments andthe return-value isignored. Normally this functioninstalls foreign
    language predicates usingcalls toPL_register_foreign().


55..44 UUssiinngg tthhee lliibbrraarryy sshhlliibb ffoorr .DLL aanndd .so ffiilleess

Thissection discussesthe functionalityofthe (autoload)library shlib.pl,providingan inter-
faceto sharedlibraries. This librarycan onlybeused ifthe prolog-flagopen_shared_object
is enabled.


llooaadd__ffoorreeiiggnn__lliibbrraarryy((_+_L_i_b_, _+_E_n_t_r_y))
    Search forthe given foreignlibrary andlink itto thecurrent SWI-Prologinstance. The
    library maybe specified withor withoutthe extension.First, absolute_file_name/3
    is used  to locate the file.  If this succeeds, the full path is passed to  the low-
    level function to open thelibrary.  Otherwise, the plainlibrary name is passed, ex-
    ploiting the operating-system defined searchmechanism for the shared library. The
    file_search_path/2 aliasmechanism definesthe alias foreign,which refers tothe
    directories <_p_l_h_o_m_e>/lib/<_a_r_c_h>and <_p_l_h_o_m_e>/lib, in thisorder.

    If thelibrary canbe loaded,the functioncalled _E_n_t_r_ywill becalled withoutarguments.
    The return valueof thefunction is ignored.

    The _E_n_t_r_y functionwill normally callPL_register_foreign() todeclare functions
    in the libraryas foreignpredicates.


llooaadd__ffoorreeiiggnn__lliibbrraarryy((_+_L_i_b))
    Equivalent to load_foreign_library/2. Forthe entry-point,this functionfirst iden-
    tifies the `base-name'of thelibrary, which isdefined tobe the file-namewith pathnor
    extension. It will then trythe entry-point install-<_b_a_s_e>. On failureit will tryto
    function install(). Otherwiseno install functionwill becalled.


uunnllooaadd__ffoorreeiiggnn__lliibbrraarryy((_+_L_i_b))
    If theforeign librarydefines thefunction uninstall_<_b_a_s_e>()or uninstall(),this function
    will be calledwithout arguments andits return valueis ignored. Next, abolish/2is
    used to removeall known foreignpredicates defined inthe library. Finallythe library
    itself is detachedfrom theprocess.


ccuurrrreenntt__ffoorreeiiggnn__lliibbrraarryy((_-_L_i_b_, _-_P_r_e_d_i_c_a_t_e_s))
    Query the currently loaded foreign librariesand their predicates. _P_r_e_d_i_c_a_t_e_s is a
    list with elements ofthe form _M_o_d_u_l_e_:_H_e_a_d,indicating the predicates installedwith
    PL_register_foreign()when the entry-pointof thelibrary was called.

Figure 5.1 connectsa Windows message-box using a foreignfunction.  This example was
tested usingWindows NTand Microsoft VisualC++ 2.0.

#include <windows.h>
#include <SWI-Prolog.h>

static foreign_t
pl_say_hello(term_t to)
{ char *a;

  if ( PL_get_atom_chars(to, &a) )

  { MessageBox(NULL, a, "DLL test", MB_OK|MB_TASKMODAL);

    PL_succeed;
  }

  PL_fail;
}

install_t
install()
{ PL_register_foreign("say_hello", 1, pl_say_hello, 0);
}

            Figure 5.1:  MessageBox() example in Windows NT


55..44..11 SSttaattiicc LLiinnkkiinngg

Below is an  outline of the files  structure required for statically  linking SWI-Prolog
with foreign  extensions.  \ldots/pl  refers to the SWI-Prolog  home directory (see
current_prolog_flag/2). <_a_r_c_h>refers tothe architectureidentifier thatmay beobtained
using current_prolog_flag/2.

        .../pl/runtime/<_a_r_c_h>/libpl.a   SWI-Library
        \ldots/pl/include/SWI-Prolog.h  Includefile
        \ldots/pl/include/SWI-Stream.h  StreamI/O includefile
        \ldots/pl/include/SWI-Exports   Exportdeclarations (AIXonly)
        \ldots/pl/include/stub.c        Extensionstub

The definition of theforeign predicates is the same asfor dynamic linking.  Unlikewith
dynamic linkinghowever, there is noinitialisation function. Instead, the file \ldots/pl/
include/stub.cmay becopied toyourproject andmodified todefine theforeignextensions.
Below isstub.c, modifiedto link thelowercase exampledescribed later inthis chapter:

/*  Copyright (c) 1991 Jan Wielemaker. All rights reserved.
    jan@swi.psy.uva.nl

    Purpose: Skeleton for extensions
*/

#include <stdio.h>
#include <SWI-Prolog.h>

extern foreign_t pl_lowercase(term, term);

PL_extension predicates[] =
{
/*{ "name",      arity,  function,      PL_FA_<flags> },*/

  { "lowercase", 2       pl_lowercase,  0 },
  { NULL,        0,      NULL,          0 }     /* terminating line */
};

int
main(int argc, char **argv)
{ PL_register_extensions(predicates);

  if ( !PL_initialise(argc, argv) )
    PL_halt(1);

  PL_install_readline();                /* delete if not required */

  PL_halt(PL_toplevel() ? 0 : 1);
}

Now, anew executable may becreated by compilingthis file andlinking it tolibpl.a from
the runtimedirectory andthe libraries requiredby both theextensions andthe SWI-Prolog
kernel. Thismay be doneby hand,or using theplld utilitydescribed insecrefplld.


55..55 IInntteerrffaaccee DDaattaa ttyyppeess


55..55..11 TTyyppee term_t::  aa rreeffeerreennccee ttoo aa PPrroolloogg tteerrmm

The principaldata-type is term_t. Type term_tis what Quintuscalls QP_term_ref. This
name indicatesbetter what thetype represents: it is a_h_a_n_d_l_e for aterm rather thanthe
term itself. Terms canonly be representedand manipulated usingthis type, as thisis the
only safeway toensure theProlog kernelis awareof allterms referenced byforeign codeand
thus allowsthe kernelto perform garbage-collectionand/or stack-shiftswhile foreigncode is
active, forexample duringa callback fromC.

A term reference isa C unsigned long, representing the offset ofa variable on the Pro-
log environment-stack.  A foreign function is passed term references for the predicate-
arguments, one for each argument.   If references for intermediate results are needed,
such references  may be created  using PL_new_term_ref()or  PL_new_term_refs().
These references normally  live till the foreign function  returns control back to Pro-
log.   Their  scope can be  explicitly limited  using PL_open_foreign_frame() and
PL_close_foreign_frame()/PL_discard_foreign_frame().

A term_t always refers toa valid Prolog term(variable, atom, integer, float orcompound
term).  A termlives either until backtracking takes us back to apoint before the term
was created, thegarbage collector has collected theterm or the termwas created after a
PL_open_foreign_frame()andPL_discard_foreign_frame()has beencalled.

The foreign-interfacefunctions can either_r_e_a_d, _u_n_i_f_yor _w_r_i_t_e toterm-references. In the
this documentwe usethe following notationfor argumentsof type term_t:

     term_t +t  Accessed in read-mode. The`+' indicates theargu-
                ment is`input'.
     term_t -t  Accessed inwrite-mode.
     term_t ?t  Accessed inunify-mode.

Term referencesare obtainedin any ofthe followingways.

  o _P_a_s_s_e_d _a_s _a_r_g_u_m_e_n_t
    The C-functions implementingforeign predicates arepassed their arguments asterm-
    references. These references maybe read orunified. Writing tothese variables causes
    undefined behaviour.

  o _C_r_e_a_t_e_d _b_y PL_new_term_ref()
    A term created by PL_new_term_ref()is normallyused to build temporary terms
    or be writtenby one of theinterface functions. For example,PL_get_arg()writes a
    reference to theterm-argument inits last argument.

  o _C_r_e_a_t_e_d _b_y PL_new_term_refs(_i_n_t _n)
    This  function  returns a  set of  term refs  with the  same  characteristics as
    PL_new_term_ref().See PL_open_query().

  o _C_r_e_a_t_e_d _b_y PL_copy_term_ref(_t_e_r_m___t _t)
    Creates a new term-referenceto the same term asthe argument. The term may be
    written to. Seefigure 5.3.

Term-references cansafely be copiedto other C-variablesof type term_t, but allcopies will
always referto thesame term.


term_t PPLL__nneeww__tteerrmm__rreeff()
    Return a fresh reference toa term.  The referenceis allocated on the _l_o_c_a_lstack.
    Allocating aterm-reference maytriggera stack-shifton machinesthatcannot usesparse-
    memory managementfor allocationthe Prolog stacks.The returnedreference describes
    a variable.


term_t PPLL__nneeww__tteerrmm__rreeffss(_i_n_t _n)
    Return _n new term references. The firstterm-reference is returned. The others are
    _t +1, _t +2, etc. There are two reasonsfor using this function. PL_open_query()
    expects the arguments asa set of consecutiveterm references and_v_e_r_y time-critical
    code requiring anumber ofterm-references can bewritten as:

    pl_mypredicate(term_t a0, term_t a1)
    { term_t t0 = PL_new_term_refs(2);
      term_t t1 = t0+1;

      ...
    }


term_t PPLL__ccooppyy__tteerrmm__rreeff(_t_e_r_m___t _f_r_o_m)
    Create anew term referenceand makeit pointinitially tothe sameterm as_f_r_o_m. This
    function is commonlyused tocopy a predicateargument toa term referencethat may
    be written.


void PPLL__rreesseett__tteerrmm__rreeffss(_t_e_r_m___t _a_f_t_e_r)
    Destroy all termreferences thathave beencreated after _a_f_t_e_r,including _a_f_t_e_ritself.
    Any reference to the invalidated term referencesafter this call results in undefined
    behaviour.

    Note that returning from the foreign context to Prolog will reclaim all references
    used in the foreign context. This call isonly necessary if references arecreated in-
    side a loop that never exits backto Prolog.  See also PL_open_foreign_frame(),
    PL_close_foreign_frame()and PL_discard_foreign_frame().


55..55..11..11 IInntteerraaccttiioonn wwiitthh tthhee ggaarrbbaaggee ccoolllleeccttoorr aanndd ssttaacckk--sshhiifftteerr

Prolog implementstwo mechanismsfor avoidingstack overflow: garbagecollection andstack
expansion. On machines thatallow for it, Prologwill use virtual memorymanagement to
detectstack overflowand expandthe runtimestacks. Onother machinesPrologwill reallocate
the stacksand update allpointers to them. To doso, Prolog needsto know which datais
referenced byC-code. As allProlog data knownby C isreferenced through termreferences
(term_t),Prolog has allinformation necessaryto perform itsmemory managementwithout
special precautionsfrom theC-programmer.


55..55..22 OOtthheerr ffoorreeiiggnn iinntteerrffaaccee ttyyppeess

aattoomm__tt An atomin Prologsinternal representation.Atoms are pointersto anopaque struc-
    ture. They area uniquerepresentation forrepresented text,which implies thatatom A
    represents the sametext asatom B if-and-only-ifA andB are thesame pointer.

    Atoms arethe centralrepresentation fortextual constantsin PrologThe transformation
    of C a characterstring to anatom implies a hash-tablelookup.  Ifthe same atomis
    needed often, itis advised tostore its referencein a globalvariable to avoidrepeated
    lookup.

ffuunnccttoorr__tt A functoris theinternal representation ofa name/arity pair.They are usedto
    find the name andarity of a compoundterm as well asto construct new compound
    terms. Like atomsthey live forthe wholeProlog session andare unique.

pprreeddiiccaattee__tt Handle toa Prolog predicate. Predicatehandles live forever(although they
    can loose theirdefinition).

qqiidd__tt QueryIdentifier. Usedby PL_open_query()/PL_next_solution()/PL_close_query()
    to handle backtrackingfrom C.

ffiidd__tt FrameIdentifier. Usedby PL_open_foreign_frame()/PL_close_foreign_frame().

mmoodduullee__tt A moduleis a uniquehandle toa Prolog module. Modulesare usedonly to call
    predicates in aspecific module.

ffoorreeiiggnn__tt Return typefor aC-function implementing aProlog predicate.

ccoonnttrrooll__tt Passed as additional argument to non-deterministic foreign functions.  See
    PL_retry*() andPL_foreign_context*().

iinnssttaallll__tt Typefor theinstall() anduninstall()functions ofshared ordynamiclink libraries.
    See secrefshlib.


55..66 TThhee FFoorreeiiggnn IInncclluuddee FFiillee


55..66..11 AArrgguummeenntt PPaassssiinngg aanndd CCoonnttrrooll

If Prologencounters a foreign predicateat run time itwill call a functionspecified in the
predicate definition of theforeign predicate.  The arguments1; :::;<_a_r_i_t_y>pass the Pro-
log arguments tothe goal as Prolog terms. Foreign functions shouldbe declared of type
foreign_t. Deterministicforeign functions havetwo alternatives toreturn control backto
Prolog:


_v_o_i_d PPLL__ssuucccceeeedd(())
    Succeed deterministically. PL_succeed is definedas return TRUE.


_v_o_i_d PPLL__ffaaiill(())
    Fail and startProlog backtracking. PL_fail isdefined as return FALSE.


55..66..11..11 NNoonn--ddeetteerrmmiinniissttiicc FFoorreeiiggnn PPrreeddiiccaatteess

By default foreignpredicates are deterministic. Using the PL_FA_NONDETERMINISTIC at-
tribute (see PL_register_foreign()) it is possible to register a predicate as a non-
deterministic predicate. Writing non-deterministicforeign predicates is slightlymore com-
plicated asthe foreign functionneeds context informationfor generating the nextsolution.
Note thatthe sameforeign function shouldbe preparedto be simultaneouslyactive inmore
than onegoal. Suppose the natural_number_below_n/2is a non-deterministicforeign predi-
cate, backtrackingover allnatural numberslower than thefirst argument. Nowconsider the
following predicate:

quotient_below_n(Q, N) :-
        natural_number_below_n(N, N1),
        natural_number_below_n(N, N2),
        Q =:= N1 / N2, !.

In thispredicate the functionnatural_number_below_n/2 simultaneouslygenerates solutions
for bothits invocations.

Non-deterministic foreignfunctions should be preparedto handle threedifferent calls from
Prolog:

  o _I_n_i_t_i_a_l _c_a_l_l _(PL_FIRST_CALL_)
    Prolog has justcreated aframe forthe foreign functionand asksit toproduce the first
    answer.

  o _R_e_d_o _c_a_l_l _(PL_REDO_)
    The previous invocation of theforeign function associated with thecurrent goal in-
    dicated it was possible tobacktrack.  The foreignfunction should produce the next
    solution.

  o _T_e_r_m_i_n_a_t_e _c_a_l_l _(PL_CUTTED_)
    The choice pointleft bythe foreign functionhas been destroyedby acut. The foreign
    function is giventhe opportunityto clean theenvironment.

Both the context information and the type ofcall is provided by an argument of type
control_tappended to the argument listfor deterministic foreign functions. The macro
PL_foreign_control()extracts the typeof call from thecontrol argument. The foreign
function canpass a contexthandle using the PL_retry*() macros andextract the handle
from theextra argumentusing the PL_foreign_context*() macro.


_v_o_i_d PPLL__rreettrryy((_l_o_n_g))
    The foreign functionsucceeds while leavinga choice point. Onbacktracking over this
    goal theforeign function willbe calledagain, butthe controlargument nowindicates it
    is a `Redo'call and themacro PL_foreign_context()will returnthe handle passed
    via PL_retry(). This handle isa 30 bits signedvalue (two bits areused for status
    indication).


_v_o_i_d PPLL__rreettrryy__aaddddrreessss((_v_o_i_d _*))
    As PL_retry(),but ensures anaddress asreturned by malloc()is correctly recovered
    by PL_foreign_context_address().


_i_n_t PPLL__ffoorreeiiggnn__ccoonnttrrooll((_c_o_n_t_r_o_l___t))
    Extracts the typeof call from thecontrol argument. The returnvalues are described
    above. Note that thefunction should beprepared to handlethe PL_CUTTEDcase and
    should be awarethat theother arguments arenot validin this case.


_l_o_n_g PPLL__ffoorreeiiggnn__ccoonntteexxtt((_c_o_n_t_r_o_l___t))
    Extracts the context fromthe context argument. In thecall type is PL_FIRST_CALL
    the context value is 0L.Otherwise it is the value returnedby the last PL_retry()
    associated with thisgoal (bothif the calltype isPL_REDO asPL_CUTTED).


_v_o_i_d _* PPLL__ffoorreeiiggnn__ccoonntteexxtt__aaddddrreessss((_c_o_n_t_r_o_l___t))
    Extracts an addressas passedin by PL_retry_address().

Note: If a non-deterministic foreignfunction returns using PL_succeedor PL_fail, Prolog
assumes the foreignfunction has cleaned its environment. NNoo call withcontrol argument
PL_CUTTEDwill follow.

The codeof figure5.2 shows askeleton fora non-deterministic foreignpredicate definition.

typedef struct                  /* define a context structure */
{ ...
} context;

foreign_t
my_function(term_t a0, term_t a1, foreign_t handle)
{ struct context * ctxt;

  switch( PL_foreign_control(handle) )
  { case PL_FIRST_CALL:
        ctxt = malloc(sizeof(struct context));
        ...
        PL_retry_address(ctxt);
    case PL_REDO:
        ctxt = PL_foreign_context_address(handle);

        ...
        PL_retry_address(ctxt);
    case PL_CUTTED:
        free(ctxt);
        PL_succeed;
  }
}

     Figure 5.2:  Skeleton for non-deterministic foreign functions


55..66..22 AAttoommss aanndd ffuunnccttoorrss

The followingfunctions providefor communication usingatoms andfunctors.


atom_t PPLL__nneeww__aattoomm(_c_o_n_s_t _c_h_a_r _*)
    Return an atom handle forthe given C-string. This function always succeeds. The
    returned handle isvalid aslong as theatom isreferenced (see section5.6.2.1).


const char* PPLL__aattoomm__cchhaarrss(_a_t_o_m___t _a_t_o_m)
    Return aC-string forthe textrepresented bythe givenatom. Thereturned textwill not
    be changed byProlog. It is notallowed to modifythe contents, noteven `temporary'
    as the stringmay residein read-only memory.


functor_t PPLL__nneeww__ffuunnccttoorr(_a_t_o_m___t _n_a_m_e_, _i_n_t _a_r_i_t_y)
    Returns a _f_u_n_c_t_o_r  _i_d_e_n_t_i_f_i_e_r, a handlefor the name/arity pair. The returned
    handle is validfor theentire Prolog session.


atom_t PPLL__ffuunnccttoorr__nnaammee(_f_u_n_c_t_o_r___t _f)
    Return an atomrepresenting thename of thegiven functor.


int PPLL__ffuunnccttoorr__aarriittyy(_f_u_n_c_t_o_r___t _f)
    Return the arityof thegiven functor.


55..66..22..11 AAttoommss aanndd aattoomm--ggaarrbbaaggee ccoolllleeccttiioonn

With theintroduction ofatom-garbage collection inversion 3.3.0, atomsno longerhave live
aslong asthe process. Instead,theirlifetime isguaranteed onlyas longas theyare referenced.
In thesingle-threaded version,atom garbagecollections are onlyinvoked atthe _c_a_l_l_-_p_o_r_t.
In themulti-threaded version (seesection 3.38, they appearasynchronously, except forthe
invoking thread.

For dealingwith atomgarbage collection, twoadditional functionsare provided:


void PPLL__rreeggiisstteerr__aattoomm(_a_t_o_m___t _a_t_o_m)
    Increment the referencecount ofthe atomby one. PL_new_atom()performsthis auto-
    matically, returning anatom witha reference countof atleast one.


void PPLL__uunnrreeggiisstteerr__aattoomm(_a_t_o_m___t _a_t_o_m)
    Decrement the referencecount ofthe atom. Ifthe reference-countdrops belowzero, an
    assertion error israised.

Please notethat thefollowing twocalls aredifferent with respectto atomgarbage collection:

PL_unify_atom_chars(t, "text");
PL_unify_atom(t, PL_new_atom("text"));

Thelatter incrementsthe referencecount oftheatom text,which effectivelyensuresthe atom
will neverbe collected. It is advicedto use the*_chars() or*_nchars() functions whenever
applicable.


55..66..33 AAnnaallyyssiinngg TTeerrmmss vviiaa tthhee FFoorreeiiggnn IInntteerrffaaccee

Each argument ofa foreign function (exceptfor the control argument)is of type term_t,
an opaquehandle to aProlog term. Threegroups of functionsare availablefor the analysis
of terms. The firstjust validates the type,like the Prolog predicatesvar/1, atom/1, etc
and arecalled PL_is_*(). Thesecond group attemptsto translate the argumentinto a C
primitive type.These predicatestake a term_t anda pointer tothe appropriateC-type and
return TRUEor FALSEdepending onsuccessful or unsuccessfultranslation. Ifthe translation
fails, thepointed-to datais never modified.


55..66..33..11 TTeessttiinngg tthhee ttyyppee ooff aa tteerrmm


int PPLL__tteerrmm__ttyyppee(_t_e_r_m___t)
    Obtain thetype ofa term,which shouldbe aterm returnedby oneofthe otherinterface
    predicates orpassed as anargument. Thefunction returnsthe typeof the Prologterm.
    The type identifiers arelisted below. Note thatthe extraction functionsPL_ge_t*()
    also validate thetype andthus the twosections beloware equivalent.

            if ( PL_is_atom(t) )
            { char *s;

              PL_get_atom_chars(t, &s);
              ...;
            }

    or

            char *s;
            if ( PL_get_atom_chars(t, &s) )
            { ...;
            }

    ___________________________________________________________________
    | PL_VARIABLE            |An unboundvariable. The valueof termas such|isa
    |                        |unique identifierfor thevariable.        |

    | PL_ATOM                |A Prologatom.                            |
    | PL_STRING              |A Prologstring.                          |
    | PL_INTEGER             |A Prologinteger.                         |
    | PL_FLOAT               |A Prologfloating pointnumber.            |
    | PL_TERM                |A compoundterm.  Notethat a list isa compound|
    |________________________|term_./2.________________________________|

The  functions PL_is_<_t_y_p_e> are  an  alternative to  PL_term_type().     The test
PL_is_variable(_t_e_r_m)is equivalentto PL_term_type(_t_e_r_m)== PL_VARIABLE, butthe
first isconsiderably faster.On theother hand, usinga switchover PL_term_type()isfaster
and morereadable then usingan if-then-else usingthe functions below. Allthese functions
return eitherTRUE orFALSE.


int PPLL__iiss__vvaarriiaabbllee(_t_e_r_m___t)
    Returns non-zero if_t_e_r_m isa variable.


int PPLL__iiss__aattoomm(_t_e_r_m___t)
    Returns non-zero if_t_e_r_m isan atom.


int PPLL__iiss__ssttrriinngg(_t_e_r_m___t)
    Returns non-zero if_t_e_r_m isa string.


int PPLL__iiss__iinntteeggeerr(_t_e_r_m___t)
    Returns non-zero if_t_e_r_m isan integer.


int PPLL__iiss__ffllooaatt(_t_e_r_m___t)
    Returns non-zero if_t_e_r_m isa float.


int PPLL__iiss__ccoommppoouunndd(_t_e_r_m___t)
    Returns non-zero if_t_e_r_m isa compound term.


int PPLL__iiss__ffuunnccttoorr(_t_e_r_m___t_, _f_u_n_c_t_o_r___t)
    Returns non-zeroif _t_e_r_miscompound andits functoris_f_u_n_c_t_o_r. This testisequivalent
    to PL_get_functor(), followed bytesting thefunctor, but easierto writeand faster.


int PPLL__iiss__lliisstt(_t_e_r_m___t)
    Returns non-zero if_t_e_r_m isa compound termwith functor./2 or theatom [].


int PPLL__iiss__aattoommiicc(_t_e_r_m___t)
    Returns non-zero if_t_e_r_m isatomic (not variableor compound).


int PPLL__iiss__nnuummbbeerr(_t_e_r_m___t)
    Returns non-zero if_t_e_r_m isan integer orfloat.


55..66..33..22 RReeaaddiinngg ddaattaa ffrroomm aa tteerrmm

The functions PL_get_*() read informationfrom a Prolog term. Most of themtake two
arguments. The firstis theinput term andthe second isa pointer tothe output valueor a
term-reference.


int PPLL__ggeett__aattoomm(_t_e_r_m___t _+_t_, _a_t_o_m___t _*_a)
    If _t is anatom, store the uniqueatom identifier over_a.  Seealso PL_atom_chars()
    and PL_new_atom(). If there isno needto access thedata (characters)of an atom,it
    is advised tomanipulate atoms usingtheir handle. As theatom is referencedby _t, it
    will live atleast as longas _t does. Iflonger live-time isrequired, the atomshould be
    locked using PL_register_atom().


int PPLL__ggeett__aattoomm__cchhaarrss(_t_e_r_m___t _+_t_, _c_h_a_r _*_*_s)
    If _t is anatom, store a pointerto a 0-terminated C-stringin _s. It is explicitly nnoott
    allowed to modifythe contentsof thisstring. Some built-inatoms may havethe string
    allocated in read-onlymemory, so`temporary manipulation' cancause anerror.


int PPLL__ggeett__ssttrriinngg__cchhaarrss(_t_e_r_m___t _+_t_, _c_h_a_r _*_*_s_, _i_n_t _*_l_e_n)
    If _tis astringobject, storea pointerto a0-terminatedC-string in_s andthelength ofthe
    string in _l_e_n.Note that thispointer isinvalidated by backtracking,garbage-collection
    and stack-shifts, sogenerally the onlysave operations areto pass itimmediately to a
    C-function that doesn'tinvolve Prolog.


int PPLL__ggeett__cchhaarrss(_t_e_r_m___t _+_t_, _c_h_a_r _*_*_s_, _u_n_s_i_g_n_e_d _f_l_a_g_s)
    Convert theargument term_t toa 0-terminatedC-string. _f_l_a_g_sis abitwise disjunction
    from two groups ofconstants.  The firstspecifies which term-types shouldconverted
    and the secondhow theargument isstored. Below isa specificationof these constants.
    BUF_RING implies,if thedata is notstatic (asfrom anatom), the datais copiedto the
    next buffer froma ring of16 buffers. This isa convenient wayof converting multiple
    arguments passed to aforeign predicate to C-strings. IfBUF_MALLOC is used,the
    data must befreed usingfree() when notneeded anylonger.
    ___________________________________________________________________
    | CVT_ATOM               |Convert ifterm isan atom                 |
    | CVT_STRING             |Convert ifterm isa string                |
    | CVT_LIST               |Convert ifterm isa listof integersbetween|1and 255
    | CVT_INTEGER            |Convert ifterm isan integer (using%d)    |

    | CVT_FLOAT              |Convert ifterm isa float (using%f)       |
    | CVT_NUMBER             |Convert ifterm isa integer orfloat       |
    | CVT_ATOMIC             |Convert ifterm isatomic                  |
    | CVT_VARIABLE           |Convert variableto print-name            |
    | CVT_WRITE              |Convert anyterm thatis notconverted byany|ofthe
    |                        |other flagsusing write/1. If noBUF_* isprovided,|
    |                        |BUF_RINGis implied.                      |
    | CVT_ALL                |Convert if term is any  of the above, except|for

    |________________________|CVT_VARIABLEand_CVT_WRITE________________|
    | BUF_DISCARDABLE        |Data mustcopied immediately              |
    | BUF_RING               |Data isstored ina ring ofbuffers         |
    | BUF_MALLOC             |Data  is copied  to a  new buffer  returned| by
    |________________________|malloc(3)________________________________|


int PPLL__ggeett__lliisstt__cchhaarrss(_+_t_e_r_m___t _l_, _c_h_a_r _*_*_s_, _u_n_s_i_g_n_e_d _f_l_a_g_s)
    Same as PL_get_chars(_l_, _s_, _C_V_T___L_I_S_T___f_l_a_g_s), provided_f_l_a_g_s contains noof the
    CVT_* flags.


int PPLL__ggeett__iinntteeggeerr(_+_t_e_r_m___t _t_, _i_n_t _*_i)
    If _t isa Prologinteger, assignits value over_i. On 32-bitmachines, thisis thesame as
    PL_get_long(),but avoids awarning fromthe compiler. Seealso PL_get_long().


int PPLL__ggeett__lloonngg(_t_e_r_m___t _+_t_, _l_o_n_g _*_i)
    If _t isa Prologinteger, assign itsvalue over _i.Note that Prologintegers havelimited
    value-range.  If _tis a floating pointnumber that can be representedas a long, this
    function succeeds aswell.


int PPLL__ggeett__ppooiinntteerr(_t_e_r_m___t _+_t_, _v_o_i_d _*_*_p_t_r)
    In thecurrent system,pointers arerepresentedby Prologintegers, butneed somemanip-
    ulation to makesure theydo notget truncateddue tothe limitedProlog integer range.
    PL_put_pointer()/PL_get_pointer()guarantees pointersin the range ofmalloc()
    are handled withouttruncating.


int PPLL__ggeett__ffllooaatt(_t_e_r_m___t _+_t_, _d_o_u_b_l_e _*_f)
    If _t isa floator integer, itsvalue isassigned over _f.


int PPLL__ggeett__ffuunnccttoorr(_t_e_r_m___t _+_t_, _f_u_n_c_t_o_r___t _*_f)
    If _t iscompound or anatom, the Prologrepresentation ofthe name-arity pairwill be
    assigned over _f.See also PL_get_name_arity()and PL_is_functor().


int PPLL__ggeett__nnaammee__aarriittyy(_t_e_r_m___t _+_t_, _a_t_o_m___t _*_n_a_m_e_, _i_n_t _*_a_r_i_t_y)
    If _tis compoundor anatom, thefunctor-name willbe assignedover _n_a_m_eand thearity
    over _a_r_i_t_y. Seealso PL_get_functor()and PL_is_functor().


int PPLL__ggeett__mmoodduullee(_t_e_r_m___t _+_t_, _m_o_d_u_l_e___t _*_m_o_d_u_l_e)
    If _t isan atom,the system willlookup or createthe correspondingmodule and assign
    an opaque pointerto itover _m_o_d_u_l_e,.


int PPLL__ggeett__aarrgg(_i_n_t _i_n_d_e_x_, _t_e_r_m___t _+_t_, _t_e_r_m___t _-_a)
    If _t iscompound and indexis between 1and arity (including), assign_a with aterm-
    reference to theargument.


int _PPLL__ggeett__aarrgg(_i_n_t _i_n_d_e_x_, _t_e_r_m___t _+_t_, _t_e_r_m___t _-_a)
    Same asPL_get_arg(),but nochecking isperformed, norwhether _tis actuallya term,
    nor whether _i_n_d_e_xis avalid argument-index.


55..66..33..33 EExxcchhaannggiinngg tteexxtt uussiinngg lleennggtthh aanndd ssttrriinngg

All internaltext-representation of SWI-Prologis represented usingchar * plus lengthand
allow for_0_-_b_y_t_e_s in them.The foreign librarysupports this byimplementing a*_nchars()
function foreach applicable *_chars()function.  Belowwe briefly present thesignatures of
these functions.For full documentationconsult the*_chars() function.


int PPLL__ggeett__aattoomm__nncchhaarrss(_t_e_r_m___t _t_, _u_n_s_i_g_n_e_d _i_n_t _l_e_n_, _c_h_a_r _*_*_s)


int PPLL__ggeett__lliisstt__nncchhaarrss(_t_e_r_m___t _t_, _u_n_s_i_g_n_e_d _i_n_t _l_e_n_, _c_h_a_r _*_*_s)


int PPLL__ggeett__nncchhaarrss(_t_e_r_m___t _t_, _u_n_s_i_g_n_e_d _i_n_t _l_e_n_, _c_h_a_r _*_*_s_, _u_n_s_i_g_n_e_d _i_n_t _f_l_a_g_s)


int PPLL__ppuutt__aattoomm__nncchhaarrss(_t_e_r_m___t _t_, _u_n_s_i_g_n_e_d _i_n_t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)


int PPLL__ppuutt__ssttrriinngg__nncchhaarrss(_t_e_r_m___t _t_, _u_n_s_i_g_n_e_d _i_n_t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)


int PPLL__ppuutt__lliisstt__nnccooddeess(_t_e_r_m___t _t_, _u_n_s_i_g_n_e_d _i_n_t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)


int PPLL__ppuutt__lliisstt__nncchhaarrss(_t_e_r_m___t _t_, _u_n_s_i_g_n_e_d _i_n_t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)


int PPLL__uunniiffyy__aattoomm__nncchhaarrss(_t_e_r_m___t _t_, _u_n_s_i_g_n_e_d _i_n_t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)


int PPLL__uunniiffyy__ssttrriinngg__nncchhaarrss(_t_e_r_m___t _t_, _u_n_s_i_g_n_e_d _i_n_t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)


int PPLL__uunniiffyy__lliisstt__nnccooddeess(_t_e_r_m___t _t_, _u_n_s_i_g_n_e_d _i_n_t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)


int PPLL__uunniiffyy__lliisstt__nncchhaarrss(_t_e_r_m___t _t_, _u_n_s_i_g_n_e_d _i_n_t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)


55..66..33..44 RReeaaddiinngg aa lliisstt

The functionsfrom thissection areintended toread aProlog list fromC. Supposewe expect
a listof atoms,the following codewill printthe atoms, eachon aline:

foreign_t
pl_write_atoms(term_t l)
{ term_t head = PL_new_term_ref();      /* variable for the elements */
  term_t list = PL_copy_term_ref(l);    /* copy as we need to write */

  while( PL_get_list(list, head, list) )
  { char *s;

    if ( PL_get_atom_chars(head, &s) )
      Sprintf("%s\n", s);
    else
      PL_fail;
  }

  return PL_get_nil(list);              /* test end for [] */
}


int PPLL__ggeett__lliisstt(_t_e_r_m___t _+_l_, _t_e_r_m___t _-_h_, _t_e_r_m___t _-_t)
    If _l isa listand not []assign aterm-reference to thehead to_h andto the tailto _t.


int PPLL__ggeett__hheeaadd(_t_e_r_m___t _+_l_, _t_e_r_m___t _-_h)
    If _l isa listand not []assign aterm-reference to thehead to_h.


int PPLL__ggeett__ttaaiill(_t_e_r_m___t _+_l_, _t_e_r_m___t _-_t)
    If _l isa listand not []assign aterm-reference to thetail to_t.


int PPLL__ggeett__nniill(_t_e_r_m___t _+_l)
    Succeeds if represents theatom [].


55..66..33..55 AAnn eexxaammppllee::  ddeeffiinniinngg write/1 iinn CC

Figure5.3 showsa simplifieddefinition ofwrite/1 toillustrate thedescribed functions. This
simplified versiondoes not dealwith operators. It is calleddisplay/1, because it mimics
closely thebehaviour ofthis Edinburgh predicate.
foreign_t
pl_display(term_t t)

{ functor_t functor;
  int arity, len, n;
  char *s;

  switch( PL_term_type(t) )
  { case PL_VARIABLE:
    case PL_ATOM:
    case PL_INTEGER:

    case PL_FLOAT:
      PL_get_chars(t, &s, CVT_ALL);
      Sprintf("%s", s);
      break;
    case PL_STRING:
      PL_get_string_chars(t, &s, &len);
      Sprintf("\"%s\"", s);

      break;
    case PL_TERM:
    { term_t a = PL_new_term_ref();

      PL_get_name_arity(t, &name, &arity);
      Sprintf("%s(", PL_atom_chars(name));
      for(n=1; n<=arity; n++)
      { PL_get_arg(n, t, a);

        if ( n > 1 )
          Sprintf(", ");
        pl_display(a);
      }
      Sprintf(")");
      break;
    default:

      PL_fail;                          /* should not happen */
  }

  PL_succeed;
}

             Figure 5.3:  A Foreign definition of display/1


55..66..44 CCoonnssttrruuccttiinngg TTeerrmmss

Terms canbe constructed usingfunctions from thePL_put_*()and PL_cons_*() families.
This approachbuilds the term`inside-out', starting atthe leaves andsubsequently creating
compound terms.Alternatively, termsmay be created`top-down', firstcreating acompound
holding onlyvariables andsubsequently unifyingthe arguments. Thissection discussesfunc-
tions for the firstapproach.  This approach is generally used forcreating arguments for
PL_call()and PL_open_query.


void PPLL__ppuutt__vvaarriiaabbllee(_t_e_r_m___t _-_t)
    Put a freshvariable inthe term. Thenew variablelives on theglobal stack. Notethat
    the initialvariable liveson thelocal stackand islost afterawrite tothe term-references.
    After using thisfunction, thevariable will continueto live.


void PPLL__ppuutt__aattoomm(_t_e_r_m___t _-_t_, _a_t_o_m___t _a)
    Put an atom in the term reference from a handle.  See also PL_new_atom()and
    PL_atom_chars().


void PPLL__ppuutt__aattoomm__cchhaarrss(_t_e_r_m___t _-_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Put anatom inthe term-referenceconstructed fromthe 0-terminatedstring. The string
    itself will neverbe referencesby Prolog afterthis function.


void PPLL__ppuutt__ssttrriinngg__cchhaarrss(_t_e_r_m___t _-_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Put a zero-terminatedstring in theterm-reference. The data willbe copied. See also
    PL_put_string_nchars().


void PPLL__ppuutt__ssttrriinngg__nncchhaarrss(_t_e_r_m___t _-_t_, _u_n_s_i_g_n_e_d _i_n_t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)

    Put astring, represented bya length/startpointer pairin theterm-reference. Thedata
    will becopied. This interfacecan dealwith0-bytes inthe string. Seealso section5.6.18.


void PPLL__ppuutt__lliisstt__cchhaarrss(_t_e_r_m___t _-_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Put a listof ASCIIvalues in theterm-reference.


void PPLL__ppuutt__iinntteeggeerr(_t_e_r_m___t _-_t_, _l_o_n_g _i)
    Put a Prologinteger inthe term reference.


void PPLL__ppuutt__ppooiinntteerr(_t_e_r_m___t _-_t_, _v_o_i_d _*_p_t_r)
    Put a Prolog integer in the term-reference. Provided ptr is in the `malloc()-area',
    PL_get_pointer()will get thepointer back.


void PPLL__ppuutt__ffllooaatt(_t_e_r_m___t _-_t_, _d_o_u_b_l_e _f)
    Put a floating-pointvalue inthe term-reference.


void PPLL__ppuutt__ffuunnccttoorr(_t_e_r_m___t _-_t_, _f_u_n_c_t_o_r___t _f_u_n_c_t_o_r)
    Create anew compound termfrom _f_u_n_c_t_o_rand bind_t tothis term. Allarguments of
    the termwill be variables.To createa termwith instantiatedarguments, either instan-
    tiate the argumentsusing thePL_unify_*()functions or usePL_cons_functor().


void PPLL__ppuutt__lliisstt(_t_e_r_m___t _-_l)
    Same as PL_put_functor(_l_, _P_L___n_e_w___f_u_n_c_t_o_r_(_P_L___n_e_w___a_t_o_m_(_"_._"),.2))


void PPLL__ppuutt__nniill(_t_e_r_m___t _-_l)
    Same as PL_put_atom_chars(_"_[_]_").


void PPLL__ppuutt__tteerrmm(_t_e_r_m___t _-_t_1_, _t_e_r_m___t _+_t_2)
    Make _t_1 pointto thesame term as_t_2.


void PPLL__ccoonnss__ffuunnccttoorr(_t_e_r_m___t _-_h_, _f_u_n_c_t_o_r___t _f_, _._._.)
    Create a term, whose arguments are filled from variable argumentlist holding the
    same number of term_t objects as the arity of the functor.  To create the term
    animal(gnu, 50), use:

            term_t a1 = PL_new_term_ref();
            term_t a2 = PL_new_term_ref();
            term_t t  = PL_new_term_ref();

            PL_put_atom_chars(a1, "gnu");
            PL_put_integer(a2, 50);
            PL_cons_functor(t, PL_new_functor(PL_new_atom("animal"), 2),
                            a1, a2);

    After this sequence,the term-references_a_1 and _a_2may beused for otherpurposes.


void PPLL__ccoonnss__ffuunnccttoorr__vv(_t_e_r_m___t _-_h_, _f_u_n_c_t_o_r___t _f_, _t_e_r_m___t _a_0)
    Creates a compoundterm like PL_cons_functor(), but_a_0 is anarray of termrefer-
    ences as returnedby PL_new_term_refs(). Thelength ofthis arrayshould match the
    number of argumentsrequired bythe functor.


void PPLL__ccoonnss__lliisstt(_t_e_r_m___t _-_l_, _t_e_r_m___t _+_h_, _t_e_r_m___t _+_t)
    Create a list(cons-) cell in_l from thehead and tail.The code belowcreates a listof
    atoms froma char **. Thelist isbuilt tail-to-head. ThePL_unify_*()functions can
    be used tobuild alist head-to-tail.

    void
    put_list(term_t l, int n, char **words)
    { term_t a = PL_new_term_ref();

      PL_put_nil(l);
      while( --n >= 0 )
      { PL_put_atom_chars(a, words[n]);
        PL_cons_list(l, a, l);
      }
    }

    Note that _lcan beredefined within aPL_cons_listcall asshown here becauseoper-
    ationally its oldvalue isconsumed before itsnew valueis set.


55..66..55 UUnniiffyyiinngg ddaattaa

The functionsof thissections _u_n_i_f_yterms withother terms ortranslated C-datastructures.
Except forPL_unify(), thefunctions ofthis section arespecific toSWI-Prolog. They have
been introducedto make translationof old codeeasier, but alsobecause they providefor a
faster mechanismfor returning data toProlog that requiresless term-references. Consider
the casewhere wewant a foreignfunction to returnthe hostname of themachine Prologis
running on.Using the PL_get_*() andPL_put_*()functions, thecode becomes:

foreign_t
pl_hostname(term_t name)
{ char buf[100];

  if ( gethostname(buf, sizeof(buf)) )
  { term_t tmp = PL_new_term_ref();

    PL_put_atom_chars(tmp, buf);
    return PL_unify(name, buf);
  }

  PL_fail;
}

Using PL_unify_atom_chars(),this becomes:

foreign_t
pl_hostname(term_t name)
{ char buf[100];

  if ( gethostname(buf, sizeof(buf)) )
    return PL_unify_atom_chars(name, buf);

  PL_fail;
}


int PPLL__uunniiffyy(_t_e_r_m___t _?_t_1_, _t_e_r_m___t _?_t_2)
    Unify two Prologterms andreturn non-zero onsuccess.


int PPLL__uunniiffyy__aattoomm(_t_e_r_m___t _?_t_, _a_t_o_m___t _a)
    Unify _t withthe atom_a and returnnon-zero onsuccess.


int PPLL__uunniiffyy__aattoomm__cchhaarrss(_t_e_r_m___t _?_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Unify _t withan atomcreated from _c_h_a_r_sand returnnon-zero on success.


int PPLL__uunniiffyy__lliisstt__cchhaarrss(_t_e_r_m___t _?_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Unify _t witha listof ASCII charactersconstructed from_c_h_a_r_s.


void PPLL__uunniiffyy__ssttrriinngg__cchhaarrss(_t_e_r_m___t _?_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Unify _twith aProlog stringobject createdfrom thezero-terminated string_c_h_a_r_s. The
    data will becopied. See alsoPL_unify_string_nchars().


void PPLL__uunniiffyy__ssttrriinngg__nncchhaarrss(_t_e_r_m___t _?_t_, _u_n_s_i_g_n_e_d _i_n_t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)

    Unify _twith aProlog stringobject createdfrom thestring createdfrom the_l_e_n/_c_h_a_r_s
    pair. The data willbe copied. This interfacecan deal with0-bytes in thestring. See
    also section 5.6.18.


int PPLL__uunniiffyy__iinntteeggeerr(_t_e_r_m___t _?_t_, _l_o_n_g _n)
    Unify _t witha Prologinteger from _n.


int PPLL__uunniiffyy__ffllooaatt(_t_e_r_m___t _?_t_, _d_o_u_b_l_e _f)
    Unify _t witha Prologfloat from _f.


int PPLL__uunniiffyy__ppooiinntteerr(_t_e_r_m___t _?_t_, _v_o_i_d _*_p_t_r)
    Unify _t witha Prologinteger describing thepointer. Seealso PL_put_pointer()and
    PL_get_pointer().


int PPLL__uunniiffyy__ffuunnccttoorr(_t_e_r_m___t _?_t_, _f_u_n_c_t_o_r___t _f)
    If _t isa compound termwith the givenfunctor, just succeed.If it isunbound, create
    a term andbind the variable,else fails. Notthat this functiondoes not createa term
    if the argumentis alreadyinstantiated.


int PPLL__uunniiffyy__lliisstt(_t_e_r_m___t _?_l_, _t_e_r_m___t _-_h_, _t_e_r_m___t _-_t)
    Unify _l witha list-cell (./2).If successful, writea reference tothe headof the listto
    _h and areference tothe tailof the listin _t.This reference maybe usedfor subsequent
    calls to thisfunction. Suppose wewant to returna listof atoms froma char **. We
    could usethe example describedby PL_put_list(), followedby acall toPL_unify(),
    or we canuse the codebelow. If the predicateargument is unbound,the differenceis
    minimal (thecode basedon PL_put_list()is probablyslightly faster). Iftheargument
    is bound,the codebelow mayfail beforereachingthe endof theword-list, butevenif the
    unification succeeds, thiscode avoidsa duplicate (garbage)list anda deep unification.

    foreign_t
    pl_get_environ(term_t env)
    { term_t l = PL_copy_term_ref(env);
      term_t a = PL_new_term_ref();
      extern char **environ;
      char **e;

      for(e = environ; *e; e++)
      { if ( !PL_unify_list(l, a, l) ||
             !PL_unify_atom_chars(a, *e) )
          PL_fail;
      }

      return PL_unify_nil(l);
    }


int PPLL__uunniiffyy__nniill(_t_e_r_m___t _?_l)
    Unify _l withthe atom[].


int PPLL__uunniiffyy__aarrgg(_i_n_t _i_n_d_e_x_, _t_e_r_m___t _?_t_, _t_e_r_m___t _?_a)
    Unifies the _i_n_d_e_x_-_t_hargument (1-based)of _t with_a.


int PPLL__uunniiffyy__tteerrmm(_t_e_r_m___t _?_t_, _._._.)
    Unify _twith a(normally) compoundterm. The remainingarguments isa sequenceof a
    type identifier,followed bythe requiredarguments. Thispredicate isan extensionto the
    Quintus and SICStusforeign interfacefrom whichthe SWI-Prologforeign interfacehas
    been derived,but hasproved tobe apowerful andcomfortable wayto createcompound
    terms from C. Dueto the varargpacking/unpacking and the requiredtype-switching
    this interface is slightlyslower than usingthe primitives. Please note that somebad
    C-compilers have fairlylow limits onthe number ofarguments thatmay be passedto
    a function.

    The type identifiersare:

    PL_VARIABLE nnoonnee
         Noop. Used inarguments of PL_FUNCTOR.

    PL_ATOM aattoomm__tt
         Unifythe argument withan atom,as in PL_unify_atom().

    PL_INTEGER lloonngg
         Unifythe argument withan integer,as in PL_unify_integer().

    PL_FLOAT ddoouubbllee
         Unify theargument with a float, asin PL_unify_float(). Note that,as the
         argument ispassed using theC vararg conventions,a float must becasted to a
         doubleexplicitly.

    PL_STRING ccoonnsstt cchhaarr **
         Unifythe argument witha stringobject, as inPL_unify_string_chars().

    PL_TERM tteerrmm__tt
         Unify asubterm. Note this maythe return valueof a PL_new_term_ref()call
         toget access toa variable.

    PL_CHARS ccoonnsstt cchhaarr **
         Unify the argument with an atom, constructed from  the C char *, as in
         PL_unify_atom_chars().

    PL_FUNCTOR ffuunnccttoorr__tt,, ......
         Unifythe argumentwith a compoundterm. Thisspecification shouldbe followed
         by exactlyas many specificationsas the numberof arguments ofthe compound
         term.

    PL_LIST iinntt lleennggtthh,, ......
         Createa listof theindicatedlength. The followingargumentscontain theelements
         ofthe list.

    For example, to unify anargument with the termlanguage(dutch), the following
    skeleton may beused:

    static functor_t FUNCTOR_language1;

    static void
    init_constants()
    { FUNCTOR_language1 = PL_new_functor(PL_new_atom("language"), 1);
    }

    foreign_t
    pl_get_lang(term_t r)
    { return PL_unify_term(r,
                           PL_FUNCTOR, FUNCTOR_language1,
                               PL_CHARS, "dutch");
    }

    install_t
    install()
    { PL_register_foreign("get_lang", 1, pl_get_lang, 0);
      init_constants();
    }


int PPLL__cchhaarrss__ttoo__tteerrmm(_c_o_n_s_t _c_h_a_r _*_c_h_a_r_s_, _t_e_r_m___t _-_t)
    Parse the string_c_h_a_r_s and putthe resulting Prologterm into _t. _c_h_a_r_smay or may
    not be closedusing a Prologfull-stop (i.e. adot followedby a blank). ReturnsFALSE
    if a syntax errorwas encountered and TRUEafter successful completion. In addition
    to returning FALSE, theexception-term is returned in_t on a syntaxerror.  Seealso
    term_to_atom/2.

    The following examplebuild agoal-term from astring andcalls it.

    int
    call_chars(const char *goal)
    { fid_t fid = PL_open_foreign_frame();
      term_t g = PL_new_term_ref();
      BOOL rval;

      if ( PL_string_to_term(goal, g) )
        rval = PL_call(goal, NULL);
      else
        rval = FALSE;

      PL_discard_foreign_frame(fid);
      return rval;
    }

      ...
      call_chars("consult(load)");
      ...


char * PPLL__qquuoottee(_i_n_t _c_h_r_, _c_o_n_s_t _c_h_a_r _*_s_t_r_i_n_g)
    Return a quotedversion of_s_t_r_i_n_g. If_c_h_r is '\'',the resultis aquoted atom. If_c_h_r
    is '"', theresult is astring. The result stringis storedin the samering of buffersas
    described with theBUF_RING argumentof PL_get_chars();

    In the currentimplementation, the stringis surrounded by _c_h_rand any occurenceof
    _c_h_r is doubled. In the futurethe behaviour willdepend on the character_escape
    prolog-flag. See current_prolog_flag/2.


55..66..66 CCaalllliinngg PPrroolloogg ffrroomm CC

The Prolog enginecan be called fromC. There are tointerfaces for this. For the first, a
term iscreated that couldbe used asan argument tocall/1 and nextPL_call() isused
to call Prolog. This systemis simple, but doesnot allow to inspectthe different answers
to a non-deterministicgoal and is relativelyslow as the runtimesystem needs to findthe
predicate. The other interface is basedon PL_open_query(),PL_next_solution() and
PL_cut_query()or PL_close_query(). This mechanism ismore powerful, butalso more
complicated touse.


55..66..66..11 PPrreeddiiccaattee rreeffeerreenncceess

This sectiondiscusses thefunctions usedto communicateabout predicates. Thougha Prolog
predicate may definedor not, redefined, etc., aProlog predicate has ahandle that is not
destroyed, normoved. This handleis knownby the typepredicate_t.


predicate_t PPLL__pprreedd(_f_u_n_c_t_o_r___t _f_, _m_o_d_u_l_e___t _m)
    Return a handleto apredicate for thespecified name/arity inthe givenmodule. This
    function always succeeds,creating ahandle foran undefinedpredicate ifno handle was
    available.


predicate_t PPLL__pprreeddiiccaattee(_c_o_n_s_t _c_h_a_r _*_n_a_m_e_, _i_n_t _a_r_i_t_y_, _c_o_n_s_t _c_h_a_r_* _m_o_d_u_l_e)

    Same a PL_pred(), but providesa moreconvenient interfaceto the C-programmer.


void PPLL__pprreeddiiccaattee__iinnffoo(_p_r_e_d_i_c_a_t_e___t _p_, _a_t_o_m___t _*_n_, _i_n_t _*_a_, _m_o_d_u_l_e___t _*_m)
    Return information on thepredicate _p. The name isstored over _n, thearity over _a,
    while _m receives thedefinition module. Note thatthe latter need notbe the sameas
    specified withPL_predicate(). Ifthe predicatewas importedintothe modulegiven to
    PL_predicate(), thisfunction willreturn themodulewhere thepredicate wasdefined.


55..66..66..22 IInniittiiaattiinngg aa qquueerryy ffrroomm CC

This sectiondiscusses thefunctions forcreating and manipulatingqueries fromC. Notethat
aforeign contextcan haveat mostone activequery. This impliesitis allowedto makestrictly
nested callsbetween C andProlog (Prolog calls C,calls Prolog, callsC, etc., butit is nnoott
allowed toopen multiple queriesand start generating solutionsfor each ofthem by calling
PL_next_solution(). Be sureto callPL_cut_query()orPL_close_query()on anyquery
you openedbefore openingthe next orreturning controlback to Prolog.


qid_t PPLL__ooppeenn__qquueerryy(_m_o_d_u_l_e___t _c_t_x_, _i_n_t _f_l_a_g_s_, _p_r_e_d_i_c_a_t_e___t _p_, _t_e_r_m___t _+_t_0)

    Opens aquery andreturns anidentifier forit. This functionalways succeeds,regardless
    whether the predicate is definedor not. _c_t_x is the _c_o_n_t_e_x_t  _m_o_d_u_l_e of thegoal.
    When NULL, the contextmodule of thecalling context willbe used, or userif there
    is no calling context (asmay happen in embeddedsystems).  Note thatthe context
    module only matters for _m_o_d_u_l_e___t_r_a_n_s_p_a_r_e_n_t predicates. See context_module/1
    and module_transparent/1. The_p argument specifiesthe predicate, andshould be
    the result ofa callto PL_pred()or PL_predicate().Note that itis allowedto store
    this handle asglobal dataand reuse itfor futurequeries. The term-reference_t_0 is the
    first of avector ofterm-references as returnedby PL_new_term_refs(_n).

    The _f_l_a_g_s argumentsprovides some additionaloptions concerningdebugging and ex-
    ception handling. Itis a bitwiseor ofthe following values:

    PL_Q_NORMAL
         Normal operation. The debuggerinherits its settingsfrom the environment. If
         an exceptionoccurs that isnot handled inProlog, a messageis printed andthe
         traceris started todebug theerror.

    PL_Q_NODEBUG
         Switch offthe debugger whileexecuting the goal. This optionis used by many
         callsto hook-predicatesto avoidtracingthe hooks. Anexampleis print/1calling
         portray/1from foreign code.

    PL_Q_CATCH_EXCEPTION
         If anexception is raisedwhile executing thegoal, do notreport it, but makeit
         availablefor PL_exception().

    PL_Q_PASS_EXCEPTION
         AsPL_Q_CATCH_EXCEPTION,but donot invalidate theexception-term whilecall-
         ingPL_close_query(). Thisoption isexperimental.

    The example below opensa query to thepredicate is_a/2 tofind the ancestor offor
    some name.

    char *
    ancestor(const char *me)
    { term_t a0 = PL_new_term_refs(2);
      static predicate_t p;

      if ( !p )
        p = PL_predicate("is_a", 2, "database");

      PL_put_atom_chars(a0, me);
      PL_open_query(NULL, PL_Q_NORMAL, p, a0);
      ...
    }


int PPLL__nneexxtt__ssoolluuttiioonn(_q_i_d___t _q_i_d)
    Generate the first (next)solution for the givenquery.  Thereturn value isTRUE if a
    solution was found,or FALSEto indicate thequery couldnot beproven. This function
    may be calledrepeatedly untilit fails togenerate allsolutions to thequery.


void PPLL__ccuutt__qquueerryy(_q_i_d)
    Discards the query, butdoes not deleteany of thedata created bythe query. It just
    invalidate _q_i_d, allowingfor anew call toPL_open_query()in thiscontext.


void PPLL__cclloossee__qquueerryy(_q_i_d)
    As PL_cut_query(), but alldata andbindings created bythe queryare destroyed.


int PPLL__ccaallll__pprreeddiiccaattee(_m_o_d_u_l_e___t _m_, _i_n_t _f_l_a_g_s_, _p_r_e_d_i_c_a_t_e___t _p_r_e_d_, _t_e_r_m___t _+_t_0)

    Shorthand for  PL_open_query(), PL_next_solution(), PL_cut_query(), gener-
    ating a single solution. The arguments are the sameas for PL_open_query(),the
    return value isthe sameas PL_next_solution().


int PPLL__ccaallll(_t_e_r_m___t_, _m_o_d_u_l_e___t)
    Call termjust like theProlog predicateonce/1. _T_e_r_mis calledin thespecified module,
    or inthe contextmodule ifmodule_t= NULL.Returns TRUEif thecall succeeds,FALSE
    otherwise.  Figure5.4 shows anexample to obtain thenumber of definedatoms.  All
    checks are omittedto improvereadability.


55..66..77 DDiissccaarrddiinngg DDaattaa

The Prolog datacreated and term-references needed tosetup the call and/oranalyse the
result can inmost cases be discarded right afterthe call.  PL_close_query()allows for
destructing the data, whileleaving the term-references. The calls below may be usedto
destroy term-referencesand data. Seefigure 5.4for an example.


fid_t PPLL__ooppeenn__ffoorreeiiggnn__ffrraammee()
    Created a foreignframe, holding amark that allowsthe system toundo bindingsand
    destroy data created afterit as well asproviding the environment forcreating term-
    references. This functionis called bythe kernelbefore calling aforeign predicate.


void PPLL__cclloossee__ffoorreeiiggnn__ffrraammee(_f_i_d___t _i_d)
    Discard all term-referencescreated after theframe was opened.All other Prologdata
    is retained. This function iscalled by the kernelwhenever a foreignfunction returns
    control back toProlog.


void PPLL__ddiissccaarrdd__ffoorreeiiggnn__ffrraammee(_f_i_d___t _i_d)
    Same as PL_close_foreign_frame(),but alsoundo allbindings madesince the open
    and destroy allProlog data.

It isobligatory tocall either ofthe twoclosing functions todiscard aforeign frame. Foreign
frames maybe nested.

int
count_atoms()
{ fid_t fid = PL_open_foreign_frame();
  term_t goal  = PL_new_term_ref();
  term_t a1    = PL_new_term_ref();
  term_t a2    = PL_new_term_ref();
  functor_t s2 = PL_new_functor(PL_new_atom("statistics"), 2);
  int atoms;

  PL_put_atom_chars(a1, "atoms");
  PL_cons_functor(goal, s2, a1, a2);
  PL_call(goal, NULL);         /* call it in current module */

  PL_get_integer(a2, &atoms);
  PL_discard_foreign_frame(fid);

  return atoms;
}

                      Figure 5.4:  Calling Prolog


55..66..88 FFoorreeiiggnn CCooddee aanndd MMoodduulleess

Modules areidentified via a uniquehandle. The following functions areavailable to query
and manipulatemodules.


module_t PPLL__ccoonntteexxtt()
    Return themodule identifier ofthe contextmodule ofthe currentlyactive foreignpred-
    icate.


int PPLL__ssttrriipp__mmoodduullee(_t_e_r_m___t _+_r_a_w_, _m_o_d_u_l_e___t _*_m_, _t_e_r_m___t _-_p_l_a_i_n)
    Utility  function.   If  _r_a_w is a  term, possibly  holding the  module construct
    <_m_o_d_u_l_e>:<_r_e_s_t>this functionwill make _p_l_a_i_n areference to <_r_e_s_t> andfill _m_o_d_-
    _u_l_e _* with <_m_o_d_u_l_e>.For further nestedmodule constructsthe inner mostmodule is
    returned via _m_o_d_u_l_e _*.  If_r_a_w is nota module construct_a_r_g will simplybe put in
    _p_l_a_i_n. If _m_o_d_u_l_e _*is NULL itwill beset to thecontext module. Otherwiseit willbe
    left untouched. Thefollowing exampleshows how toobtain theplain termand module
    if the defaultmodule isthe user module:

    { module m = PL_new_module(PL_new_atom("user"));
      term_t plain = PL_new_term_ref();

      PL_strip_module(term, &m, plain);
      ...


atom_t PPLL__mmoodduullee__nnaammee(_m_o_d_u_l_e___t)
    Return the nameof _m_o_d_u_l_eas an atom.


module_t PPLL__nneeww__mmoodduullee(_a_t_o_m___t _n_a_m_e)
    Find an existingor createa new modulewith namespecified by theatom _n_a_m_e.


55..66..99 PPrroolloogg eexxcceeppttiioonnss iinn ffoorreeiiggnn ccooddee

This section discusses PL_exception(), PL_throw()and PL_raise_exception(), the
interface functions to detect and generate Prologexceptions from C-code.  PL_throw()
and PL_raise_exception()from theC-interface to raisean exception fromforeign code.
PL_throw() exploits the C-function longjmp() to return immediately to the innermost
PL_next_solution().  PL_raise_exception()registers the exceptionterm and returns
FALSE. Ifa foreignpredicate returnsFALSE, whileand exception-termis registereda Prolog
exception willbe raisedby the virtualmachine.

Calling these functionsoutside the context ofa function implementing aforeign predicate
results inundefined behaviour.

PL_exception()may beused aftera callto PL_next_solution()fails,and returnsa term
reference toan exceptionterm if anexception wasraised, and 0otherwise.

If a C-function,  implementing a predicate calls Prolog  and detects an exception us-
ing PL_exception(),  it can handle  this exception,  or return with  the exception.
Some caution is  required though.  It  is nnoott allowed to call  PL_close_query()or
PL_discard_foreign_frame()afterwards,as thiswill invalidatethe exceptionterm. Below
is thecode thatcalls aProlog defined arithmeticfunction (seearithmethic_function/1).

If PL_next_solution()succeeds, theresult is analysedand translated toa number, after
which thequery is closed andall Prolog data createdafter PL_open_foreign_frame()is
destroyed. Onthe other hand,if PL_next_solution()fails andif anexception was raised,
just passit.  Otherwisegenerate an exception(PL_error() is aninternal call for building
the standarderror terms and callingPL_raise_exception()). After this,the Prolog en-
vironment shouldbe discardedusing PL_cut_query()andPL_close_foreign_frame()to
avoid invalidatingthe exceptionterm.

static int
prologFunction(ArithFunction f, term_t av, Number r)
{ int arity = f->proc->definition->functor->arity;
  fid_t fid = PL_open_foreign_frame();
  qid_t qid;
  int rval;

  qid = PL_open_query(NULL, PL_Q_NORMAL, f->proc, av);

  if ( PL_next_solution(qid) )
  { rval = valueExpression(av+arity-1, r);
    PL_close_query(qid);
    PL_discard_foreign_frame(fid);
  } else
  { term_t except;

    if ( (except = PL_exception(qid)) )
    { rval = PL_throw(except);          /* pass exception */
    } else
    { char *name = stringAtom(f->proc->definition->functor->name);

                                        /* generate exception */
      rval = PL_error(name, arity-1, NULL, ERR_FAILED, f->proc);
    }

    PL_cut_query(qid);                  /* donot destroy data */
    PL_close_foreign_frame(fid);        /* same */
  }

  return rval;
}


int PPLL__rraaiissee__eexxcceeppttiioonn(_t_e_r_m___t _e_x_c_e_p_t_i_o_n)
    Generate an exception(as throw/1)and returnFALSE. Belowis anexample returning
    an exception fromforeign predicate:

    foreign_t
    pl_hello(term_t to)
    { char *s;

      if ( PL_get_atom_chars(to, &s) )
      { Sprintf("Hello \"%s\"\n", s);

        PL_succeed;
      } else
      { term_t except = PL_new_term_ref();

        PL_unify_term(except,
                      PL_FUNCTOR, PL_new_functor(PL_new_atom("type_error"), 2),
                        PL_CHARS, "atom",
                        PL_TERM,  to);

        return PL_raise_exception(except);
      }
    }


int PPLL__tthhrrooww(_t_e_r_m___t _e_x_c_e_p_t_i_o_n)
    Similar to PL_raise_exception(), butreturns usingthe Clongjmp() functionto the
    innermost PL_next_solution().


term_t PPLL__eexxcceeppttiioonn(_q_i_d___t _q_i_d)
    If PL_next_solution()fails, this canbe due tonormal failure ofthe Prolog call,or
    because an exceptionwas raisedusing throw/1. Thisfunction returnsa handle tothe
    exception term ifan exceptionwas raised, or0 ifthe Prolog goalsimply failed..


55..66..1100 FFoorreeiiggnn ccooddee aanndd PPrroolloogg tthhrreeaaddss

If SWI-Prolog has been build to support multi-threading(see section 3.38), all foreign-
code linked to Prolog should be thread-safe (_r_e_e_n_t_r_a_n_t)  or guarded in Prolog using
with_mutex/2from simultaneous access frommultiple Prolog threads. On Unix systems,
this generallyimplies thecode shouldbe compiledwith the-D_REENTRANTflag passedto the
compiler. Please notethat on manyUnix systems notall systemcalls and library-functions
are thread-safe.Consult your manualfor details.

If youare usingSWI-Prolog as anembedded enginein amulti-threaded application youcan
access theProlog engine frommultiple threads bycreating an _e_n_g_i_n_ein each threadfrom
which youcall Prolog. Withoutcreating an engine,a thread canonly usefunctions that do
not usethe term_t type (forexample PL_new_atom()).

PPlleeaassee nnoottee  tthhaatt tthhee  iinntteerrffaaccee bbeellooww  wwiillll oonnllyy wwoorrkk  iiff tthhrreeaaddiinngg  iinn
yyoouurr aapppplliiccaattiioonn iiss bbaasseedd oonn tthhee ssaammee tthhrreeaadd--lliibbrraarryy aass  uusseedd ttoo ccoommppiillee
SSWWII--PPrroolloogg..


int PPLL__tthhrreeaadd__sseellff()
    Returns the integer Prolog identifierof the engine or-1 if the callingthread has no
    Prolog engine. This function is alsoprovided in the single-threadedversion of SWI-
    Prolog, where itreturns -2.


int PPLL__tthhrreeaadd__aattttaacchh__eennggiinnee(_P_L___t_h_r_e_a_d___a_t_t_r___t _*_a_t_t_r)
    Creates a newProlog enginein the callingthread. If thecalling threadalready has an
    engine the reference countof the engine isincremented. The _a_t_t_r argument canbe
    NULL tocreate a threadwith defaultattributes. Otherwiseit isa pointer toa structure
    with the definitionbelow. For anyfield withvalue `0', thedefault isused.

    typedef struct
    { unsigned long     local_size;    /* Stack sizes (K-bytes) */
      unsigned long     global_size;
      unsigned long     trail_size;
      unsigned long     argument_size;
      char *            alias;         /* alias name */
    } PL_thread_attr_t;

    The structure maybe destroyed afterPL_thread_attach_engine()has returned. If
    an error occurs,-1 isreturned. If this Prologis notcompiled for multi-threading,-2 is
    returned.


int PPLL__tthhrreeaadd__ddeessttrrooyy__eennggiinnee()
    Destroy   the  Prolog  engine  in  the  calling  thread.      Only  takes  ef-
    fect   if   PL_thread_destroy_engine() is   called   as  many   times   as
    PL_thread_attach_engine()in this thread. ReturnsTRUE onsuccess and FALSEif
    the calling threadhas noengine or thisProlog doesnot support threads.

    Please note thatconstruction anddestruction of enginesare relatively expensiveoper-
    ations. Only destroy anengine if performanceis not criticaland memory isa critical
    resource.  Theengine is automaticallydestroyed if thethread finishes, regardlesshow
    many times PL_thread_attach_engine()has been called.


55..66..1111 MMiisscceellllaanneeoouuss


55..66..1111..11 TTeerrmm CCoommppaarriissoonn


int PPLL__ccoommppaarree(_t_e_r_m___t _t_1_, _t_e_r_m___t _t_2)
    Compares two termsusing thestandard order ofterms andreturns -1,0 or 1.See also
    compare/3.


55..66..1111..22 RReeccoorrddeedd ddaattaabbaassee

The interfacefunctions belowprovide forefficient managementof Prologterms in theProlog
database. Theyprovide an alternativeto callingasserta/1 or recorda/3or friends.


record_t PPLL__rreeccoorrdd(_t_e_r_m___t _+_t)
    Record theterm _tinto theProlog databaseas recorda/3and returnan opaquehandle
    to the term.  The returned handleremains valid until PL_erase() iscalled on it.
    PL_recorded() isused to copyrecorded termsback tothe Prolog stack.


void PPLL__rreeccoorrddeedd(_r_e_c_o_r_d___t _r_e_c_o_r_d_, _t_e_r_m___t _-_t)
    Copy a recorded term back tothe Prolog stack.  Thesame record may be used to
    copy multiple instances atany time to theProlog stack. See also PL_record()and
    PL_erase().


void PPLL__eerraassee(_r_e_c_o_r_d___t _r_e_c_o_r_d)
    Remove the recordedterm fromthe Prologdatabase, reclaimingall associatedmemory
    resources.


55..66..1122 CCaattcchhiinngg SSiiggnnaallss ((SSooffttwwaarree IInntteerrrruuppttss))

SWI-Prolog offersboth a Cand Prolog interface todeal with softwareinterrupts (signals).
The Prologmapping is definedin section 3.10. Thissubsection deals withhandling signals
from C.

If asignal isnot used byProlog andthe handler doesnot callProlog in anyway, thenative
signal interfaceroutines maybe used.

Some versionsof SWI-Prolog,notably runningon popular Unixplatforms, handleSIG_SEGV
for guardingthe Prologstacks. If theapplication whishesto handlethis signal too,it should
use PL_signal()to install its handler after initialisating Prolog. SWI-Prolog will pass
SIG_SEGVto theuser code ifit detectedthe signal isnot relatedto a Prologstack overflow.

Anyhandler thatwishes tocall oneof theProlog interfacefunctions shouldcall PL_signal()
for itsinstallation.


void (*)() PPLL__ssiiggnnaall(_s_i_g_, _f_u_n_c)
    This functionis equivalentto theBSD-Unix signal()function, regardlessof theplatform
    used. The signalhandler isblocked whilethe signalroutine isactive, andautomatically
    reactivated after thehandler returns.

    After a signalhandler isregistered using thisfunction, thenative signal interfaceredi-
    rects the signal to ageneric signal handler insideSWI-Prolog.  Thisgeneric handler
    validates the environment,creates asuitable environmentfor callingthe interfacefunc-
    tions described inthis chapterand finally callsthe registereduser-handler.


55..66..1133 EErrrroorrss aanndd wwaarrnniinnggss

PL_warning()prints astandardProlog warningmessage tothestandard error(user_error)
stream. Pleasenote thatnew code shouldconsider usingPL_raise_exception()to raise a
Prolog exception.See also section3.9.


int PPLL__wwaarrnniinngg(_f_o_r_m_a_t_, _a_1_, _._._.)
    Print an errormessage startingwith `[WARNING: ', followedby theoutput from_f_o_r_-
    _m_a_t, followedby a`]' and anewline. Thenstart thetracer. _f_o_r_m_a_t andthe arguments
    are the sameas forprintf(2). Always returnsFALSE.


55..66..1144 EEnnvviirroonnmmeenntt CCoonnttrrooll ffrroomm FFoorreeiiggnn CCooddee


int PPLL__aaccttiioonn(_i_n_t_, _._._.)
    Perform some actionon theProlog system. _i_n_tdescribes the action,Remaining argu-
    ments depend onthe requestedaction. The actionsare listed intable 5.1.
    ___________________________________________________________________
    | PL_ACTION_TRACE        |Start Prolog tracer (trace/0).   Requires|
    |                        |no arguments.                            |
    | PL_ACTION_DEBUG        |Switch  on Prolog  debug mode  (debug/0).|
    |                        |Requires no arguments.                   |
    | PL_ACTION_BACKTRACE    |Print   backtrace   on   current   output|

    |                        |stream.   The  argument (an  int) is  the|
    |                        |number of frames printed.                |
    | PL_ACTION_HALT         |Halt  Prolog  execution.     This  action|
    |                        |should be called rather  than Unix exit()|
    |                        |to give  Prolog the opportunity  to clean|
    |                        |up.   This  call does  not return.    The|
    |                        |argument (an int) is the  exit code.  See|
    |                        |halt/1.                                  |

    | PL_ACTION_ABORT        |Generate a Prolog abort  (abort/0).  This|
    |                        |call  does  not  return.     Requires  no|
    |                        |arguments.                               |
    | PL_ACTION_BREAK        |Create  a  standard  Prolog  break  envi-|
    |                        |ronment  (break/0).    Returns after  the|
    |                        |user  types  the  end-of-file  character.|
    ||                       |Requires|no arguments.                   ||

    | PL_ACTION_GUIAPP       |Win32:  Used to  indicate the kernel that|
    |                        |the application  is a GUI  application if|
    |                        |the  argument  is  not 0  and  a  console|
    |                        |application if  the argument  is 0.    If|
    |                        |a  fatal error  occurs,  the system  uses|
    |                        |a windows  messagebox to  report this  on|
    |                        |a GUI  application and simply  prints the|
    |                        |error and exits otherwise.               |

    | PL_ACTION_WRITE        |Write  the  argument,  a  char *  to  the|
    |                        |current output stream.                   |
    | PL_ACTION_FLUSH        |Flush  the current  output stream.    Re-|
    |________________________|quires_no_arguments._____________________|

                    Table 5.1:  PL_action() options


55..66..1155 QQuueerryyiinngg PPrroolloogg


C_type PPLL__qquueerryy(_i_n_t)
    Obtain status information onthe Prolog system. The actualargument type depends
    on the informationrequired.  _i_n_tdescribes what informationis wanted. The options
    are given intable 5.2.
    ___________________________________________________________________
    | PL_QUERY_ARGC          |Return an  integer holding the  number of|
    |                        |arguments given to Prolog from Unix.     |
    | PL_QUERY_ARGV          |Return  a char  **  holding the  argument|
    |                        |vector given to Prolog from Unix.        |
    | PL_QUERY_SYMBOLFILE    |Return  a  char  *  holding  the  current|

    |                        |symbol file of the running process.      |
    | PL_MAX_INTEGER         |Return a  long, representing  the maximal|
    |                        |integer  value  represented by  a  Prolog|
    |                        |integer.                                 |
    | PL_MIN_INTEGER         |Return a  long, representing  the minimal|
    |                        |integer value.                           |
    | PL_QUERY_VERSION       |Return a  long, representing  the version|

    |                        |as 10; 000M* +100m* +p, where  M is  the |
    |                        |major,  m the  minor version  number and |
    |                        |p the  patch-level.   For  example, 20717|
    |________________________|means_2.7.17.____________________________|

                     Table 5.2:  PL_query() options


55..66..1166 RReeggiisstteerriinngg FFoorreeiiggnn PPrreeddiiccaatteess


int PPLL__rreeggiisstteerr__ffoorreeiiggnn(_c_o_n_s_t _c_h_a_r _*_n_a_m_e_, _i_n_t _a_r_i_t_y_, _f_o_r_e_i_g_n___t _(_*_f_u_n_c_t_i_o_n_)_(_)_, _i_n_t _f_l_a_g_s)

    Register a C-functionto implementa Prolog predicate.After this callreturns success-
    fully a predicatewith name _n_a_m_e(a char *)and arity _a_r_i_t_y(a Cint) is created. As
    a special case,_n_a_m_e may consistof a sequenceof alpha-numerical charactersfollowed
    by the colon(:). In this casethe name uptilthe colon istaken to bethe destination
    module and therest ofthe name thepredicate name.

    When called in Prolog,Prolog will call _f_u_n_c_t_i_o_n. _f_l_a_g_sforms bitwise or'ed listof
    options for theinstallation. These are:
    ___________________________________________________________________
    | PL_FA_NOTRACE          |Predicate cannotbe seenin the tracer     |
    | PL_FA_TRANSPARENT      |Predicate ismodule transparent           |
    | PL_FA_NONDETERMINISTIC |Predicateis non-deterministic. Seealso PL_retry().|
    |_PL_FA_VARARGS__________|Use_alternativecalling_convention._______|


void PPLL__rreeggiisstteerr__eexxtteennssiioonnss(_P_L___e_x_t_e_n_s_i_o_n _*_e)
    Register foreign predicates from a table of structures. The type PL_extension is
    defined as:

    typedef struct _PL_extension
    { char          *predicate_name; /* Name of the predicate */
      short         arity;           /* Arity of the predicate */
      pl_function_t function;        /* Implementing functions */
      short         flags;           /* Or of PL_FA_... */
    } PL_extension;

    Here is anexample ofits usage:

    static PL_extension predicates[] = {
    { "foo",        1,      pl_foo, 0 },
    { "bar",        2,      pl_bar, PL_FA_NONDETERMINISTIC },
    { NULL,         0,      NULL,   0 }
    };

    main(int argc, char **argv)
    { PL_register_extensions(predicates);

      if ( !PL_initialise(argc, argv) )
        PL_halt(1);

      ...
    }

    The functionPL_register_extensions()is theonlyPL_*function thatmay becalled
    bbeeffoorree PL_initialise().The functions areregistered afterregistration ofthe SWI-
    Prolog builtinforeign predicates andbefore loadingthe initialsaved state.This implies
    that initialization/1 directivescan referto them.


55..66..1177 FFoorreeiiggnn CCooddee HHooookkss

For variousspecific applicationssome hooks reprovided.


PL_dispatch_hook_t PPLL__ddiissppaattcchh__hhooookk(_P_L___d_i_s_p_a_t_c_h___h_o_o_k___t)
    If this hookis not NULL,this functionis called whenreading fromthe terminal. It is
    supposed to dispatchevents when SWI-Prologis connectedto a windowenvironment.
    It canreturn twovalues: PL_DISPATCH_INPUTindicatesProlog inputis availableon file
    descriptor 0or PL_DISPATCH_TIMEOUT toindicate atimeout. The oldhookis returned.
    The type PL_dispatch_hook_tis defined as:

    typedef int  (*PL_dispatch_hook_t)(void);


void PPLL__aabboorrtt__hhooookk(_P_L___a_b_o_r_t___h_o_o_k___t)
    Install a hookwhen abort/0 isexecuted. SWI-Prolog abort/0is implementedusing
    C setjmp()/longjmp() construct. Thehooks are executedin the reverseorder of their
    registration after thelongjmp() tookplace and beforethe Prologtoplevel is reinvoked.
    The type PL_abort_hook_tis defined as:

    typedef void (*PL_abort_hook_t)(void);


int PPLL__aabboorrtt__uunnhhooookk(_P_L___a_b_o_r_t___h_o_o_k___t)
    Remove a hook installedwith PL_abort_hook(). ReturnsFALSE if no suchhook is
    found, TRUE otherwise.


void PPLL__oonn__hhaalltt(_v_o_i_d _(_*_f_)_(_i_n_t_, _v_o_i_d _*_)_, _v_o_i_d _*_c_l_o_s_u_r_e)
    Register thefunction _f tobe calledif SWI-Prologis halted.The function iscalled with
    two arguments: the exit codeof the process(0 if this cannotbe determined on your
    operating system) and the_c_l_o_s_u_r_e argument passedto the PL_on_halt()call. See
    also at_halt/1.


55..66..1188 SSttoorriinngg ffoorreeiiggnn ddaattaa

This sectionprovides some hintsfor handlingforeign data inProlog. With foreigndata, we
refer todata that isused by foreign languagepredicates and needsto be passedaround in
Prolog. Excludingcombinations, there arethree principaloptions for storingsuch data

  o _N_a_t_u_r_a_l _P_r_o_l_o_g _d_a_t_a
    E.i. usingthe representationone wouldchoose ifthere wasno foreigninterface required.

  o _O_p_a_q_u_e _p_a_c_k_e_d _P_r_o_l_o_g _d_a_t_a
    Data can alsobe represetented ina foreign structureand stored onthe Prolog stacks
    using PL_put_string_nchars()and retrievedusing PL_get_string_chars(). It is
    generally good practiceto wrapthe string ina compoundterm with arity1, soProlog
    can identify thetype. portray/1 rulesmay beused tostreamline printing suchterms
    during development.

  o _N_a_t_u_r_a_l _f_o_r_e_i_g_n _d_a_t_a_, _p_a_s_s_i_n_g _a _p_o_i_n_t_e_r
    An alternative is to passa pointer to theforeign data.  Again,this functor may be
    wrapped in acompound term.

The choicemay beguided using thefollowing distinctions

  o _I_s _t_h_e _d_a_t_a _o_p_a_q_u_e _t_o _P_r_o_l_o_g
    With `opaque' data, we referto data handled inforeign functions, passed aroundin
    Prolog, but ofwhich Prolognever examines thecontents of thedata itself. Ifthe data
    is opaque to Prolog, thechoosen representation does not dependon simple analysis
    by Prolog, and the selection willbe driven solely by simplicityof the interface and
    performance (both intime andspace).

  o _H_o_w _b_i_g _i_s _t_h_e _d_a_t_a
    Is effient encodingrequired? For examine,a boolean araymay beexpressed as acom-
    pound term, holding integerseach of whichcontains a number ofbits, or asa list of
    true and false.

  o _W_h_a_t _i_s _t_h_e _n_a_t_u_r_e _o_f _t_h_e _d_a_t_a
    For examples in C, constants areoften expressed using `enum' or #define'dinteger
    values. If prologneeds tohandle thisdata, atomsare amore logicalchoice. Whether or
    not this mappingis used dependson whether Prologneeds tointerpret the data,how
    important debugging isand howimportant performance is.

  o _W_h_a_t _i_s _t_h_e _l_i_f_e_t_i_m_e _o_f _t_h_e _d_a_t_a
    We can distinguishthree cases.

      1. Thelifetime isdictated bythe accesibility ofthe dataon theProlog stacks.Their
         is noway by whichthe foreign code whenthe data becomes`garbage', and the
         data thusneeds tobe represented onthe Prolog stacksusing Prolog data-types.
         (2),

      2. The datalives on the`heap' and isexplicitly allocated anddeallocated.  Inthis
         case, representing the data using native foreignrepresentation and passing a
         pointerto it isa sensiblechoice.

      3. The datalives as during thelifetime of a foreignpredicate.  Ifthe predicate is
         deterministic, foreignautomatic variables are suitable. if the predicateis non-
         deterministic, thedata may be allocated usingmalloc() and a pointer maybe
         passed. Seesection 5.6.1.1.


55..66..1188..11 EExxaammpplleess ffoorr ssttoorriinngg ffoorreeiiggnn ddaattaa

In thissection, we wulloutline some examples,covering typical cases.In the firstexample,
we will dealwith extending Prolog's data representationwith integer-sets, represented as
bit-vectors. Inthe second example,we lookat handling a`netmask'. Finally, wediscuss the
outline ofthe DDEinterface.

IInntteeggeerr  sseettss  withnot-to-far-apart upper- and lower-boundscan be represented using
bit-vectors. Common setoperations, such asunion, intersection, etc.are reduced tosimple
and'ingand or'ingthe bitvectors. Thiscanbe donein Prolog,using acompound termholding
integerarguments. Especially iftheintegers arekept belowthe maximumtaggedinteger value
(see current_prolog_flag/2), thisrepresentation is fairlyspace-efficient (wasting 1word
for thefunctor and and7 bitsper integer forthe tags). Arithmetic canall be performedin
Prolog too.

Forreally demandingapplications, foreignrepresentation willperform better,especially time-
wise. Bit-vectors are natrually expressedusing string objects. If the stringis wrapped in
bitvector/1, lower-boundof thevector is 0,and theupperbound is notdefined, animple-
mentation forgetting andputting the setesas wellas the unionpredicate forit isbelow.

#include <SWI-Prolog.h>

#define max(a, b) ((a) > (b) ? (a) : (b))
#define min(a, b) ((a) < (b) ? (a) : (b))

static functor_t FUNCTOR_bitvector1;

static int
get_bitvector(term_t in, int *len, unsigned char **data)
{ if ( PL_is_functor(in, FUNCTOR_bitvector1) )
  { term_t a = PL_new_term_ref();

    PL_get_arg(1, in, a);
    return PL_get_string(a, (char **)data, len);
  }

  PL_fail;
}

static int
unify_bitvector(term_t out, int len, const unsigned char *data)
{ if ( PL_unify_functor(out, FUNCTOR_bitvector1) )
  { term_t a = PL_new_term_ref();

    PL_get_arg(1, out, a);

    return PL_unify_string_nchars(a, len, (const char *)data);
  }

  PL_fail;
}

static foreign_t
pl_bitvector_union(term_t t1, term_t t2, term_t u)
{ unsigned char *s1, *s2;
  int l1, l2;

  if ( get_bitvector(t1, &l1, &s1) &&
       get_bitvector(t2, &l2, &s2) )
  { int l = max(l1, l2);
    unsigned char *s3 = alloca(l);

    if ( s3 )
    { int n;
      int ml = min(l1, l2);

      for(n=0; n<ml; n++)
        s3[n] = s1[n] | s2[n];
      for( ; n < l1; n++)
        s3[n] = s1[n];
      for( ; n < l2; n++)
        s3[n] = s2[n];

      return unify_bitvector(u, l, s3);
    }

    return PL_warning("Not enough memory");
  }

  PL_fail;
}

install_t
install()
{ PL_register_foreign("bitvector_union", 3, pl_bitvector_union, 0);

  FUNCTOR_bitvector1 = PL_new_functor(PL_new_atom("bitvector"), 1);
}

NNeettmmaasskk''ss  areused with TCP/IPconfiguration. Suppose we havean applicationdealing
with reasoningabout a networkconfiguration. Such anapplication requires communicating
netmask structuresfrom the operatingsystem, reasoning aboutthem and possiblycommu-
nicate themto theuser. A netmaskconsists of4 bitmasksbetween 0 and255. C-application
normallysee themas an4-byte wideunsigned integer.SWI-Prolog cannotdo that,as integers
are alwayssigned.

We could usethe string approach outlinedabove, but this makes ithard to handle these
terms inProlog. Abetter choiceis a compoundterm netmask/4,holding the4 submasksas
integer arguments.

As theimplementation istrivial, we willomit thishere.

TThhee  DDDDEE iinntteerrffaaccee  (see section3.45) represents anothercommon usage ofthe foreign
interface: providing communication tonew operating systemfeatures.  TheDDE interface
requires knowledgeabout active DDE serverand client channels. These channels contains
various foreigndata-types. Suchan interfaceis normally achievedusing anopen/close proto-
col thatcreates anddestroys a_h_a_n_d_l_e. The handleis areference toa foreigndata-structure
containing therelevant information.

There area coupleof possibilitiesfor representingthe handle.The choicedepends onrespon-
sibilities and debuggingfacilities.  Thesimplest aproach is tousing PL_unify_pointer()
and PL_get_pointer(). Thisapproach isfast andeasy, buthas thedrawbacks of(untyped)
pointers: there is no reliableway to detect the validityof the pointer, not toverify it is
pointing toa structure ofthe desired type. Thepointer may bewrapped into acompound
term witharity 1(i.e. dde_channel(<_P_o_i_n_t_e_r>)), makingthe type-problem lessserious.

Alternatively (used in theDDE interface), the interface code can maintaina (preferably
variable length)array of pointers andreturn the index inthis array. This provides better
protection. Especiallyfor debuggingpurposes, wrappingthe handle ina compoundis agood
suggestion.


55..66..1199 EEmmbbeeddddiinngg SSWWII--PPrroolloogg iinn aa CC--pprrooggrraamm

Asof version2.1.0, SWI-Prologmay beembedded ina C-program. Toreach ata compiledC-
program withSWI-Prolog asan embeddedapplication is verysimilar tocreating astatically
linked SWI-Prologexecutable asdescribed in section5.4.1.

The file\ldots/pl/include/stub.c definesSWI-Prologs default mainprogram:

int
main(int argc, char **argv)
{ if ( !PL_initialise(argc, argv) )
    PL_halt(1);

  PL_install_readline();        /* delete if you don't want readline */

  PL_halt(PL_toplevel() ? 0 : 1);
}

This may  be replaced  with your  own main  C-program.   The  interface function
PL_initialise()mmuusstt becalled beforeany ofthe otherSWI-Prolog foreignlanguage func-
tions described inthis chapter.  PL_initialise()interprets all the command-lineargu-
ments, exceptfor the-t toplevel flag thatis interpretedby PL_toplevel().


int PPLL__iinniittiiaalliissee(_i_n_t _a_r_g_c_, _c_h_a_r _*_*_a_r_g_v)
    Initialises theSWI-Prolog heapand stacks,restores the bootQLF file,loads thesystem
    and personalinitialisation files,runs theat_initialization/1 hooksandfinally runs
    the -g goal hook.

    Special consideration isrequired forargv[0]. OnUUnniixx, this argumentpasses thepart
    of the commandlinethat is usedto locate theexecutable. Prolog usesthis to findthe
    file holding therunning executable. The WWiinnddoowwss versionuses this tofind a _m_o_d_u_l_e
    of the runningexecutable. If thespecified modulecannot befound, it triesthe module
    libpl.dll, containing theProlog runtime kernel.In all thesecases, the resultingfile
    is used fortwo purposes

      o  See whethera Prologsaved-state is appendedto the file. Ifthis isthe case, this
         state willbe loaded instead ofthe default boot.prc file fromthe SWI-Prolog
         homedirectory. See alsoqsave_program/[1,2] andsection 5.7.

      o  Findthe Prolog homedirectory. Thisprocess isdescribed in detailin section5.8.

    PL_initialise() returns1 if allinitialisation succeededand 0otherwise.

    In most cases,_a_r_g_c and _a_r_g_vwill bepassed from themain program. Itis allowed to
    create your own argumentvector, provided argv[0] isconstructed according to the
    rules above. Forexample:

    int
    main(int argc, char **argv)
    { char *av[10];
      int ac = 0;

      av[ac++] = argv[0];
      av[ac++] = "-x";
      av[ac++] = "mystate";
      av[ac]   = NULL;

      if ( !PL_initialise(ac, av) )
        PL_halt(1);
      ...
    }

    Please note thatthe passed argumentvector maybe referred fromProlog at anytime
    and should thereforebe validas long asthe Prologengine is used.

    A goodsetup inWindows isto addSWI-Prolog's bindirectory toyour PATHand either
    pass a moduleholding asaved-state, or "libpl.dll"as argv[0].


void PPLL__iinnssttaallll__rreeaaddlliinnee()
    Installs theGNU-readline line-editor.Embedded applicationsthat donot usetheProlog
    toplevel should normallydelete thisline, shrinking theProlog kernelsignificantly.


int PPLL__ttoopplleevveell()
    Runs thegoal of the-t toplevel switch(default prolog/0)and returns1 ifsuccess-
    ful, 0 otherwise.


void PPLL__hhaalltt(_i_n_t _s_t_a_t_u_s)
    Cleanup the Prologenvironment andcalls exit() withthe statusargument.


55..77 LLiinnkkiinngg eemmbbeeddddeedd aapppplliiccaattiioonnss uussiinngg pplllldd

The utilityprogram plld(Win32: plld.exe)may beused tolink acombination ofC-files and
Prolog filesinto astand-alone executable. plld automatesmost ofwhat is describedin the
previous sections.

Inthe normalusage, acopyis madeof thedefaultembedding template\ldots/pl/include/
stub.c. The main()routine is modifiedto suit yourapplication. PL_initialise() mmuusstt
be passed theprogram-name (_a_r_g_v_[_0_]) (Win32: the executing programcan be obtained
using GetModuleFileName()). Theother elements ofthe command-linemay be modified.
Next, plldis typicallyinvoked as:

plld -o output stubfile.c [other-c-or-o-files] [plfiles]

plld willfirst split theoptions into variousgroups for boththe C-compilerand the Prolog
compiler. Next,it will addvarious defaultoptions to theC-compiler andcall it tocreate an
executable holdingthe user'sC-code andthe Prologkernel. Then,it willcall theSWI-Prolog
compiler tocreate asaved state fromthe providedProlog files andfinally, itwill attach this
saved stateto thecreated emulator tocreate therequested executable.

Below, itis describedhow the optionsare splitand which additionaloptions arepassed.

--hheellpp
    Print brief synopsis.

--ppll _p_r_o_l_o_g
    Select the prologto use. Thisprolog is usedfor two purposes:get the home-directory
    as well asthe compiler/linkeroptions and createa savedstate of theProlog code.

--lldd _l_i_n_k_e_r
    Linker used to link the raw executable. Default is to use the C-compiler (Win32:
    link.exe).

--cccc _C_-_c_o_m_p_i_l_e_r
    Compiler for .cfiles foundon the commandline.Default is thecompiler usedto build
    SWI-Prolog (see current_prolog_flag/2) (Win32:cl.exe).

--cc++++ _C_+_+_-_c_o_m_p_i_l_e_r
    Compiler for C++sources (extensions.cpp, .cxx,.cc or .C)files foundon the com-
    mandline. Default isc++ or g++if theC-compiler is gcc)(Win32: cl.exe).

--nnoossttaattee
    Just relink the kernel, donot add any Prologcode to the new kernel. This isused
    to create a newkernel holding additionalforeign predicates on machinesthat do not
    support the shared-library (DLL) interface, or ifbuilding the state cannot be han-
    dled by the default procedureused by plld. In the latter casethe state is created
    seperately andappended tothe kernelusing cat <_k_e_r_n_e_l> <_s_t_a_t_e> > <_o_u_t>(Win32:
    copy /b <_k_e_r_n_e_l>+<_s_t_a_t_e> <_o_u_t>)

--ppll--ooppttiioonnss _,_._._.
    Additional options passedto Prologwhen creating thesaved state. Thefirst character
    immediately following pl-optionsis usedas separatorand translated tospaces when
    the argumentis built.Example: -pl-options,-F,xpce passed-F xpceas additional
    flags to Prolog.

--lldd--ooppttiioonnss _,_._._.
    Passes options tothe linker,similar to -pl-options.

--cccc--ooppttiioonnss _,_._._.
    Passes options tothe C/C++compiler, similar to-pl-options.

--vv
    Select verbose operation,showing thevarious programs andtheir options.

--oo _o_u_t_f_i_l_e
    Reserved to specifythe finaloutput file.

--ll_l_i_b_r_a_r_y
    Specifies a library for theC-compiler.  By default, -lpl(Win32:  libpl.lib)and the
    libraries needed bythe Prologkernel are given.

--LL_l_i_b_r_a_r_y_-_d_i_r_e_c_t_o_r_y
    Specifies a librarydirectory forthe C-compiler.By defaultthe directory containingthe
    Prolog C-library forthe currentarchitecture is passed.

-g | -Iinclude-directory | -Ddefinition
    These optionsare passedto theC-compiler. Bydefault, theinclude directorycontaining
    SWI-Prolog.h is passed.plld adds twoadditional * -Ddefflags:

    --DD____SWI_PROLOG__
         Indicatesthe code isto beconnected to SWI-Prolog.

    --DD____SWI_EMBEDDED__
         Indicatesthe creation ofan embeddedprogram.

 _*_._o | _*_._c | _*_._C | _*_._c_x_x | _*_._c_p_p
    Passed as inputfiles tothe C-compiler

 _*_._p_l |_*_._q_l_f
    Passed as inputfiles tothe Prolog compilerto createthe saved-state.

 *
    I.e. all otheroptions. These arepassed aslinker options tothe C-compiler.


55..77..11 AA ssiimmppllee eexxaammppllee

Thefollowing isa verysimple examplegoing throughall thesteps outlinedabove. It provides
an arithmeticexpression evaluator.We willcall theapplication calcand defineit inthe files
calc.c andcalc.pl. The Prologfile issimple:

calc(Atom) :-
        term_to_atom(Expr, Atom),
        A is Expr,
        write(A),
        nl.

The C-partof theapplication parsesthe command-lineoptions, initialises theProlog engine,
locates thecalc/1 predicateand calls it.The coder isin figure5.5.

#include <stdio.h>
#include <SWI-Prolog.h>

#define MAXLINE 1024

int
main(int argc, char **argv)
{ char expression[MAXLINE];
  char *e = expression;
  char *program = argv[0];
  char *plav[2];
  int n;

  /* combine all the arguments in a single string */

  for(n=1; n<argc; n++)
  { if ( n != 1 )
      *e++ = ' ';
    strcpy(e, argv[n]);
    e += strlen(e);

  }

  /* make the argument vector for Prolog */

  plav[0] = program;
  plav[1] = NULL;

  /* initialise Prolog */

  if ( !PL_initialise(1, plav) )
    PL_halt(1);

  /* Lookup calc/1 and make the arguments and call */

  { predicate_t pred = PL_predicate("calc", 1, "user");

    term_t h0 = PL_new_term_refs(1);
    int rval;

    PL_put_atom_chars(h0, expression);
    rval = PL_call_predicate(NULL, PL_Q_NORMAL, pred, h0);

    PL_halt(rval ? 0 : 1);
  }

  return 0;
}

             Figure 5.5:  C-source for the calc application

The applicationis nowcreated using thefollowing command-line:

% plld -o calc calc.c calc.pl

The followingindicates theusage of theapplication:

% calc pi/2
1.5708


55..88 TThhee PPrroolloogg ``hhoommee'' ddiirreeccttoorryy

Executables embeddingSWI-Prolog should be ableto find the `home'directory of the de-
velopment environmentunless aself-contained saved-state hasbeen addedto the executable
(see qsave_program/[1,2]andsection 5.7).

If Prologstarts up, itwill try tolocate the developmentenvironment. To do so,it will try
the followingsteps untilone succeeds.

 1. If theenvironment variableSWI_HOME_DIRis definedand pointstoan existingdirectory,
    use this.

 2. If the environment variableSWIPL is definedand points to anexisting directory, use
    this.

 3. Locate the primaryexecutable or (Windowsonly) acomponent (_m_o_d_u_l_e) thereofand
    check whether the parentdirectory of the directoryholding this file containsthe file
    swipl. If so,this filecontainsthe (relative)path tothe homedirectory. Ifthis directory
    exists, use this.This is thenormal mechanismused by thebinary distribution.

 4. If the precompiledpath exists,use it. Thisis only usefulfor asource installation.

If all failsand there is no stateattached to the executable orprovided Windows module
(see PL_initialise()), SWI-Prolog gives up. If astate is attached,the current working
directory isused.

The file_search_path/2aliasswi isset to pointto thehome directory located.


55..99 EExxaammppllee ooff UUssiinngg tthhee FFoorreeiiggnn IInntteerrffaaccee

Below isan example showingall stages ofthe declaration ofa foreign predicatethat trans-
forms atomspossibly holdinguppercase letters intoan atomonly holding lowercase letters.
Figure 5.6shows theC-source file,figure 5.7illustrates compilingand loadingof foreigncode.
/*  Include file depends on local installation */

#include <SWI-Prolog.h>
#include <stdlib.h>
#include <ctype.h>

foreign_t
pl_lowercase(term_t u, term_t l)
{ char *copy;
  char *s, *q;

  int rval;

  if ( !PL_get_atom_chars(u, &s) )
    return PL_warning("lowercase/2: instantiation fault");
  copy = malloc(strlen(s)+1);

  for( q=copy; *s; q++, s++)

    *q = (isupper(*s) ? tolower(*s) : *s);
  *q = '\0';

  rval = PL_unify_atom_chars(l, copy);
  free(copy);

  return rval;
}

install_t
install()
{ PL_register_foreign("lowercase", 2, pl_lowercase, 0);
}

                   Figure 5.6:  Lowercase source file

% gcc -I/usr/local/lib/pl-\plversion/include -fpic -c lowercase.c
% gcc -shared -o lowercase.so lowercase.o

% pl
Welcome to SWI-Prolog (Version \plversion)
Copyright (c) 1993-1996 University of Amsterdam.  All rights reserved.

For help, use ?- help(Topic). or ?- apropos(Word).

1 ?- load_foreign_library(lowercase).

Yes
2 ?- lowercase('Hello World!', L).

L = 'hello world!'

Yes

    Figure 5.7:  Compiling the C-source and loading the object file


55..1100 NNootteess oonn UUssiinngg FFoorreeiiggnn CCooddee


55..1100..11 MMeemmoorryy AAllllooccaattiioonn

SWI-Prolog's memoryallocation is based onthe malloc(3) library routines. Foreign ap-
plications cansafely use malloc(3),realloc(3) and free(3). Memoryallocation using
brk(2) orsbrk(2) isnot allowed asthese callsconflict with malloc(3).


55..1100..22 DDeebbuuggggiinngg FFoorreeiiggnn CCooddee

Statically linkedforeign code orembedded systems can bedebugged normally. Most mod-
ern environmentsprovide debuggingtools for dynamicallyloaded sharedobjects ordynamic
load libraries. Thefollowing example traces thecode of lowercaseusing gdb(1) ina Unix
environment.

% gcc -I/usr/local/lib/pl-2.2.0/include -fpic -c -g lowercase.c
% gcc -shared -o lowercase.so lowercase.o
% gdb pl
(gdb) r
Welcome to SWI-Prolog (Version \plversion)
Copyright (c) 1993-1996 University of Amsterdam.  All rights reserved.

For help, use ?- help(Topic). or ?- apropos(Word).

?- load_foreign_library(lowercase).
<type Control-C>
(gdb) shared                    % loads symbols for shared objects
(gdb) break pl_lowercase
(gdb) continue
?- lowercase('HELLO', X).


55..1100..33 NNaammee CCoonnfflliiccttss iinn CC mmoodduulleess

In thecurrent version ofthe systemall public Cfunctions of SWI-Prologare in thesymbol
table. Thiscan leadto nameclashes withforeign code. SomedayI shouldwrite aprogram to
strip allthese symbolsfrom thesymbol table(why doesUnix nothave that?). Fornow Ican
only suggestto giveyour function anothername. You cando this usingthe Cpreprocessor.
If_for example_yourforeign package usesa function warning(),which happensto exist in
SWI-Prolog aswell, thefollowing macro shouldfix theproblem.

#define warning warning_

Note thatshared librariesdo nothave thisproblem asthe sharedlibrary loaderwill onlylook
for symbolsin themain executable forsymbols thatare not definedin thelibrary itself.


55..1100..44 CCoommppaattiibbiilliittyy ooff tthhee FFoorreeiiggnn IInntteerrffaaccee

The term-referencemechanism was firstused by QuintusProlog version 3. SICStusProlog
version 3is strongly basedon the Quintusinterface. The describedSWI-Prolog interface is
similar tousing the Quintusor SICStus interfaces, definingall foreign-predicate arguments
of type+term. SWI-Prologexplicitly uses typefunctor_t,while Quintus andSICStus uses
<_n_a_m_e> and<_a_r_i_t_y>. As the names ofthe functions differfrom Prolog toProlog, a simple
macro layerdealing withthe names canalso dealwith this detail.For example:

#define QP_put_functor(t, n, a) PL_put_functor(t, PL_new_functor(n, a))

The PL_unify_*() functionsare lackingfrom the Quintusand SICStusinterface. They can
easily beemulated orthe put/unify approachshould beused to writecompatible code.

The  PL_open_foreign_frame()/PL_close_foreign_frame() combination  is  lack-
ing  from both  other Prologs.    SICStus has  PL_new_term_refs(_0),  followed by
PL_reset_term_refs()thatallows for discardingterm references.

The Prologinterface forthe graphicaluser interface packageXPCE sharesabout 90% ofthe
code usinga simplemacro layer todeal withdifferent namingand calling conventionsof the
interfaces.


CChhaapptteerr 66..  GGEENNEERRAATTIINNGG RRUUNNTTIIMMEE AAPPPPLLIICCAATTIIOONNSS

This chapterdescribes the features ofSWI-Prolog for delivering applicationsthat can run
without thedevelopment versionof the systeminstalled.

A SWI-Prolog runtime executableis a file consisting of twoparts.  The first part isthe
_e_m_u_l_a_t_o_r, whichis machinedependent. The secondpart isthe _r_e_s_o_u_r_c_e _a_r_c_h_i_v_e, which
containsthe compiledprogram ina machine-independentformat,startup optionsand possibly
user-defined _r_e_s_o_u_r_c_e_s,see resource/3and open_resource/3.

These two partscan be connected in various differentways.  The most commonway for
distributed runtime applicationsis to _c_o_n_c_a_t_e_n_a_t_e thetwo parts.  Thiscan be achieved
using externalcommands (Unix:cat, Windows: copy),or usingthe stand_alone optionto
qsave_program/2. Thesecond option isto attach astartup script infront ofthe resource
that startsthe emulatorwith theproper options. Thisis thedefault underUnix. Finally, an
emulator canbe toldto use aspecified resourcefile using the-x commandlineswitch.


qqssaavvee__pprrooggrraamm((_+_F_i_l_e_, _+_L_i_s_t_O_f_O_p_t_i_o_n_s))
    Saves the currentstate ofthe programto thefile _F_i_l_e. Theresult isa resourcearchive
    containing asaved-state thatexpresses allProlog datafromthe runningprogram andall
    user-defined resources. Dependingon the stand_alone option, theresource isheaded
    by the emulator,a Unixshell-script or nothing.

    _L_i_s_t_O_f_O_p_t_i_o_n_s is alist of <_K_e_y>= <_V_a_l_u_e>or<_K_e_y>(<_V_a_l_u_e>) pairs. Theavailable
    keys are describedin table6.1.
_________________________________________________________________________
|__KKeeyy________________||OOppttiioonn__||________TTyyppee____________||DDeessccrriippttiioonn__________________________________________________||
|| local      | --LL   ||    K-bytes    |Size (Limit) of local stack         |
| global     | --GG   ||    K-bytes    |Size (Limit) of global stack        |
| trail      | --TT   ||    K-bytes    |Size (Limit) of trail stack         |
| argument   | --AA   ||    K-bytes    |Size (Limit) of argument stack      |

| goal       | --gg   ||     atom      |Initialisation goal                 |
| toplevel   | --tt   ||     atom      |Prolog toplevel goal                |
|_init_file___|--ff___||_____atom______|Personal_initialisation_file________||||||
| class      |      |     atom      |If  runtime,  only  read  resources |
|            |      |               |from  the  state  (default).     If |
|            |      |               |kernel,  lock  all   predicates  as |

|            |      |               |system predicates  If  development, |
|            |      |               |save  the   predicates   in   their |
|            |      |               |current  state  and  keep   reading |
|            |      |               |resources  from  their  source  (if |
|            |      |               |present).  See also resource/3.     |
| autoload   |      |     bool      |If true, run autoload/0 first       |
| map        |      |     file      |File to write info on dump          |
| op         |      | save/standard |Save operator declarations?         |

| stand_alone |     |     bool      |Include the emulator in the state   |
| emulator   |      |     file      |Emulator attached  to  the  (stand- |
|            |      |               |alone) executable.  Default  is the |
|____________|______|_______________|running_emulator.___________________|

          Table 6.1:  <_K_e_y> = <_V_a_l_u_e> pairs for qsave_program/2

    Before writing thedata tofile, qsave_program/2will runautoload/0 toall required
    autoloading the systemcan discover. Seeautoload/0.

    Provided the application doesnot require anyof the Prolog librariesto be loadedat
    runtime, the only filefrom the SWI-Prolog developmentenvironment required is the
    emulator itself. Theemulator may bebuilt intwo flavours. Thedefault is the_d_e_v_e_l_-
    _o_p_m_e_n_t _e_m_u_l_a_t_o_r. The _r_u_n_t_i_m_e _e_m_u_l_a_t_o_ris similar, butlacks thetracer.

    If theoption stand_alone(on)is present,the emulatoris thefirst partof thestate. If
    the emulatoris startedit willtest whethera boot-file(state) isattached tothe emulator
    itself andload this state.Provided theapplication hasall librariesloaded, theresulting
    executable is completelyindependent of theruntime environment orlocation where it
    was build.

    See also section2.10.2.3.


qqssaavvee__pprrooggrraamm((_+_F_i_l_e))
    Equivalent to qsave_program(File, []).


aauuttoollooaadd
    Check thecurrent Prologprogram forpredicates thatare referred to,are undefinedand
    have a definitionin theProlog library. Loadthe appropriate libraries.

    This predicateis used byqsave_program/[1,2]to ensurethe savedstate willnot de-
    pend onone of thelibraries. Thepredicate autoload/0will findall ddiirreeccttreferences
    to predicates. Itdoes notfind predicatesreferenced viameta-predicates. The predicate
    log/2 is definedin thelibrary(quintus) to providea quintuscompatible means tocom-
    pute the naturallogarithm of anumber. The following programwill behave correctly
    if its stateis executedin an environmentwhere thelibrary(quintus) is notavailable:

    logtable(From, To) :-
            From > To, !.
    logtable(From, To) :-
            log(From, Value),
            format('~d~t~8|~2f~n', [From, Value]),
            F is From + 1,
            logtable(F, To).

    However,  thefollowing implementation refers to log/2 through the meta-predicate
    maplist/3.  Autoload willnot be able tofind the reference. This problem may be
    fixed either byloading themodule libtary(quintus) explicitlyor userequire/1 totell
    the system thatthe predicatelog/2 is requiredby thismodule.

    logtable(From, To) :-
            findall(X, between(From, To, X), Xlist),
            maplist(log, Xlist, SineList),
            write_table(Xlist, SineList).

    write_table([], []).
    write_table([I|IT], [V|VT]) :-
            format('~d~t~8|~2f~n', [I, V]),
            write_table(IT, VT).


vvoollaattiillee _+_N_a_m_e_/_A_r_i_t_y_, _._._.
    Declare that the clausesof specified predicates shouldnnoott be savedto the program.
    The volatiledeclaration isnormally usedto avoidthat theclauses ofdynamicpredicates
    that represent datafor thecurrent session issaved inthe state file.


66..11 LLiimmiittaattiioonnss ooff qqssaavvee__pprrooggrraamm

There arethree areasthat require specialattention whenusing qsave_program/[1,2].

  o If theprogram isan embeddedProlog applicationor usesthe foreignlanguage interface,
    care hasto betakento restorethe appropriateforeigncontext. See section6.2for details.

  o If theprogram uses directives(:- goal. lines)that performother actionsthen setting
    predicate attributes(dynamic, volatile,etc.) orloading files(consult, etc.),the directive
    may need tobe prefixedwith initialization/1.

  o Database referencesas returnedby clause/3,recorded/3, etc. arenot preservedand
    may thus notbe partof the databasewhen saved.


66..22 RRuunnttiimmeess aanndd FFoorreeiiggnn CCooddee

Someapplications mayneed touse theforeign languageinterface. Objectcode isby definition
machine-dependent andthus cannotbe part ofthe savedprogram file.

To complicatethe mattereven further thereare variousways of loadingforeign code:

  o _U_s_i_n_g _t_h_e _l_i_b_r_a_r_y_(_s_h_l_i_b_) _p_r_e_d_i_c_a_t_e_s
    This is thepreferred wayof dealing withforeign code. Itloads quickly andensures an
    acceptable level ofindependence between theversions of theemulator and theforeign
    code loaded. Itworkson Unixmachines supportingsharedlibraries andlibrary functions
    to load them. Most modernUnixes, as well asWin32 (Windows 95/NT)satisfy this
    constraint.

  o _S_t_a_t_i_c _l_i_n_k_i_n_g
    This mechanismworks onall machines, butgenerally requiresthe sameC-compiler and
    linker to beused forthe external codeas isused to buildSWI-Prolog itself.

To makea runtime executable thatcan run onmultiple platforms onemust make runtime
checksto findthe correctway oflinking. Supposewe havea source-filemyextension defining
the installationfunction install().

If thisfile iscompiled intoa shared library,load_foreign_library/1will loadthis library
and call theinstallation function to initialise theforeign code.  If itis loaded as a static
extension, defineinstall() asthe predicate install/0:

static foreign_t
pl_install()
{ install();

  PL_succeed;
}

PL_extension PL_extensions [] =
{
/*{ "name",     arity,  function,       PL_FA_<flags> },*/

  { "install",  0,      pl_install,     0 },
  { NULL,       0,      NULL,           0 }     /* terminating line */
};

Now, usethe followingProlog code toload theforeign library:

load_foreign_extensions :-
        current_predicate(install, install), !, % static loaded
        install.
load_foreign_extensions :-                      % shared library
        load_foreign_library(foreign(myextension)).

:- initialization load_foreign_extensions.

The path aliasforeign is defined by file_search_path/2.  By defaultit searches the
directories <_h_o_m_e>/lib/<_a_r_c_h>and<_h_o_m_e>/lib. The application can specify additional
rules forfile_search_path/2.


66..33 UUssiinngg pprrooggrraamm rreessoouurrcceess

A _r_e_s_o_u_r_c_e is verysimilar to a file. Resources however can be represented in twodif-
ferent formats: on files,  aswell as part of the resource _a_r_c_h_i_v_e of a saved-state (see
qsave_program/2).

A resourcehas a _n_a_m_eand a _c_l_a_s_s. The_s_o_u_r_c_e data ofthe resource isa file. Resources
are declaredby declaringthe predicate resource/3. Theyare accessedusing the predicate
open_resource/3.

Before goinginto details, letus start withan example. Short textscan easily beexpressed
in Prolog sourcecode, butlong texts are cumbersome.  Assumeour application defines a
command `help'that printsa helptextto thescreen. We putthe contentof the helptextinto
a filecalled help.txt.The followingcode implements ourhelp commandsuch thathelp.txt
is incorperatedinto theruntime executable.

resource(help, text, 'help.txt').

help :-
        open_resource(help, text, In),
        copy_stream(In, user_output),
        close(In).

copy_stream(In, Out) :-
        get0(In, C),
        copy_stream(C, In, Out).

copy_stream(-1, _, _) :- !.
copy_stream(C, In, Out) :-
        put(Out, C),
        get0(In, C2),
        copy_stream(C2, In, Out).

Thepredicate help/0opens theresource asaProlog stream. Ifwe areexecutingthis fromthe
development environment,this will actuallyreturn a streamto the gelp.txtitself. When
executed fromthe saved-state, thestream willactually be astream opened onthe program
resource file,taking careof the offsetand lengthof the resource.


66..33..11 PPrreeddiiccaatteess DDeeffiinniittiioonnss


rreessoouurrccee((_+_N_a_m_e_, _+_C_l_a_s_s_, _+_F_i_l_e_S_p_e_c))
    This predicate is definedas a dynamic predicatein the moduleuser.  Clausesfor it
    may be defined inany module, including theuser module. _N_a_m_e is the nameof the
    resource (an atom).  Aresource name may contain allcharacters, except for $ and
    :, which are reservedfor internal usage bythe resource library. _C_l_a_s_s describes the
    what kind ofobject we are dealingwith. In the currentimplementation, it isjust an
    atom.  _F_i_l_e_S_p_e_c is afile specification that may exploitfile_search_path/2 (see
    absolute_file_name/2).

    Normally, resourcesare definedas unitclauses(facts), butthe definitionofthis predicate
    can also imply rules.  Forproper generation of the saved state generation, itmust
    be possible to enumeratethe available resources bycalling this predicatewith all its
    arguments unbound.

    Dynamic rulescan beuseful toturn allfilesin acertain directoryinto resources,without
    specifying a resources for eachfile.  For example,assume the file_search_path/2
    icons refersto theresource directorycontaining (XPM)icons. The followingdefinition
    makes all theseimages availableas resources:

    resource(Name, image, icons(XpmName)) :-
            atom(Name), !,
            file_name_extension(Name, xpm, XpmName).
    resource(Name, image, XpmFile) :-
            var(Name),
            absolute_file_name(icons(.), [type(directory)], Dir)
            concat(Dir, '/*.xpm', Pattern),
            expand_file_name(Pattern, XpmFiles),
            member(XpmFile, XpmFiles).


ooppeenn__rreessoouurrccee((_+_N_a_m_e_, _?_C_l_a_s_s_, _-_S_t_r_e_a_m))
    Opens the resourcespecified by _N_a_m_eand _C_l_a_s_s. Ifthe latter isa variable, itwill be
    unified tothe classof thefirst resourcefound thathas tehespecified _N_a_m_e.If successful,
    _S_t_r_e_a_m becomes ahandle toa binary inputstream, providingaccess to thecontent of
    the resource.

    The predicate open_resource/3 first checks resource/3. When succesful it will
    open the returnedresource source-file. Otherwiseit will lookin theprograms resource
    database. When creatinga saved-state,the systemnormally savestheresource contents
    into the resourcearchive, butdoes not savethe resourceclauses.

    This  way, the development environment uses the files (and modifications  to the
    resource/3 declarations and/or files containing resourceinfo thus immediately af-
    fect the running environment, whilethe runtime system quicklyaccesses the system
    resources.


66..33..22 TThhee plrc pprrooggrraamm

The utilityprogram plrc can beused to examineand manipulate the contentsof a SWI-
Prolog resourcefile. The optionsare inspiredby the Unixar program. Thebasic command
is:

% plrc option resource-file member ...

The optionsare describedbelow.

ll
    List contents ofthe archive.

xx
    Extract named (orall) membersof the archiveinto thecurrent directory.

aa
    Add files to the archive.  Ifthe archive already contains a member with thesame
    name, the contents is replaced. Anywhere in thesequence of members, the options
    --class=_c_l_a_s_s and --encoding=_e_n_c_o_d_i_n_gmay appear. They affectthe class and
    encoding of subsequentfiles. The initialclass isdata and encodingnone.

dd
    Delete named membersfrom thearchive.

This commandis alsodescribed in thepl(1) Unixmanual page.


66..44 FFiinnddiinngg AApppplliiccaattiioonn ffiilleess

If your application uses files that are not part of the saved program such as database
files, configuration files,etc., the runtime versionhas to beable to locate thesefiles.  The
file_search_path/2mechanism incombination with the-palias command-line argument
is thepreferred wayto locateruntime files. Thefirst stepis todefine analias forthe toplevel
directory ofyour application. Wewill callthis directory gnatdirin ourexamples.

A good place forstoring data associated with SWI-Prolog runtime systems isbelow the
emulator's home-directory. swi is apredefined alias for thisdirectory.  Thefollowing is a
useful defaultdefinition forthe search path.

user:file_search_path(gnatdir, swi(gnat)).

The applicationshould locate allfiles using absolute_file_name. Suppose gnatdircontains a
file config.plto definelocal configuration. Thenuse the codebelow toload thisfile:

configure_gnat :-
        (   absolute_file_name(gnatdir('config.pl'), ConfigFile)
            ->  consult(ConfigFile)
            ;   format(user_error, 'gnat: Cannot locate config.pl~n'),
            halt(1)
            ).


66..44..11 PPaassssiinngg aa ppaatthh ttoo tthhee aapppplliiccaattiioonn

Suppose the system administrator has installed theSWI-Prolog runtime environment in
/usr/local/lib/rt-pl-3.2.0. A user wantsto install gnat, butgnat will lookfor its
configuration in/usr/local/lib/rt-pl-3.2.0/gnat wherethe user cannotwrite.

The userdecides to installthe gnat runtimefiles in /users/bob/lib/gnat. Forone-time
usage, theuser maydecide to startgnat usingthe command:

% gnat -p gnatdir=/users/bob/lib/gnat


66..55 TThhee RRuunnttiimmee EEnnvviirroonnmmeenntt


66..55..11 TThhee RRuunnttiimmee EEmmuullaattoorr

Thesources maybe usedto builttwo versionsof theemulator. By default,the _d_e_v_e_l_o_p_m_e_n_t
_e_m_u_l_a_t_o_r isbuilt. This emulatorcontains allfeatures for interactivedevelopment ofProlog
applications. If thesystem is configured using--enable-runtime, make(1) willcreate a
_r_u_n_t_i_m_e _v_e_r_s_i_o_n ofthe emulator.This emulator isequivalent tothe developmentversion,
except forthe followingfeatures:

  o _N_o _i_n_p_u_t _e_d_i_t_i_n_g
    The GNU library-lreadline thatprovides EMACScompatible editingof input lines
    will not belinked tothe system.

  o _N_o _t_r_a_c_e_r
    The tracer andall itsoptions are removed,making thesystem a littlefaster too.

  o _N_o _p_r_o_f_i_l_e_r
    profile/3 and friendsare not supported.This saves somespace and providesbetter
    performance.

  o _N_o _i_n_t_e_r_r_u_p_t
    Keyboard interrupt (Control-Cnormally) is notrebound and willnormally terminate
    the application.

  o _c_u_r_r_e_n_t___p_r_o_l_o_g___f_l_a_g_(_r_u_n_t_i_m_e_, _t_r_u_e_) _s_u_c_c_e_e_d_s
    This may be used toverify your application is running inthe runtime environment
    rather than thedevelopment environment.

  o clause/[2,3] _d_o _n_o_t _w_o_r_k _o_n _s_t_a_t_i_c _p_r_e_d_i_c_a_t_e_s
    This prolog-flag inhibits listing your program. It is only a very limited protection
    however.

The followingfragment isan examplefor buildingthe runtimeenvironment in\env{HOME}/
lib/rt-pl-3.2.0. If possible,the shared-library interfaceshould be configuredto ensure
it canserve alarge number ofapplications.

% cd pl-3.2.0
% mkdir runtime
% cd runtime
% ../src/configure --enable-runtime --prefix=$HOME
% make
% make rt-install

The runtimedirectory contains thecomponents listed below. Thisdirectory may be tar'ed
and shippedwith yourapplication.

               ___________________________________________
               |_README.RT____|Info_on_theruntime_environment_|
               |_bin/<_a_r_c_h>/pl|The_emulator_itself________   |

               |_man/pl.1_____|Manual_page_forpl__________  |
               |_swipl________|pointer_to_thehome_directory(.)_|
               | lib/         |directory for sharedlibraries    |
               |_lib/<_a_r_c_h>/__|machine-specific_shared_libraries_|


CChhaapptteerr 77..  HHAACCKKEERRSS CCOORRNNEERR

This appendixdescribes anumber of predicateswhich enable theProlog userto inspect the
Prolog environmentand manipulate (or evenredefine) the debugger. Theycan be used as
entry pointsfor experimentswith debugging toolsfor Prolog. Thepredicates describedhere
shouldbe handledwith somecare asit iseasy tocorrupt theconsistency ofthe Prologsystem
by misusingthem.


77..11 EExxaammiinniinngg tthhee EEnnvviirroonnmmeenntt SSttaacckk


pprroolloogg__ccuurrrreenntt__ffrraammee((_-_F_r_a_m_e))
    Unify _F_r_a_m_ewith aninteger providingareference tothe parentofthe currentlocal stack
    frame. A pointerto thecurrentlocal framecannot beprovided asthepredicate succeeds
    deterministically and thereforeits frameis destroyed immediatelyafter succeeding.


pprroolloogg__ffrraammee__aattttrriibbuuttee((_+_F_r_a_m_e_, _+_K_e_y_, _-_V_a_l_u_e))
    Obtain information about the localstack frame _F_r_a_m_e. _F_r_a_m_e is a frame reference
    as obtained throughprolog_current_frame/1,prolog_trace_interception/4or
    this predicate. Thekey values aredescribed below.

    aalltteerrnnaattiivvee
         _V_a_l_u_e isunified withan integer referenceto the localstack frame inwhich exe-
         cution isresumed if thegoal associated with_F_r_a_m_e fails. Fails ifthe frame has
         noalternative frame.

    hhaass__aalltteerrnnaattiivveess
         _V_a_l_u_eis unified withtrue if_F_r_a_m_e still isa candidatefor backtracking. false
         otherwise.

    ggooaall
         _V_a_l_u_eis unified withthe goalassociated with_F_r_a_m_e. If thedefinition moduleof
         theactive predicate isnot userthe goal isrepresented as<_m_o_d_u_l_e>:<_g_o_a_l>. Do
         notinstantiate variables inthis goalunless you kknnoowwwhat youare doing!

    ccllaauussee
         _V_a_l_u_e is unified with a reference to the currently running clause.  Fails if
         the current goal isassociated with a foreign (C) defined predicate.  See also
         nth_clause/3and clause_property/2.

    lleevveell
         _V_a_l_u_eis unified withthe recursionlevel of_F_r_a_m_e. The toplevel frameis atlevel
         `0'.

    ppaarreenntt
         _V_a_l_u_eis unifiedwith anintegerreference tothe parentlocal stackframe of_F_r_a_m_e.
         Failsif _F_r_a_m_e isthe topframe.

    ccoonntteexxtt__mmoodduullee
         _V_a_l_u_eis unified withthe nameof the contextmodule ofthe environment.

    ttoopp
         _V_a_l_u_e isunified withtrue if _F_r_a_m_eis the topProlog goalfrom a recursivecall
         backfrom the foreignlanguage. false otherwise.

    hhiiddddeenn
         _V_a_l_u_eis unified withtrue ifthe frameis hidden fromthe user,either because a
         parenthas the hide-childsattribute (allsystem predicates), orthe systemhas no
         trace-meattribute.

    ppcc
         _V_a_l_u_eis unified withthe program-pointer savedon behalveof the parent-goalif
         theparent-goal is notowned bya foreign predicate.

    aarrgguummeenntt((_N))
         _V_a_l_u_eis unifiedwith the_N-th slotof theframe. Argument 1is thefirst argument
         ofthe goal. Arguments abovethe arityrefer to localvariables. Fails silentlyif _N
         isout of range.


77..22 IInntteerrcceeppttiinngg tthhee TTrraacceerr


pprroolloogg__ttrraaccee__iinntteerrcceeppttiioonn((_+_P_o_r_t_, _+_F_r_a_m_e_, _+_P_C_, _-_A_c_t_i_o_n))
    Dynamic predicate,normally not defined.This predicateis calledfrom theSWI-Prolog
    debugger just before it would showa port.  Ifthis predicate succeeds the debugger
    assumes the traceaction has beentaken care ofand continues execution asdescribed
    by _A_c_t_i_o_n. Otherwisethe normal Prologdebugger actionsare performed.

    _P_o_r_t is one ofcall, redo, exit, failor unify. _F_r_a_m_e is an integerreference to
    the current localstack frame. _P_C isthe currentvalue of theprogram-counter, relative
    to the startof the currentclause, or 0if it isinvalid, forexample because thecurrent
    frame runs aforeign predicate, orno clause hasbeen selected yet. _A_c_t_i_o_n shouldbe
    unified with one ofthe atoms continue (justcontinue execution), retry (retrythe
    current goal) orfail (force thecurrent goalto fail). Leaving ita variableis identical
    to continue.

    Together with thepredicates described insection 3.41and the otherpredicates ofthis
    chapter this predicate enablesthe Prolog user todefine a complete newdebugger in
    Prolog.  Besides this it enablesthe Prolog programmer monitor the execution of a
    program. The examplebelow records allgoals trappedby the tracerin thedatabase.

    prolog_trace_interception(Port, Frame, _PC, continue) :-
            prolog_frame_attribute(Frame, goal, Goal),
            prolog_frame_attribute(Frame, level, Level),
            recordz(trace, trace(Port, Level, Goal)).

    To trace theexecution of`go' this waythe followingquery should begiven:

    ?- trace, go, notrace.


pprroolloogg__sskkiipp__lleevveell((_-_O_l_d_, _+_N_e_w))
    Unify _O_l_dwith theold valueof `skiplevel'and thanset thislevel accordingto _N_e_w.New
    is an integer,or the specialatom very_deep(meaning don't skip).The `skip level'is
    a global variableof theProlog systemthat disablesthe debugger onall recursionlevels
    deeper than thelevel of thevariable. Used toimplement the traceoptions `skip' (sets
    skip level tothe level ofthe frame) and`up' (sets skiplevel to thelevel of theparent
    frame (i.e. thelevel ofthis frame minus1).


pprroolloogg__lliisstt__ggooaall((_:_G_o_a_l))
    Hook, normally notdefined.  Thishook is calledby the 'L'command of thetracer in
    the module user tolist the currentlycalled predicate. This hook maybe defined to
    list only relevantclauses of theindicated _G_o_a_l and/orshow the actualsource-code in
    an editor. Seealso portray/1 andmultifile/1.


77..33 HHooookkss uussiinngg tthhee exception/3 pprreeddiiccaattee

This sectiondescribes thepredicate exception/3, whichmay bedefined by theuser inthe
module user asa multifile predicate.  Unlikethe name suggests, this isactually a _h_o_o_k
predicate. Exceptions arehandled by theISO predicates catch/3and throw/1. They all
frames createdafter thematching catch/3 tobe discardedimmediately.

The predicateexception/3 is calledby thekernel on acouple of events,allowing the user
to alterthe behaviouron some predefinedevents.


eexxcceeppttiioonn((_+_E_x_c_e_p_t_i_o_n_, _+_C_o_n_t_e_x_t_, _-_A_c_t_i_o_n))
    Dynamic predicate, normally not defined. Called bythe Prolog system on run-time
    exceptions.  Currently exception/3is only used for trappingundefined predicates.
    Future versions might handle signalhandling, floating exceptions and otherruntime
    errors via thismechanism. The valuesfor _E_x_c_e_p_t_i_o_nare described below.

    uunnddeeffiinneedd__pprreeddiiccaattee
         If _E_x_c_e_p_t_i_o_n is undefined_predicate _C_o_n_t_e_x_t is instantiated to a term
         _N_a_m_e/_A_r_i_t_y. _N_a_m_e refersto the nameand _A_r_i_t_y tothe arity ofthe undefined
         predicate. Ifthe definitionmodule of thepredicate isnot _u_s_e_r, _C_o_n_t_e_x_twill be
         ofthe form<_M_o_d_u_l_e>:<_N_a_m_e>/<_A_r_i_t_y>.If thepredicate failsProlog will generate
         an esistence_errorexception. If thepredicate succeeds it shouldinstantiate
         the lastargument either to theatom fail to tell Prologto fail the predicate,
         the atomretry totell Prolog toretry the predicateor error tomake the sys-
         tem generatean exception. Theaction retry onlymakes sense ifthe exception
         handlerhas defined thepredicate.


77..44 RReeaaddlliinnee IInntteerraaccttiioonn

The following predicates are available ifcurrent_prolog_flag(readline, true) suc-
ceeds. Theyallow fordirectinteraction withthe GNUreadline library.See alsoreadline(3)


rrll__rreeaadd__iinniitt__ffiillee((_+_F_i_l_e))
    Read a readlineinitialisation file. Readlineby default reads~/.inputrc. This predi-
    cate may beused toread alternative readlineinitialisation files.


rrll__aadddd__hhiissttoorryy((_+_L_i_n_e))
    Add a lineto theControl-P/Control-N history systemof thereadline library.


CChhaapptteerr 88..  SSUUMMMMAARRYY


88..11 PPrreeddiiccaatteess

The predicate summaryis used by theProlog predicate apropos/1 tosuggest predicates
from akeyword.
 !/0                      Cut (discardchoicepoints)

 !/1                      Cut block.See block/3
 ,/2                      Conjunction ofgoals
 ->/2                     If-then-else
 *->/2                    Soft-cut
 ./2                      Consult. Alsolist constructor
 ;/2                      Disjunction ofgoals. Same as|/2
 </2                      Arithmetic smaller

 =/2                      Unification
 =../2                    \Univ." Termto list conversion
 =:=/2                    Arithmetic equal
 =</2                     Arithmetic smalleror equal
 ==/2                     Identical
 =@=/2                    Structural identical
 =\=/2                    Arithmetic notequal
 >/2                      Arithmetic larger

 >=/2                     Arithmetic largeror equal
 @</2                     Standard ordersmaller
 @=</2                    Standard ordersmaller orequal
 @>/2                     Standard orderlarger
 @>=/2                    Standard orderlarger orequal
 \+/1                     Negation byfailure. Same asnot/1
 \=/2                     Not unifyable

 \==/2                    Not identical
 \=@=/2                   Not structuralidentical
 ^/2                      Existential quantification(bagof/3, setof/3)
 |/2                      Disjunction ofgoals. Same as;/2
 abolish/1                Remove predicatedefinition fromthe database
 abolish/2                Remove predicatedefinition fromthe database
 abort/0                  Abort execution,return totop level
 absolute_file_name/2     Get absolutepath name

 absolute_file_name/3     Get absolutepath namewith options
 access_file/2            Check accesspermissions ofa file
 append/1                 Append toa file
 append/3                 Concatenate lists
 apply/2                  Call goalwith additionalarguments
 apropos/1                library(online_help)Show relatedpredicates and manualsections
 arg/3                    Access argumentof aterm

 arithmetic_function/1    Register anevaluable function
 assert/1                 Add aclause tothe database
 assert/2                 Add aclause tothe database, givereference
 asserta/1                Add aclause tothe database (first)
 asserta/2                Add aclause tothe database (first)
 assertz/1                Add aclause tothe database (last)
 assertz/2                Add aclause tothe database (last)
 attach_console/0         Attach I/Oconsole tothread

 at_end_of_stream/0       Test forend offile on input
 at_end_of_stream/1       Test forend offile on stream
 at_halt/1                Register goalto runat halt/1
 at_initialization/1      Register goalto runat start-up
 atom/1                   Type checkfor anatom
 atom_chars/2             Convert betweenatom andlist of characters
 atom_codes/2             Convert betweenatom andlist of ASCIIvalues

 atom_length/2            Determine lengthof anatom
 atom_prefix/2            Test forstart ofatom
 atom_to_term/3           Convert betweenatom andterm
 atomic/1                 Type checkfor primitive
 autoload/0               Autoload allpredicates now
 bagof/3                  Find allsolutions toa goal
 between/3                Integer rangechecking/generating
 block/3                  Start ablock (`catch'/`throw')

 break/0                  Start interactivetoplevel
 call/1                   Call agoal
 call/[2..]               Call withadditional arguments
 call_shared_object_function/2UNIX: CallC-function inshared (.so) file
 call_with_depth_limit/3  Prove goalwith boundeddepth
 catch/3                  Call goal,watching forexceptions
 char_code/2              Convert betweenatom andASCII value

 char_type/2              Classify characters
 character_count/2        Get characterindex ona stream
 chdir/1                  Change workingdirectory
 checklist/2              Invoke goalon allmembers of alist
 clause/2                 Get clausesof apredicate
 clause/3                 Get clausesof apredicate
 clause_property/2        Get propertiesof aclause
 close/1                  Close stream

 close/2                  Close stream(forced)
 close_dde_conversation/1 Win32: CloseDDE channel
 close_shared_object/1    UNIX: Closeshared library(.so file)
 compare/3                Compare, usinga predicateto determine theorder
 compiling/0              Is thisa compilationrun?
 compound/1               Test forcompound term
 atom_concat/3            Append twoatoms

 code_type/2              Classify acharacter-code
 concat_atom/2            Append alist ofatoms
 concat_atom/3            Append alist ofatoms with separator
 consult/1                Read (compile)a Prologsource file
 context_module/1         Get contextmodule ofcurrent goal
 convert_time/8           Break timestamp intofields
 convert_time/2           Convert timestamp tostring
 copy_stream_data/2       Copy alldata fromstream to stream

 copy_stream_data/3       Copy nbytes fromstream to stream
 copy_term/2              Make acopy ofa term
 current_arithmetic_function/1Examine evaluablefunctions
 current_atom/1           Examine existingatoms
 current_flag/1           Examine existingflags
 current_foreign_library/2library(shlib) Examineloaded sharedlibraries (.so files)
 current_format_predicate/2Enumerate user-definedformat codes

 current_functor/2        Examine existingname/arity pairs
 current_input/1          Get currentinput stream
 current_key/1            Examine existingdatabase keys
 current_module/1         Examine existingmodules
 current_module/2         Examine existingmodules
 current_mutex/3          Examine existingmutexes
 current_op/3             Examine currentoperator declarations
 current_output/1         Get thecurrent outputstream

 current_predicate/2      Examine existingpredicates
 current_signal/3         Current softwaresignal mapping
 current_stream/3         Examine openstreams
 current_thread/2         Examine Prologthreads
 dde_current_connection/2 Win32: Examineopen DDE connections
 dde_current_service/2    Win32: ExamineDDE services provided
 dde_execute/2            Win32: Executecommand on DDEserver

 dde_register_service/2   Win32: Becomea DDE server
 dde_request/3            Win32: Makea DDE request
 dde_poke/3               Win32: POKEoperation on DDEserver
 dde_unregister_service/1 Win32: Terminatea DDE service
 debug/0                  Test fordebugging mode
 debugging/0              Show debuggerstatus
 default_module/2         Get thedefault modulesof a module
 delete/3                 Delete allmatching membersfrom a list

 delete_file/1            Remove afile fromthe file system
 discontiguous/1          Indicate distributeddefinition ofa predicate
 dwim_match/2             Atoms matchin \DoWhat I Mean"sense
 dwim_match/3             Atoms matchin \DoWhat I Mean"sense
 dwim_predicate/2         Find predicatein \DoWhat I Mean"sense
 dynamic/1                Indicate predicatedefinition maychange
 edit/1                   Edit afile

 ensure_loaded/1          Consult afile ifthat has notyet beendone
 erase/1                  Erase adatabase recordor clause
 exception/3              (hook) Handleruntime exceptions
 exists_directory/1       Check existenceof directory
 exists_file/1            Check existenceof file
 exit/2                   Exit fromnamed block. Seeblock/3
 expand_answer/2          Expand answerof query
 expand_file_name/2       Wildcard expansionof filenames

 expand_file_search_path/2Wildcard expansionof filepaths
 expand_goal/2            Compiler: expandgoal in clause-body
 expand_query/4           Expanded enteredquery
 expand_term/2            Compiler: expandread term intoclause(s)
 explain/1                library(explain) Explainargument
 explain/2                library(explain) 2ndargument isexplanation of first
 export/1                 Export apredicate froma module

 export_list/2            List ofpublic predicatesof a module
 fail/0                   Always false
 fail/1                   Immediately failnamed block. Seeblock/3
 current_prolog_flag/2    Get systemconfiguration parameters
 file_base_name/2         Get filepart ofpath
 file_directory_name/2    Get directorypart ofpath
 file_name_extension/3    Add, removeor testfile extensions
 file_search_path/2       Define path-aliasesfor locatingfiles

 fileerrors/2             Do/Don't warnon fileerrors
 findall/3                Find allsolutions toa goal
 flag/3                   Simple globalvariable system
 flatten/2                Transform nestedlist intoflat list
 float/1                  Type checkfor afloating point number
 flush/0                  Output pendingcharacters oncurrent stream
 flush_output/1           Output pendingcharacters onspecified stream

 forall/2                 Prove goalfor allsolutions of anothergoal
 foreign_file/1           Examine loadedforeign files
 format/1                 Formatted output
 format/2                 Formatted outputwith arguments
 format/3                 Formatted outputon astream
 format_predicate/2       Program format/[1,2]
 free_variables/2         Find unboundvariables ina term
 functor/3                Get nameand arityof a termor constructa term

 garbage_collect/0        Invoke thegarbage collector
 garbage_collect_atoms/0  Invoke theatom garbagecollector
 gensym/2                 Generate uniqueatoms froma base
 get/1                    Read firstnon-blank character
 get/2                    Read firstnon-blank characterfrom a stream
 get0/1                   Read nextcharacter
 get0/2                   Read nextcharacter froma stream

 get_byte/1               Read nextbyte (ISO)
 get_byte/2               Read nextbyte froma stream (ISO)
 get_char/1               Read nextcharacter asan atom (ISO)
 get_char/2               Read nextcharacter froma stream (ISO)
 get_code/1               Read nextcharacter (ISO)
 get_code/2               Read nextcharacter froma stream (ISO)
 get_single_char/1        Read nextcharacter fromthe terminal
 get_time/1               Get currenttime

 getenv/2                 Get shellenvironment variable
 goal_expansion/2         Hook formacro-expanding goals
 ground/1                 Verify termholds nounbound variables
 halt/0                   Exit fromProlog
 halt/1                   Exit fromProlog withstatus
 hash_term/2              Hash-value ofground term
 help/0                   Give helpon help

 help/1                   Give helpon predicatesand show partsof manual
 ignore/1                 Call theargument, butalways succeed
 import/1                 Import apredicate froma module
 include/1                Include afile withdeclarations
 index/1                  Change clauseindexing
 initialization/1         Initialization directive
 int_to_atom/2            Convert frominteger toatom
 int_to_atom/3            Convert frominteger toatom (non-decimal)

 integer/1                Type checkfor integer
 interactor/0             Start newthread withconsole and toplevel
 intersection/3           Set intersection
 is/2                     Evaluate arithmeticexpression
 is_absolute_file_name/1  True ifarg definesan absolute path
 is_list/1                Type checkfor alist
 is_set/1                 Type checkfor aset

 keysort/2                Sort, usinga key
 last/2                   Last elementof alist
 leash/1                  Change portsvisited bythe tracer
 length/2                 Length ofa list
 library_directory/1      (hook) Directoriesholding Prologlibraries
 limit_stack/2            Limit stackexpansion
 line_count/2             Line numberon stream
 line_position/2          Character positionin lineon stream

 list_to_set/2            Remove duplicates
 listing/0                List programin currentmodule
 listing/1                List predicate
 load_files/2             Load sourcefiles withoptions
 load_foreign_library/1   library(shlib) Loadshared library(.so file)
 load_foreign_library/2   library(shlib) Loadshared library(.so file)
 make/0                   Reconsult allchanged sourcefiles

 make_fat_filemap/1       Win32: Createfile containing non-FATfilenames
 make_library_index/1     Create autoloadfile INDEX.pl
 maplist/3                Transform allelements ofa list
 member/2                 Element ismember ofa list
 memberchk/2              Deterministic member/2
 merge/3                  Merge twosorted lists
 merge_set/3              Merge twosorted sets
 message_hook/3           Intercept print_message/2

 meta_predicate/1         Quintus compatibility
 module/1                 Query/set currenttype-in module
 module/2                 Declare amodule
 module_transparent/1     Indicate modulebased metapredicate
 msort/2                  Sort, donot removeduplicates
 multifile/1              Indicate distributeddefinition ofpredicate
 mutex_create/1           Create athread-synchronisation device

 mutex_destroy/1          Destroy amutex
 mutex_lock/1             Become ownerof amutex
 mutex_trylock/1          Become ownerof amutex (non-blocking)
 mutex_unlock/1           Release ownershipof mutex
 mutex_unlock_all/0       Release ownershipof allmutexes
 name/2                   Convert betweenatom andlist of ASCIIcharacters
 nl/0                     Generate anewline
 nl/1                     Generate anewline ona stream

 nodebug/0                Disable debugging
 nonvar/1                 Type checkfor boundterm
 noprotocol/0             Disable loggingof userinteraction
 nospy/1                  Remove spypoint
 nospyall/0               Remove allspy points
 not/1                    Negation byfailure (argumentnot provable). Sameas \+/1
 notrace/0                Stop tracing

 notrace/1                Do notdebug argumentgoal
 nth0/3                   N-th elementof alist (0-based)
 nth1/3                   N-th elementof alist (1-based)
 nth_clause/3             N-th clauseof apredicate
 number/1                 Type checkfor integeror float
 number_chars/2           Convert betweennumber andone-char atoms
 number_codes/2           Convert betweennumber andASCII values
 numbervars/4             Enumerate unboundvariables ofa term usinga givenbase

 on_signal/3              Handle asoftware signal
 once/1                   Call agoal deterministically
 op/3                     Declare anoperator
 open/3                   Open afile (creatinga stream)
 open/4                   Open afile (creatinga stream)
 open_dde_conversation/3  Win32: OpenDDE channel
 open_null_stream/1       Open astream todiscard output

 open_resource/3          Open aprogram resourceas a stream
 open_shared_object/2     UNIX: Openshared library(.so file)
 open_shared_object/3     UNIX: Openshared library(.so file)
 peek_byte/1              Read bytewithout removing
 peek_byte/2              Read bytewithout removing
 peek_char/1              Read characterwithout removing
 peek_char/2              Read characterwithout removing
 peek_code/1              Read character-codewithout removing

 peek_code/2              Read character-codewithout removing
 phrase/2                 Activate grammar-ruleset
 phrase/3                 Activate grammar-ruleset (returningrest)
 please/3                 Query/change environmentparameters
 plus/3                   Logical integeraddition
 portray/1                (hook) Modifybehaviour ofprint/1
 portray_clause/1         Pretty printa clause

 predicate_property/2     Query predicateattributes
 predsort/3               Sort, usinga predicateto determine theorder
 preprocessor/2           Install apreprocessor beforethe compiler
 print/1                  Print aterm
 print/2                  Print aterm ona stream
 print_message/2          Print messagefrom (exception)term
 print_message_lines/3    Print messageto stream
 profile/3                Obtain executionstatistics

 profile_count/3          Obtain profileresults ona predicate
 profiler/2               Obtain/change statusof theprofiler
 prolog/0                 Run interactivetoplevel
 prolog_current_frame/1   Reference togoal's environmentstack
 prolog_edit:locate/2     Locate targetsfor edit/1
 prolog_edit:locate/3     Locate targetsfor edit/1
 prolog_edit:edit_source/1Call editorfor edit/1

 prolog_edit:edit_command/2Specify editoractivation
 prolog_edit:load/0       Load edit/1extensions
 prolog_file_type/2       Define meaningof fileextension
 prolog_frame_attribute/3 Obtain informationon agoal environment
 prolog_list_goal/1       Hook. Intercepttracer 'L' command
 prolog_load_context/2    Context informationfor directives
 prolog_skip_level/2      Indicate deepestrecursion totrace
 prolog_to_os_filename/2  Convert betweenProlog andOS filenames

 prolog_trace_interception/4library(user) Interceptthe Prologtracer
 prompt1/1                Change promptfor 1line
 prompt/2                 Change theprompt usedby read/1
 proper_list/1            Type checkfor list
 protocol/1               Make alog ofthe user interaction
 protocola/1              Append logof theuser interaction tofile
 protocolling/1           On whatfile isuser interaction logged

 put/1                    Write acharacter
 put/2                    Write acharacter ona stream
 put_byte/1               Write abyte
 put_byte/2               Write abyte ona stream
 put_char/1               Write acharacter
 put_char/2               Write acharacter ona stream
 put_code/1               Write acharacter-code
 put_code/2               Write acharacter-code ona stream

 qcompile/1               Compile sourceto QuickLoad File
 qsave_program/1          Create runtimeapplication
 qsave_program/2          Create runtimeapplication
 read/1                   Read Prologterm
 read/2                   Read Prologterm fromstream
 read_clause/1            Read clause
 read_clause/2            Read clausefrom stream

 read_history/6           Read usinghistory substitution
 read_link/3              Read asymbolic link
 read_term/2              Read termwith options
 read_term/3              Read termwith optionsfrom stream
 recorda/2                Record termin thedatabase (first)
 recorda/3                Record termin thedatabase (first)
 recorded/2               Obtain termfrom thedatabase
 recorded/3               Obtain termfrom thedatabase

 recordz/2                Record termin thedatabase (last)
 recordz/3                Record termin thedatabase (last)
 redefine_system_predicate/1Abolish systemdefinition
 rename_file/2            Change nameof file
 repeat/0                 Succeed, leavinginfinite backtrackpoints
 require/1                This filerequires thesepredicates
 reset_profiler/0         Clear statisticsobtained bythe profiler

 resource/3               Declare aprogram resource
 retract/1                Remove clausefrom thedatabase
 retractall/1             Remove unifyingclauses fromthe database
 reverse/2                Inverse theorder ofthe elements ina list
 same_file/2              Succeeds ifarguments referto same file
 see/1                    Change thecurrent inputstream
 seeing/1                 Query thecurrent inputstream
 seek/4                   Modify thecurrent positionin a stream

 seen/0                   Close thecurrent inputstream
 select/3                 Select elementof alist
 set_input/1              Set currentinput streamfrom a stream
 set_output/1             Set currentoutput streamfrom a stream
 set_prolog_flag/2        Define asystem feature
 set_stream/2             Set streamattribute
 set_stream_position/2    Seek streamto position

 set_tty/2                Set `tty'stream
 setarg/3                 Destructive assignmenton term
 setenv/2                 Set shellenvironment variable
 setof/3                  Find allunique solutionsto a goal
 sformat/2                Format ona string
 sformat/3                Format ona string
 shell/0                  Execute interactivesubshell
 shell/1                  Execute OScommand

 shell/2                  Execute OScommand
 show_profile/1           Show resultsof theprofiler
 size_file/2              Get sizeof afile in characters
 skip/1                   Skip tocharacter incurrent input
 skip/2                   Skip tocharacter onstream
 rl_add_history/1         Add lineto readline(3)history
 rl_read_init_file/1      Read readline(3)init file

 sleep/1                  Suspend executionfor specifiedtime
 sort/2                   Sort elementsin alist
 source_file/1            Examine currentlyloaded sourcefiles
 source_file/2            Obtain sourcefile ofpredicate
 source_location/2        Location oflast readterm
 spy/1                    Force traceron specifiedpredicate
 stack_parameter/4        Some systems:Query/Set runtime stackparameter
 statistics/0             Show executionstatistics

 statistics/2             Obtain collectedstatistics
 stream_property/2        Get streamproperties
 string/1                 Type checkfor string
 string_concat/3          atom_concat/3for strings
 string_length/2          Determine lengthof astring
 string_to_atom/2         Conversion betweenstring andatom
 string_to_list/2         Conversion betweenstring andlist of ASCII

 style_check/1            Change levelof warnings
 sub_atom/5               Take asubstring froman atom
 sublist/3                Determine elementsthat meetcondition
 subset/2                 Generate/check subsetrelation
 sub_string/5             Take asubstring froma string
 subtract/3               Delete elementsthat donot meet condition
 succ/2                   Logical integersuccessor relation
 swritef/2                Formatted writeon astring

 swritef/3                Formatted writeon astring
 tab/1                    Output numberof spaces
 tab/2                    Output numberof spaceson a stream
 tell/1                   Change currentoutput stream
 telling/1                Query currentoutput stream
 term_expansion/2         (hook) Convertterm beforecompilation
 term_to_atom/2           Convert betweenterm andatom

 thread_at_exit/1         Register goalto becalled at exit
 thread_create/3          Create anew Prologtask
 thread_exit/1            Terminate Prologtask withvalue
 thread_get_message/1     Wait formessage
 thread_join/2            Wait forProlog task-completion
 thread_peek_message/1    Test formessage inqueue
 thread_self/1            Get identifierof currentthread
 thread_send_message/2    Send messageto anotherthread

 thread_signal/2          Execute goalin anotherthread
 threads/0                List runningthreads
 throw/1                  Raise anexception (seecatch/3)
 time/1                   Determine timeneeded toexecute goal
 time_file/2              Get lastmodification timeof file
 tmp_file/2               Create atemporary filename
 told/0                   Close currentoutput

 trace/0                  Start thetracer
 trace/1                  Set trace-pointon predicate
 trace/2                  Set/Clear trace-pointon ports
 tracing/0                Query statusof thetracer
 trim_stacks/0            Release unusedmemory resources
 true/0                   Succeed
 tty_get_capability/3     Get terminalparameter
 tty_goto/2               Goto positionon screen

 tty_put/2                Write controlstring toterminal
 ttyflush/0               Flush outputon terminal
 union/3                  Union oftwo sets
 unify_with_occurs_check/2Logically soundunification
 unix/1                   OS interaction
 unknown/2                Trap undefinedpredicates
 unload_foreign_library/1 library(shlib) Detachshared library(.so file)

 unsetenv/1               Delete shellenvironment variable
 use_module/1             Import amodule
 use_module/2             Import predicatesfrom amodule
 var/1                    Type checkfor unboundvariable
 visible/1                Ports thatare visiblein the tracer
 volatile/1               Predicates thatare notsaved
 wait_for_input/3         Wait forinput withoptional timeout
 wildcard_match/2         Csh(1) stylewildcard match

 win_exec/2               Win32: spawnWindows task
 with_mutex/2             Run goalwhile holdingmutex
 write/1                  Write term
 write/2                  Write termto stream
 write_ln/1               Write term,followed bya newline
 write_canonical/1        Write aterm withquotes, ignore operators
 write_canonical/2        Write aterm withquotes, ignore operatorson astream

 write_term/2             Write termwith options
 write_term/3             Write termwith optionsto stream
 writef/1                 Formatted write
 writef/2                 Formatted writeon stream
 writeq/1                 Write term,insert quotes
 writeq/2                 Write term,insert quoteson stream


88..22 AArriitthhmmeettiicc FFuunnccttiioonnss

 */2                Multiplication
 **/2               Power function

 +/2                Addition
 -/1                Unary minus
 -/2                Subtraction
 //2                Division
 ///2               Integer division
 /\/2               Bitwise and
 <</2               Bitwise leftshift
 >>/2               Bitwise rightshift

 ./2                List ofone character: charactercode
 \/1                Bitwise negation
 \//2               Bitwise or
 ^/2                Power function
 abs/1              Absolute value
 acos/1             Inverse (arc)cosine
 asin/1             Inverse (arc)sine

 atan/1             Inverse (arc)tangent
 atan/2             Rectangular topolar conversion
 ceil/1             Smallest integerlarger thanarg
 ceiling/1          Smallest integerlarger thanarg
 cos/1              Cosine
 cputime/0          Get CPUtime
 e/0                Mathematical constant
 exp/1              Exponent (basee)

 float/1            Explicitly convertto float
 float_fractional_part/1Fractional partof afloat
 float_integer_part/1Integer partof afloat
 floor/1            Largest integerbelow argument
 integer/1          Round tonearest integer
 log/1              Natural logarithm
 log10/1            10 baselogarithm

 max/2              Maximum oftwo numbers
 min/2              Minimum oftwo numbers
 mod/2              Remainder ofdivision
 random/1           Generate randomnumber
 rem/2              Remainder ofdivision
 round/1            Round tonearest integer
 truncate/1         Truncate floatto integer
 pi/0               Mathematical constant

 sign/1             Extract signof value
 sin/1              Sine
 sqrt/1             Square root
 tan/1              Tangent
 xor/2              Bitwise exclusiveor


88..33 OOppeerraattoorrss

 $                   1    fx  Bind toplevelvariable
 ^                 200   xfy  Predicate
 ^                 200   xfy  Arithmetic function
 mod               300   xfx  Arithmetic function
 *                 400   yfx  Arithmetic function
 /                 400   yfx  Arithmetic function
 //                400   yfx  Arithmetic function
 <<                400   yfx  Arithmetic function

 >>                400   yfx  Arithmetic function
 xor               400   yfx  Arithmetic function
 +                 500    fx  Arithmetic function
 -                 500    fx  Arithmetic function
 ?                 500    fx  XPCE: obtainer
 \                 500    fx  Arithmetic function
 +                 500   yfx  Arithmetic function

 -                 500   yfx  Arithmetic function
 /\                500   yfx  Arithmetic function
 \/                500   yfx  Arithmetic function
 :                 600   xfy  module:term separator
 <                 700   xfx  Predicate
 =                 700   xfx  Predicate
 =..               700   xfx  Predicate
 =:=               700   xfx  Predicate

 <                 700   xfx  Predicate
 ==                700   xfx  Predicate
 =@=               700   xfx  Predicate
 =\=               700   xfx  Predicate
 >                 700   xfx  Predicate
 >=                700   xfx  Predicate
 @<                700   xfx  Predicate

 @=<               700   xfx  Predicate
 @>                700   xfx  Predicate
 @>=               700   xfx  Predicate
 is                700   xfx  Predicate
 \=                700   xfx  Predicate
 \==               700   xfx  Predicate
 =@=               700   xfx  Predicate
 not               900    fy  Predicate

 \+                900    fy  Predicate
 ,                1000   xfy  Predicate
 ->               1050   xfy  Predicate
 *->              1050   xfy  Predicate
 ;                1100   xfy  Predicate
 |                1100   xfy  Predicate
 discontiguous    1150    fx  Predicate

 dynamic          1150    fx  Predicate
 module_transparent1150   fx  Predicate
 multifile        1150    fx  Predicate
 volatile         1150    fx  Predicate
 initialization   1150    fx  Predicate
 :-               1200    fx  Introduces adirective
 ?-               1200    fx  Introduces adirective
 -->              1200   xfx  DCGrammar: rewrite

 :-               1200   xfx  head :-body. separator


Bibliography

[Anjewierden &Wielemaker, 1989]A.Anjewierden andJ. Wielemaker. Extensibleobjects.
                             ESPRITProject 1098 Technical Report UvA-C1-TR-
                             006a,University ofAmsterdam, March 1989.

[BIM, 1989]                  _B_I_M _P_r_o_l_o_g _r_e_l_e_a_s_e _2_._4.Everberg, Belgium, 1989.

[Bowen &Byrd, 1983]          D.L. Bowen andL. M. Byrd. Aportable Prolog com-
                             piler. InL. M.Pereira, editor, _P_r_o_c_e_e_d_i_n_g_s _o_f _t_h_e
                             _L_o_g_i_n  _P_r_o_g_r_a_m_m_i_n_g  _W_o_r_k_s_h_o_p   _1_9_8_3, Lisabon,
                             Portugal,1983. Universidadenova de Lisboa.

[Bratko, 1986]               I.Bratko.  _P_r_o_l_o_g   _P_r_o_g_r_a_m_m_i_n_g   _f_o_r   _A_r_t_i_-
                             _f_i_c_i_a_l  _I_n_t_e_l_l_i_g_e_n_c_e.  Addison-Wesley, Reading,
                             Massachusetts,1986.

[Clocksin &Melish, 1987]     W.F. Clocksin and C.S. Melish. _P_r_o_g_r_a_m_m_i_n_g  _i_n
                             _P_r_o_l_o_g.Springer-Verlag, NewYork,Third, Revisedand
                             Extendededition, 1987.

[Deransart _e_t _a_l_.,1996]      P.Deransart, A. Ed-Dbali, and L.Cervoni.  _P_r_o_l_o_g_:
                             _T_h_e _S_t_a_n_d_a_r_d.Springer-Verlag, New York,1996.

[Kernighan &Ritchie, 1978]   B.W. Kernighanand D.M. Ritchie. _T_h_e _C _P_r_o_g_r_a_m_-
                             _m_i_n_g _L_a_n_g_u_a_g_e.Prentice-Hall, Englewood Cliffs,New
                             Jersey,1978.

[OKeefe, 1990]               R.A. OKeefe. _T_h_e _C_r_a_f_t  _o_f  _P_r_o_l_o_g. MITPress,
                             Massachussetts,1990.

[Pereira, 1986]              F.Pereira. _C_-_P_r_o_l_o_g _U_s_e_r_'_s _M_a_n_u_a_l, 1986.

[Qui, 1997]                  _Q_u_i_n_t_u_s _P_r_o_l_o_g_,  _U_s_e_r _G_u_i_d_e  _a_n_d  _R_e_f_e_r_e_n_c_e
                             _M_a_n_u_a_l.Berkhamsted, UK, 1997.

[Sterling &Shapiro, 1986]    L.Sterling andE. Shapiro._T_h_e _A_r_t _o_f _P_r_o_l_o_g. MIT
                             Press,Cambridge, Massachusetts,1986.

[Warren, 1983]               D.H. D. Warren. Theruntime environment fora pro-
                             logcompiler using acopy algorithm. Technical Report
                             83/052,SUNYand StoneBrook, NewYork, 1983.Major
                             revisionMarch 1984.

                                  830
