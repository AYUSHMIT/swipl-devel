\chapter{Getting started}		\label{sec:starting}

This section introduces programming the PCE/Prolog environment: the
entities (objects), referencing objects and manipulating objects.  Most
of the material is introduced with examples.  A complete definition of
the interface primitives is in appendix~\ref{sec:interface}.

\section{Starting PCE/Prolog}

PCE can be connected to several Prolog implementations.  It is a
normal Unix executable and is be started from the Unix shell like
any other program.  When PCE/Prolog starts, it appears just like
the Prolog system it is based on, except for the banner message.
Below we started PCE/SWI-Prolog (\cite{SWI-Prolog:manual}).

\begin{code}
% xpce
~/.xpcerc compiled, 0.09 sec, 10,636 bytes.
.plrc compiled, 0.10 sec, 11,772 bytes.
PCE Development system (4.8.14, Oct 1995 for i486-linux and X11R6)
Copyright 1993-1995, University of Amsterdam.  All rights reserved.
The host-language is SWI-Prolog version 2.1.10

For HELP on prolog, please type help. or apropos(topic).
         on xpce, please type manpce.

1 ?- 
\end{code}

\index{version}%
SWI-Prolog's prompt is ``$<$n$>$ ?-'' where $<$n$>$ is the
history-number of the command. The banner indicates the PCE version.
The current version is 4.8 and the patch-level is 14.

\section{Prolog ... and what?}

This section describes the four basic Prolog predicates used to
control PCE from Prolog.  These four predicates map onto the basic
functions of PCE's virtual machine: creating, destroying,
manipulating and querying {\em objects}, the basic entifies of
PCE.

For those not familiar with this jargon, an object is an observable
entity with a persistent state and associated procedures (called {\em
methods}).  Objects may represent just about anything.  In PCE's world
there are objects representing a position in a two-dimensional plane
as well as an entire window on your screen.  Each object belongs to a
{\em class}.  The class defines the constituents of the persistent
state as well as the procedures associated with the object.  For
example a position in a two-dimensional plane is represented by a
object of class {\em point}.  The state of a point object consists of
its X- and Y-coordinates.

\subsection{New: creating objects}

\index{object,reference}\index{reference, object}
The predicate new/2 (new(?Reference,~+NewTerm)) {\em creates} an
object in the PCE world and either assigns the given {\em reference}
to it or unifies the first argument with a PCE generated reference.
An (object-) reference is a unique handle used in further
communication with the object.  Below are some examples (\verb$?-$ is
the Prolog prompt):

\begin{code}
1 ?- new(P, point(10,20)).
P = @772024

2 ?- new(@demo, dialog('Demo Window')).
\end{code}

The first example creates an instance of class point from the
arguments `10' and `20'.  The reference is represented in Prolog using
the prefix operator \predrefer{@}{1}.  For PCE generated references
the argument of this term is a PCE generated integer value.  These
integers are guaranteed to be unique.  The second example creates a
dialog object.  A dialog is a window that is specialised for
displaying structured UI objects such as buttons, text-entry-fields,
etc.  In this example we have specified the reference.  Such a
reference must be of the form @Atom. PCE will associate the created
object with this reference.%
    \footnote{Normal applications use almost only PCE generated
	      references.  Many of the examples in this manual are
	      typed from the terminal and Prolog specified references
	      are easier to type.}

As illustrated by the examples above, the second argument to new/2
is a term.  The principal functor denotes the name of the class of
which a instance is to be created and the arguments are the
initialisation parameters.  The complete transformation rules are
given in appendix~\ref{sec:interface}.

As stated before, an object has persistent state.  At creation time, the
initial state is defined by the class from which the object is created
and the initialisation arguments.  In our example, the point is assigned
an x-value of 10 and and y-value of 20.  The dialog is assigned the label
`Demo Window'.  A dialog window has many {\em instance variables}: local
variables that serve as place-holders for the persistent state
associated with the object.  The example defines the `label' instance
variable.  All the others default according to the class definition.  


\subsection{Send: modifying object state}

The state of an object may be manipulated using the predicate
send/[2-12] (send(+Receiver, +Selector, ...Args...)).  The first two
arguments of this predicate are an object reference and the name of
the operation to perform (called {\em selector}). The example below
assumes the previous example to be typed in.%
    \footnote{Replace @772024 with the reference returned in
	      the previous example.} 
    
\begin{code}
3 ?- send(@772024, x, 15).
4 ?- send(@demo, append, text_item(name)).
\end{code}

The first example invokes the {\em method} `x' of the point object.
This method is declared at class point.  It sets the instance variable
x of the corresponding point object to the argument value.  The second
example invokes the method append of class dialog.  This method
appends a UI component to the dialog window.  The component is
specified by the term `text_item(name)', which is converted into an
object just as the second argument of new/2.

The query below will open the dialog window.

\begin{code}
5 ?- send(@demo, open).
\end{code}

If everything is ok, a window as shown in figure~\ref{fig:dialog}
should appear on your screen.  The outside (in the figure this is the
title-bar displayed above the window) is determined by the window
manager you are using.  It should look the same as any other window
on your terminal.  If an error of any kind appears, please refer
to appendix~\ref{sec:trouble}.


\postscriptfig{dialog}{Example Dialog Window}

\subsection{Get: querying objects}

The next fundamental interface predicate is get/[3-13].  It is used to
obtain information on the state of objects.  Again, the first two
arguments are the reference and selector.  The last argument is
unified with the return-value and the remaining arguments are
treated the same as with send/[2-12].  Examples:

\begin{code}
6 ?- get(@772024, y, Y).
Y = 20
7 ?- get(@demo, display, D).
D = @display/display
8 ?- get(@772024, distance, point(100,100), Distance).
Distance = 117
\end{code}

The first example just obtains the value of the `y' instance variable.
The second example returns the display object on which @demo is
displayed.  This is the reference to an object of class display that
represents your screen.%
    \footnote{Prolog would normally print `@display'.  The
    	      library(pce_portray) defines a clause for the Prolog predicate
	      portray/1 that prints object references as
	      `@Reference/Class'.  This library is used throughout
	      all the examples of this manual.}
The last example again shows the creation of objects from the
arguments to send/[2-12] and get/[3-13] and also shows that the
returned value does not need to be a direct instance variable of the
object.  The return value is an integer representing the (rounded)
distance between @772024 and point(100,100).

The second example illustrates that get/[3-13] returns objects by
their reference.  This reference may be used for further queries.
The example below computes the width and height of your screen.

\begin{code}
9 ?- get(@display, size, Size),
     get(Size, width, W),
     get(Size, height, H).
Size = @4653322, W = 1152, H = 900
\end{code}

As a final example, type something in the text entry field and try
the following:

\begin{code}
10 ?- get(@demo, member, name, TextItem),
      get(TextItem, selection, Text).
TextItem = @573481/text_item, Text = hello
\end{code}

\index{graphical,finding}\index{finding,graphical}
The first get operation requests a member of the dialog with the given
name (`name').  This will return the object reference of the text_item
object appended to the dialog.  The next request obtains the
`selection' of the text_item.  This is the text typed in the text
entry field.


\subsection{Free: removing objects}

\index{remove,objects}\index{object,remove}
The final principal interface predicate is free/1.  Its argument is
an object reference as returned by new/2 or get/[3-13].  It will remove
the object from the PCE object base.  Examples:

\begin{code}
12 ?- free(@772024).
13 ?- free(@demo).
14 ?- free(@display).
No
\end{code}

The second example not only removed the dialog window object from
the PCE object base, it also removes the associated X-window from
the screen.  The last example illustrates that certain system objects
have been protected against freeing.


\section{Optional arguments}

\index{default arguments}\index{optional arguments}\index{argument,optional}
Arguments to PCE methods are identified by their position.  Many
methods have both obligatory and optional arguments.  If obligatory
arguments are omitted PCE will generate a warning.  If optional
arguments are omitted PCE will fill the argument with the constant
@default.  The interpretation of @default is left to the
implementation of the receiving method.  See also
section~\ref{sec:online}.

\section{Named arguments}

\index{argument,named}\index{named argument}
Some methods take a lot of arguments of which you generally only want
to specify a few.  A good example is `style ->initialise'%
	\footnote{The ->initialise method is called by new/2 and
		  controls creating a new instance.}
taking 7 arguments.  Both calls below create a style object representing
an underlined text-fragment:

\begin{code}
1 ?- new(X, style(@default, @default, @default, @default, @on)).
2 ?- new(X, style(underline := @on)).
\end{code}

The names of arguments are specified in the reference manual.  For
example, the method `area ->set' has the following specification.

\begin{code}
area->set: x=[int], y=[int], width=[int], heigth=[int]
\end{code}

The following example illustrates the usage of this method:

\begin{code}
1 ?- new(A, area),
     send(A, set, y := 10, heigth := 50).
\end{code}


\section{Example: show files in directory}	\label{sec:fileviewer}

In this section we will illustrate the above with some small examples.
We will also show how the GUI can call procedures in the Prolog system.

The demo creates a list of files from the given directory and allows
the user to view a file.  \Figref{fileviewer} shows the result.

\postscriptfig[width=\textwidth}{fileviewer}{The FileViewer demo}

\begin{pcecode}
fileviewer(Dir) :-
	new(F, frame('File Viewer')),
	send(F, append, new(B, browser)),
	send(new(D, dialog), below, B),
	send(D, append,
	     button(view, message(@prolog, view,
				  B?selection?key))),
	send(D, append,
	     button(quit, message(F, destroy))),
	send(B, members, directory(Dir)?files),
	send(F, open).

view(F) :-
	send(new(V, view(F)), open),
	send(V, load, F).
\end{pcecode}

The main window of the application consists of a \class{frame} holding
two specialised \class{window} instances.  Any opened window in XPCE
is enclosed in a \class{frame}.  A \class{frame} is a collection of
{\em tiled} windows.  The windows are positioned using the methods
->above, ->below, ->right and ->left.  The frame ensures its member
windows will be properly aligned and handles resizing of the frame.

In line 3, a \class{browser} is ->append'ed to the frame object. A
browser is a window specialised for displaying a list of objects.
Browsers handle very large numbers of items effectively.  Next,
a \class{dialog} is positioned below the browser.  A dialog is
a window specialised in handling the layout of controllers, or
\class{dialog_item} objects as XPCE calls them.

Line 5 adds a \class{button} to the dialog.  `view' specifies the
{\em name} of the button. XPCE defines a central mapping from
`dialog_item <->name' to the label displayed.  The default mapping
capitalises the name and replaces underscores with spaces.  The
second argument of the button specifies the {\em action} associated
with the button.  A \class{message} is a dormant send-operation.  When
pressed, the button will execute

\begin{code}
send(@prolog, view, B?selection?key)
\end{code}

If a message is sent to @prolog, this will be mapped on executing
a predicate with the name of the {\em selector} of the message and
an arity that equals the number of arguments to the message (1 here).

The argument is a term with principal functor \class{?} and defines an
`obtainer', which is a dormant get-operation. It is defined as a Prolog
infix operator of type {\tt yfx}, priority 500. This implies that
\mbox{\tt B?selection?key} should be read as%
    \footnote{Initial versions of XPCE lacked the obtainer.  In this
	      case the browser {\em B} would be passed to the predicate
	      view/1, which would extract the current filename from the
	      browser.  Obtainers improve the readability and avoid the
	      need to mix UI related code with functional code.}

\begin{code}
?(?(B, selection), key)
\end{code}

The result of the get-operation <-selection on a browser returns the
\class{dict_item} object currently selected.  Dict-items are the
elements of a \class{dict}, the underlying data object of a browser.
A \class{dict_item} consists of a <-key (its identifier), a <-label
(the visual text) and optionally an associated object.

Line 8 appends a second button to the dialog window.  The dialog window
will automatially align this one to the right of the first.  The action
sends a message directly to another XPCE object and ->destroys the
frame object if the quit button is pressed.  Note that this will erase
all UI objects associated with the frame.  The garbage collector will
destroy the \class{message} objects too.

Line 10 fills the \class{browser} with the files from the specified
directory.  The expression \mbox{\tt directory(Dir)?files} defines
an obtainer operating on an instance of class \class{directory}.  The
obtainer evaluates to a \class{chain} holding the names of all files
in the directory.  This expression is the same as:

\begin{code}
	...,
	new(Dobj, directory(Dir)),
	get(Dobj, files, Chain),
	send(B, members, Chain),
	...
\end{code}

Again, the garbage collector will take care of the directory and chain
objects.  The browser will automatically convert the given names to
\class{dict_item} objects.%
    \footnote{This conversion is implemented with class
	      \class{dict_item}.  Actually the browser just specifies
	      the desired type and the message passing kernel invokes
	      the conversion method of class \class{dict_item}.}

Finally, the frame is ->open'ed.  This will cause the frame to ask
each of the windows to compute its desired size, after which the
frame aligns the windows, decides on their final geometry and creates
the Window-system counterpart.

The view/1 callback predicate simply opens an instance of \class{view},
a window specialised in text-editing and loads the file into the view.
The method `view ->load' expects an instance of class \class{file}.
Again, the type-conversion will deal with this. 


\section{Summary}

PCE's world consists of objects.  An object is an entity with
persistent state that belongs to a class.  The PCE/Prolog interface
defines four basic predicates: new/2 to create objects from a
description and returns an object reference.  The predicate
send/[2-12] changes the state of an object and succeeds if the
requested change could be made.  The predicate get/[3-13] requests an
object to compute a value and return it.  Finally, free/1 removes
objects from the PCE database.

Objects of the class message are `dormant' send operations.  They
may be activated by other objects (button, text_item, ...).  In this
case a send operation is started.

The object @prolog (class \class{host}) allows calling Prolog predicates
from the PCE environment.


