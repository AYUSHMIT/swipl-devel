\chapter{Global architecture}

Section~\ref{sec:starting} introduced the basic principles of
PCE/Prolog with examples.  In this section we present a rough
conceptual overview of PCE and the PCE/Prolog environment.


\section{What is ``Object-Oriented''?}

PCE is an object-oriented system.  This implies that the basic
entity in PCE's world is an object, which is an observable entity
with persistent state capable of performing actions.  Such an action
is activated by sending the object a {\em message}.

So far most object oriented systems agree.  Starting from these
notions however one can find object oriented environments that take
widely different approaches for representing objects, actions on
objects and sending messages.

Rather than specifying operations on each individual object most OO
environments define some way of sharing the operation definitions
(called {\em methods}).  There are two ways to share methods.  One is
to create objects as a copy of other objects and then modify them (by
attaching and deleting attributes and methods) to fit the particular
need.  If a series of similar objects is needed, one first creates an
object that satisfies the common functionality and then creates
multiple copies of this object.  This approach is followed by
SELF \cite{chambers:89}.  The other ---more traditional--- approach is to
define a {\em class}.  A class is an entity in the object oriented
environment that defines the constituents of the persistent state
and the methods for each of its {\em instantiations}.  PCE takes the
latter approach, but adds some notions of the object-copying
approach. 


\section{PCE's objects}

Getting down to earth, a PCE object is a set of {\em values} of {\em
instance variables} bundled into a single entity which is referred
to by its {\em object reference}. An object is an instantiation of
a {\em class}.  A class holds the key to decoding the information of
its instances:% 
    \footnote{We will mix the terms {\em instance} and {\em object}
              freely in this document.  They must be considered synonyms.}
the instance variables.  The class also serves as a placeholder
for storing the methods understood by its instances.  Figure~\ref
{fig:arch1} illustrates this.

\postscriptfig[width=\textwidth]{arch1}{Classes and Objects in PCE}


\subsection{Classes}

As explained above, a PCE class describes the storage-layout and the
methods of its instances.  In PCE a class is a normal object.  It is
an instance of class {\em class}.%
    \footnote{Class class is an instance of itself.  In other systems
	      (SmallTalk, \cite{Goldberg:83a}), classes are instances of a
	      {\em meta-class}.  Yet in other system, classes have
	      a completely different status (for example widgets in
	      the X11 Intrinsics)}
\index{inheritance,of classes}
As in most OO systems PCE classes may inherit from a {\em
super-class}.  PCE classes are organised in a single-inheritance
hierarchy.%
    \footnote{Multiple inheritance introduces various technical and
	      conceptual problems.  PCE uses delegation to achieve
	      similar results.  This is explained in section~\ref
	      {sec:delegation}.}
The root of this hierarchy is class {\em object}.  Class object is the
only class without a super-class.  Figure~\ref{fig:classhierarchy} gives
the complete hierarchy of PCE classes.

\postscriptfig[height=8in]{classhierarchy}{PCE's Class hierarchy}


\section{Objects and non-objects}

Except for integers, everything accessible to the user is represented
as an object.  By implementing classes, instance variables, methods,
messages, conditions, constants, variables, etc.\ as objects
everything in PCE may be accessed through the basic predicates
new/2, send/[2-12] and get/[3-13] from Prolog.


\section{Delegation}		\label{sec:delegation}

\index{delegation}\index{multiple inheritance}\index{inheritance,multiple}
PCE does not offer multiple inheritance.  Sharing functionality from
multiple classes is generally dealt with using {\em delegation}.
Delegation implies that messages not understood by a principal object
are forwarded to an object that is associated to it.

For example, PCE defines class \class{editor} to be a graphical object
capable of editing text.  Most applications require a \class {window}
capable of editing text.  PCE's class \class{view} is not a subclass
of both editor and window, but just of window.  The window displays an
instance of class editor and constraints the size of the editor to
occupy the entire visible area of the window.  Any message arriving on
the view that is not defined on class view (or class window) will be
forwarded to the associated editor object.

The dynamic nature of delegation makes this mechanism more flexible
than multiple inheritance.  For example, PCE defines class \class{node}.
This class defines the communication to a \class{tree} to automate the
layout of hierarchies.  A node can manipulate any graphical object.
Using multiple inheritance would require a class {\em box_node},
{\em cicle_node}, etc.%
    \footnote{A problem with PCE's current implementation of
	      delegation is that the object that is a functional
	      part of another object is not aware of this fact.}


\section{Executable Objects}

\index{statement,as object}\index{executable,object}
\index{program,as object}\index{lambda functions}
PCE defines {\em executable} objects.  Executable objects (often
called \idx{code object}s) may be compared to lambda functions is Lisp.
They are used for:

\begin{itemize}
    \tick{To define `\idx{call-back}' actions}
The traditional and most common usage of executable objects is to
specify the action undertaken by interactive UI components when they
are activated.  We have seen examples of this in
section~\ref{sec:dialogexample}.
    \tick{As implementation of a \class{method} object} 
A method describes an action associated with a class or individual
object.  It maps a {\em selector} onto an action.  This action is
either a C-function (used for most internal methods) or an
executable object.  Examples of this may be found in
section~\ref{sec:movepiece}.  See also \cite{PCE:udc}.
    \tick{As parameter to a method}
Various of PCE's method take an executable object as a parameter to
specify the action undertaken.  For example, the method `sort' of
class \class{chain} takes an executable object to compare two
elements:

\begin{code}
1 ?- new(@ch, chain(this, is, not, a, gnu)).
2 ?- send(@ch, sort, ?(@arg1, compare, @arg2)).
3 ?- object(@ch, O).
O = chain(a, gnu, is, not, this) 
\end{code}

The `?(@arg1, compare, @arg2)' construct describes a \class{function}
object, a subclass of executable objects that yield a value.  This is
further explained in section~\ref {sec:function}. 
\end{itemize}

Two major groups of code objects are distinguished: {\em procedures}
and {\em functions}.  The first only returns status information
similar to the send-operation.  The latter returns a value or failure
status information similar to the get-operation.  The most important
`procedure' code objects are:

\begin{itemize}
    \tick{message}
A \class{message} object starts a send-operation when executed.
    \tick{and}
An \class{and} is a sequence of code objects.  It fails if one of the
members fails and succeeds otherwise.
    \tick{if}
An \class{if} implements a branch.
\end{itemize}

The online manual may be used to get an overview of the available
code objects.  See section~\ref{sec:classhierarchy}.


\subsection{Functions}		\label{sec:function}

Functions are code objects which ---when executed--- evaluate to a PCE
datum (int or object).  They may be used as arguments to other code
objects or as arguments to any method.  A function is automatically
evaluated iff:

\begin{shortlist}
    \tick{It appears as an argument of a code object that is executed}
    \tick{Type checking demands execution} 
\end{shortlist}

\noindent
The most important function objects are:

\begin{itemize}
    \tick{`?'}
Class \class{?} starts a get-operation when executed (= evaluated).  It
may be compared to \class{message}.
    \tick{var}
Class \class{var} describes a variable.  The definition of this
class is not yet stable.  The objects @arg1, @arg2, ..., @arg10,
@receiver and @event are the most commonly used var objects.
    \tick{arithmetic functions (+, -, *, /)}
\index{arithmetic}%
These functions define {\em integer} arithmetic and are commonly used
to deal with graphical computations in code objects.
\end{itemize}


\section{Prolog}

PCE was {\em not} designed to propose a new programming language, but
to be a system that can easily be added to another
environment to create a hybrid architecture.  In this environment,
PCE takes care of the user interface (UI) and possibly other tasks for
which it is better suited than the environment it is attached to (e.g.\
representing long text fragments is difficult in Prolog).

The small size of the interface (only four predicates) makes it easy
to connect PCE to another environment.  This simple interface
nevertheless provides a powerful and fast communication channel.

As we have seen in section~\ref{sec:starting} activating PCE is done by
providing the user with access to PCE's message passing
primitives.  Near the end of section~\ref{sec:starting} we briefly
explained how control is passed from PCE to Prolog. The predefined
object @prolog is (the only) instance of class {\em host}.  Any
message sent to this instance will be mapped on a Prolog goal and
given to the Prolog system as a query: the {\em selector} of the
method will be used as a predicate name.  The arguments will be
translated from PCE data-types to their corresponding Prolog
data-types according to the transformation rules described in
section~\ref{sec:interface}. 

Figure~\ref{fig:control} shows the data- and control-flow between
PCE and Prolog.  The lines with arrows indicate data-flow in the
direction of the arrow.  The dotted ellipse with arrows indicates
the flow of control.

\postscriptfig[width=\textwidth]{control}{Data and Control flow in PCE/Prolog}


\section{Summary}

This section explained the basic object-oriented notions used in
PCE.  PCE's data is organised in {\em objects} and integers.  An
object represents a state.  An object is an instance of a class.
A class describes the constituents of the state represented in
its instances and the methods (actions) understood by its instances.

A class is a normal object, as are all the other constituents of
PCE's programming world: methods, instance variables, messages,
expressions, etc.  This uniformity allows for inspecting and changing
PCE using the four basic interface predicates from Prolog.

The basic interface predicates pass control from Prolog to PCE.
When control is to be passed from PCE to Prolog (for example if
the user presses a button), a message is send to @prolog, the
only instance of class host.  This object will create a goal
from the message and pass this goal to the Prolog environment to
be proven.
