\chapter{Using Modules}                 \label{sec:modules}

\section{Why Using Modules?}		\label{sec:whymodules}

In traditional Prolog systems the predicate space was flat.  This
approach is not very suitable for the development of large
applications, certainly not if these applications are developed by
more than one programmer.  In many cases, the definition of a Prolog
predicate requires sub-predicates that are intended only to complete
the definition of the main predicate.  With a flat and global
predicate space these support predicates will be visible from the
entire program.

For this reason, it is desirable that each source module has its own
predicate space.  A module consists of a declaration for its name,
its \jargon{public predicates} and the predicates themselves.  This
approach allows the programmer to use short (local) names for support
predicates without worrying about name conflicts with the support
predicates of other modules.  The module declaration also makes
explicit which predicates are meant for public usage and which for
private purposes.  Finally, using the module information, cross
reference programs can indicate possible problems much better.


\section{Name-based versus Predicate-based Modules} \label{sec:whichmodules}

Two approaches to realise a module system are commonly used in Prolog
and other languages. The first one is the \jargon{name based} module
system. In these systems, each atom read is tagged (normally prefixed)
with the module name, with the exception of those atoms that are defined
\jargon{public}. In the second approach, each module actually implements
its own predicate space.

A critical problem with using modules in Prolog is introduced by the
meta-predicates that transform between Prolog data and Prolog
predicates.  Consider the case where we write:

\begin{code}
:- module(extend, [add_extension/3]).

add_extension(Extension, Plain, Extended) :-
        maplist(extend_atom(Extension), Plain, Extended).

extend_atom(Extension, Plain, Extended) :-
        atom_concat(Plain, Extension, Extended).
\end{code}

In this case we would like maplist to call {extend_atom}/3 in the module
\const{extend}.  A name based module system will do this correctly. It
will tag the atom \const{extend_atom} with the module and maplist will
use this to construct the tagged term {extend_atom}/3.  A name based
module however, will not only tag the atoms that will eventually be
used to refer to a predicate, but \strong{all} atoms that are not declared
public.  So, with a name based module system also data is local to the
module.  This introduces another serious problem:

\begin{code}
:- module(action, [action/3]).

action(Object, sleep, Arg) :- ....
action(Object, awake, Arg) :- ....

:- module(process, [awake_process/2]).

awake_process(Process, Arg) :-
        action(Process, awake, Arg).
\end{code}

This code uses a simple object-oriented implementation technique
were atoms are used as method selectors.  Using a name based module
system, this code will not work, unless we declare the selectors
public atoms in all modules that use them.  Predicate based module
systems do not require particular precautions for handling this case.

It appears we have to choose either to have local data, or to have
trouble with meta-predicates.  Probably it is best to choose for
the predicate based approach as novice users will not often write
generic meta-predicates that have to be used across multiple modules,
but are likely to write programs that pass data around across
modules.  Experienced Prolog programmers should be able to deal with 
the complexities of meta-predicates in a predicate based module
system.


\section{Defining a Module}		\label{dec:defmodule}

Modules normally are created by loading a \jargon{module file}.  A module
file is a file holding a module/2 directive as its first term.  The
module/2 directive declares the name and the public (i.e.,
externally visible) predicates of the module.  The rest of the file
is loaded into the module.  Below is an example of a module file,
defining reverse/2. 

\begin{code}
:- module(reverse, [reverse/2]).

reverse(List1, List2) :-
        rev(List1, [], List2).

rev([], List, List).
rev([Head|List1], List2, List3) :-
        rev(List1, [Head|List2], List3).
\end{code}


\section{Importing Predicates into a Module}	\label{sec:import}

As explained before, in the predicate based approach adapted by
SWI-Prolog, each module has its own predicate space.  In SWI-Prolog,
a module initially is completely empty.  Predicates can be added
to a module by loading a module file as demonstrated in the previous
section, using assert or by \jargon{importing} them from another module.

Two mechanisms for importing predicates explicitly from another module
exist.  The use_module/[1,2] predicates load a module file and import
(part of the) public predicates of the file.  The import/1 predicate
imports any predicate from any module.

\begin{description}
    \predicate{use_module}{1}{+File}
Load the file(s) specified with \arg{File} just like ensure_loaded/1.
The files must all be module files.  All exported predicates from the
loaded files are imported into the context module.  This predicate is
equivalent to ensure_loaded/1, except that it raises an error if 
\arg{File} is not a module file.  

    \predicate{use_module}{2}{+File, +ImportList}
Load the file specified with \arg{File} (only one file is accepted).
\arg{File} must be a module file. \arg{ImportList} is a list of
predicate indicators specifying the predicates that will be imported
from the loaded module. If a predicate is specified that is not exported
from the loaded module a warning will be printed. The predicate will
nevertheless be imported to simplify debugging. \arg{ImportList} also
allows for renaming or import-everything-except. See also \const{import}
option of load_files/2. The first example below loads member/2 from the
lists library and append/2 under the name \const{list_concat}, which how
this predicate is named in YAP. The second example loads a all exports
from library option, except for meta_options/3. These renaming
facilities are generally used to deal with portability issues with as
few as possible changes to the actual code.  See also \secref{dialect}
and \secref{reexport}.

\begin{code}
:- use_module(library(lists), [ member/2,
				append/2 as list_concat
			      ]).
:- use_module(library(option), except([meta_options/3])).
\end{code}

    \predicate{import}{1}{+PredicateIndicator}
Import predicate \arg{PredicateIndicator} into the current context
module. \arg{PredicateIndicator} must specify the source module using
the \mbox{<module>:<pi>} construct. Note that predicates are
normally imported using one of the directives use_module/[1,2].
The import/1 alternative is meant for handling imports into dynamically
created modules.  See also export/1 and export_list/2.
\end{description}


It would be rather inconvenient to have to import each predicate
referred to by the module, including the system predicates.  For this
reason each module is assigned a \jargon{default module}.  All predicates
in the default module are available without extra declarations.  Their
definition however can be overruled in the local module.  This schedule
is implemented by the exception handling mechanism of SWI-Prolog:  if
an undefined predicate exception is raised for a predicate in some
module, the exception handler first tries to import the predicate from
one of the module's \jargon{import modules}. On success, normal
execution is resumed.


\subsection{Reserved Modules}

SWI-Prolog contains two special modules. The first one is the module
\const{system}. This module contains all built-in predicates described
in this manual. Module \const{system} has no default module assigned to
it. The second special module is the module \const{user}. This module
forms the initial working space of the user. Initially it is empty. The
import module of module \const{user} is \const{system}, making all
built-in predicate definitions available as defaults. Built-in
predicates thus can be overruled by defining them in module \const{user}
before they are used.

All other modules import from the module \const{user}. This implies they
can use all predicates imported into \const{user} without explicitly
importing them.


\section{Composing modules from other modules}
\label{sec:reexport}

The predicates in this section are intended to create new modules from
the content of other modules. Below is an example is to define a
\emph{composite} module.  The example exports all public predicates
of \const{module_1}, \const{module_2} and \const{module_3}, pred/1
from \const{module_4}, all predicates from \const{module_5} except
do_not_use/1 and all predicates from \const{module_6} while renaming
pred/1 into mypred/1.

\begin{code}
:- module(my_composite, []).
:- reexport([ module_1,
	      module_2,
	      module_3
	    ]).
:- reexport(module_4, [ pred/1 ]).
:- reexport(module_5, except([do_not_use/1])).
:- reexport(module_6, except([pred/1 as mypred])).
\end{code}


\begin{description}
    \predicate{reexport}{1}{+Files}
Load and import predicates as use_modules/1 and re-export all imported
predicates. The reexport declarations must immediately follow the module
declaration.

    \predicate{reexport}{2}{+File, +Import}
Import from \arg{File} as use_module/2 and re-export the imported
predicates. The reexport declarations must immediately follow the module
declaration.
\end{description}


\section{Using the Module System}	\label{sec:usemodules}

The current structure of the module system has been designed with some
specific organisations for large programs in mind.  Many large
programs define a basic library layer on top of which the actual
program itself is defined.  The module \const{user}, acting as the
default module for all other modules of the program can be used to
distribute these definitions over all program module without
introducing the need to import this common layer each time
explicitly.  It can also be used to redefine built-in predicates
if this is required to maintain compatibility to some other Prolog
implementation.  Typically, the loadfile of a large application
looks like this:

\begin{code}
:- use_module(compatibility).   % load XYZ prolog compatibility

:- use_module(                  % load generic parts
        [ error                 % errors and warnings
        , goodies               % general goodies (library extensions)
        , debug                 % application specific debugging
        , virtual_machine       % virtual machine of application
        , ...                   % more generic stuff
        ]).

:- ensure_loaded(
        [ ...                   % the application itself
        ]).
\end{code}

The `use_module' declarations will import the public predicates from
the generic modules into the \const{user} module.  The `ensure_loaded'
directive loads the modules that constitute the actual application.
It is assumed these modules import predicates from each other using
use_module/[1,2] as far as necessary.

In combination with the object-oriented schema described below it is
possible to define a neat modular architecture.  The generic code
defines general utilities and the message passing predicates ({invoke}/3
in the example below).  The application modules define classes that
communicate using the message passing predicates.


\subsection{Object Oriented Programming}

Another typical way to use the module system is for defining classes
within an object oriented paradigm.  The class structure and the
methods of a class can be defined in a module and the explicit
module-boundary  overruling describes in \secref{overrule}
can by used by the message passing code to invoke the behaviour.  An
outline of this mechanism is given below.

\begin{code}
%       Define class point

:- module(point, []).           % class point, no exports

%        name           type,           default access
%                                       value

variable(x,             integer,        0,      both).
variable(y,             integer,        0,      both).

%         method name   predicate name  arguments

behaviour(mirror,       mirror,         []).

mirror(P) :-
        fetch(P, x, X),
        fetch(P, y, Y),
        store(P, y, X),
        store(P, x, Y).
\end{code}


The predicates {fetch}/3 and {store}/3 are predicates that change
instance variables of instances. The figure below indicates how message
passing can easily be implemented:

\begin{code}
%       invoke(+Instance, +Selector, ?ArgumentList)
%       send a message to an instance

invoke(I, S, Args) :-
        class_of_instance(I, Class),
        Class:behaviour(S, P, ArgCheck), !,
        convert_arguments(ArgCheck, Args, ConvArgs),
        Goal =.. [P|ConvArgs],
        Class:Goal.

\end{code}


The construct <Module>:<Goal> explicitly calls \arg{Goal} in
module \arg{Module}.  It is discussed in more detail in
\secref{metainmodule}.


\section{Meta-Predicates in Modules}	\label{sec:metainmodule}

As indicated in the introduction, the problem with a predicate based
module system lies in the difficulty to find the correct predicate
from a Prolog term.  The predicate `solution(Solution)' can exist in
more than one module, but `assert(solution(4))' in some module is
supposed to refer to the correct version of {solution}/1.

Various approaches are possible to solve this problem. One is to tag the
term to indicate which module is desired (e.g., `assert(Module:Term)').
Of course, this tagging should not be done by hand because this invites
spagetti-style programming such as asserting into other modules. The
predicate assert/1 is supposed to assert in the module it is called from
and should do so without being told explicitly.   Current SWI-Prolog has
two mechanisms to achieve this:

\begin{itemize}
    \item Use a meta_predicate/1 declaration, which causes the compiler
    to provide the above mentioned <module>:<term> tagging.

    \item Use a module_transparent/1 declaration, which causes the
    compiler to preserves the current \jargon{context module} over
    the call.  The context module was the original mechanism provided
    by SWI-Prolog and although new code should use meta_predicate/1
    for compatibility, the context module mechanism still underpins
    SWI-Prologs handling of meta_predicate/1.  See \secref{ctxmodule}
    for a further explanation of this construct.
\end{itemize}


\subsection{Defining a meta-predicate}
\label{sec:metapred}

The meta_predicate/1 directive causes all module-sensitive arguments to
be passed as <module>:<term>.  If the argument is already qualified this
way, it is left untouched because the context has already been assigned
elsewhere.  This mechanism can be used to address specific modules
explicitely as in the code below that asserts `term' in the module
`target':

\begin{code}
	assert(target:term).
\end{code}

Below we use this to define maplist inside a module. The argument `2' in
the meta_predicate declaration means that the argument is module
sensitive and refers to a predicate with an arity that is two more than
the term that is passed in. The compiler only distinguishes the values
0..9 and \chr{:}, which denode module-sensitive arguments from \chr{+},
\chr{-} and \chr{?} which denotes \jargon{modes}. The values 0..9 are
used by the \jargon{cross-referencer} and syntax highlighting. Note that
the helper-predicate maplist_/3 does not need to be declared as a
meta-predicate because the maplist/3 wrapper already ensures that
\arg{Goal} is qualified as <module>:\arg{Goal}.  See the description
of meta_predicate/1 for details.

\begin{code}
:- module(maplist, [maplist/3]).
:- meta_predicate maplist(2, ?, ?).

%%      maplist(:Goal, +List1, ?List2)
%
%       True if Goal can successfully be applied to all successive pairs
%       of elements from List1 and List2.

maplist(Goal, L1, L2) :-
	maplist_(L1, L2, G).

maplist_([], [], _).
maplist_([H0|T0], [H|T], Goal) :-
	call(Goal, H0, H),
	maplist_(T0, T, Goal).
\end{code}


\subsection{Definition and Context Module}
\label{sec:ctxmodule}

The qualification of arguments with their module described in
\secref{metapred} is realised using \jargon{transparent} predicates.
Direct use of this underlying mechanism is now deprecated, but its
understanding may still contributed to understanding modules in
SWI-Prolog, while in some respects the transparent mechanism is
more powerful than the meta-predicate mechanism.

Each predicate of the program is assigned a module, called its
\jargon{definition module}. The definition module of a predicate is
always the module in which the predicate was originally defined. Each
active goal in the Prolog system has a \jargon{context module} assigned
to it.

The context module is used to find predicates from a Prolog term. By
default, the context module is the definition module of the predicate
running the goal. For transparent predicates however, this is the
context module of the goal that calls them, i.e., the context module is
\emph{not} changed when calling a transparent predicate. Below, we
implement maplist/3 using the transparent mechanims. The code more
maplist/3 and maplist_/3 is the same, but note that we must also declare
the helper as transparent to avoid changing the context module when
calling it. 

\begin{code}
:- module(maplist, maplist/3).

:- module_transparent
	maplist/3,
	maplist_/3.

maplist(Goal, L1, L2) :-
	maplist_(L1, L2, G).

maplist_([], [], _).
maplist_([H0|T0], [H|T], Goal) :-
	call(Goal, H0, H),
	maplist_(T0, T, Goal).
\end{code}

Also note that \emph{any} call that translates terms into predicates is
subject to the transparent mechanism, not just the term passed as first
argument into maplist/3. For example, consider the code below that
counts the number of unique atoms returned as binding for a variable.
Defined using \exam{:- meta_predicate count_atom_results(-,0,-).}, this
works as expected. If we define count_atom_results/3 as transparent,
atom_result/2 is called wrongly in the module \emph{calling}
count_atom_results/3. This can be solved using strip_module/3 to create
a qualified goal and a non-transparent helper predicate that is defined
in the same module. 

\begin{code}
:- module(count_atom_results,
	  count_atom_results/3).

count_atom_results(A, Goal, Count) :-
	setof(A, atom_result(A, Goal), As), !,
	length(As, Count).
count_atom_results(_, _, 0).

atom_result(Var, Goal) :-
	call(Goal),
	atom(Var).
\end{code}


\subsection{Overruling Module Boundaries}       \label{sec:overrule}

The mechanism above is sufficient to create an acceptable module
system.  There are however cases in which we would like to be able to
overrule this schema and explicitly call a predicate in some module
or assert explicitly in some module.  The first is useful to invoke
goals in some module from the user's top-level or to implement a
object-oriented system (see above).  The latter is useful to create
and modify \jargon{dynamic modules} (see \secref{dynamic-modules}). 

For this purpose, the reserved term \functor{:}{2} has been introduced.
All built-in predicates that transform a term into a predicate
reference will check whether this term is of the form
\mbox{`<Module>:<Term>'}.  If so, the predicate is searched
for in \arg{Module} instead of the goal's context module.  The
\op{:} operator may be nested, in which case the inner-most module
is used.

The special calling construct \mbox{<Module>:<Goal>} pretends
\arg{Goal} is called from \arg{Module} instead of the context module.
Examples:

\begin{code}
?- assert(world:done).  % asserts done/0 into module world
?- world:assert(done).  % the same
?- world:done.          % calls done/0 in module world
\end{code}


\section{Dynamic Modules}               \label{sec:dynamic-modules}

So far, we discussed modules that were created by loading a
module-file.  These modules have been introduced on facilitate the
development of large applications.  The modules are fully defined at
load-time of the application and normally will not change during 
execution.  Having the notion of a set of predicates as a
self-contained world can be attractive for other purposes as well.
For example, assume an application that can reason about multiple
worlds.  It is attractive to store the data of a particular world in a
module, so we extract information from a world simply by invoking
goals in this world.

Dynamic modules can easily be created.  Any built-in predicate that
tries to locate a predicate in a specific module will create this
module as a side-effect if it did not yet exist.  Example:

\begin{code}
?- assert(world_a:consistent),
   world_a:unknown(_, fail).
\end{code}

These calls create a module called `world_a' and make the call
`world_a:consistent' succeed.  Undefined predicates will not start the
tracer or autoloader for this module (see unknown/2).

Import and export from dynamically created world is arranged via the
predicates import/1 and export/1:

\begin{code}
?- world_b:export(solve(_,_)).          % exports solve/2 from world_b
?- world_c:import(world_b:solve(_,_)).  % and import it to world_c
\end{code}


\section{Module Handling Predicates}	\label{sec:manipmodule}

This section gives the predicate definitions for the remaining
built-in predicates that handle modules.

\begin{description}
    \directive{module}{2}{+Module, +PublicList}
This directive can only be used as the first term of a source file. It
declares the file to be a \jargon{module file}, defining \arg{Module} and
exporting the predicates of \arg{PublicList}. \arg{PublicList} is a
list of predicate indicators (name/arity or name//arity pairs) or
operator declarations using the format \term{op}{Precedence, Type,
Name}. Operators defined in the export list are available inside the
module as well as to modules importing this module. See also
\secref{operators}.

    \predicate{current_module}{1}{-Module}
Generates all currently known modules.

    \predicate{current_module}{2}{?Module, ?File}
Is true if \arg{File} is the file from which \arg{Module} was loaded.
\arg{File} is the internal canonical filename. See also
source_file/[1,2].

    \prefixop{meta_predicate}{+Heads}
Define the predicates referenced by the comma-separated list \arg{Heads}
as \jargon{meta-predicates}. Each argument of each head is a
\jargon{meta argument specifier}. Defined specifiers are given below.
Only 0..9 and \chr{:} are interpreted; the mode declarations \chr{+},
\chr{-} and \chr{?} are not distinguished.

    \begin{description}
        \termitem{0..9}{}
The argument is a term that is used to reference a predicate
with the $N$ more arguments than the given argument term.  For
example: call(0) or maplist(1, +).
        \termitem{:}{}
The argument is module sensitive, but does not directly refer
to a predicate.  For example: consult(:).
        \termitem{-}{}
The argument is not module sensitive and unbound on entry.
        \termitem{?}{}
The argument is not module sensitive and the mode is unspecified.
        \termitem{+}{}
The argument is not module sensitive and bound (i.e., nonvar)
on entry.
    \end{description}

Each argument that is module-sensitive (i.e., marked 0..9 or \chr{:}) is
qualified with the context module of the caller if it is not already
qualified. The implementation ensures that the argument is passed as
<module>:<term>, where <atom> is an atom denoting the name of a module
and <term> itself is not of this form.  Below is a simple declaration
and a number of queries.

\begin{code}
:- meta_predicate
	meta(0, +).

meta(Module:Term, _Arg) :-
	format('Module=~w, Term = ~q~n', [Module, Term]).
\end{code}

\begin{code}
?- meta(test, x).
Module=user, Term = test
?- meta(m1:test, x).
Module=m1, Term = test
?- m2:meta(test, x).
Module=m2, Term = test
?- m1:meta(m2:test, x).
Module=m2, Term = test
?- meta(m1:m2:test, x).
Module=m2, Term = test
?- meta(m1:42:test, x).
Module=m1, Term = 42:test
\end{code}

The meta_predicate/1 declaration is the portable mechanism for defining
meta-predicates and replaces the old SWI-Prolog specific mechanism
provided by de deprecated predicates module_transparent/1,
context_module/1 and strip_module/3.  See also \secref{modulecompat}.

    \prefixop{module_transparent}{+Preds}
\arg{Preds} is a comma separated list of name/arity pairs (like
dynamic/1).  Each goal associated with a transparent declared predicate
will inherit the \jargon{context module} from its parent goal.

    \predicate{context_module}{1}{-Module}
Unify \arg{Module} with the context module of the current goal.
context_module/1 itself is transparent.

    \predicate{strip_module}{3}{+Term, -Module, -Plain}
Used in module transparent or meta-predicates to extract the referenced
module and plain term. If \arg{Term} is a module-qualified term, i.e.\
of the format \arg{Module}:\arg{Plain}, \arg{Module} and \arg{Plain}
are unified to these values.  Otherwise \arg{Plain} is unified to
\arg{Term} and \arg{Module} to the context module.

    \predicate{export}{1}{+PredicateIndicator, \ldots}
Add a predicate to the public list of the context module.  This implies
the predicate will be imported into another module if this module is
imported with use_module/[1,2].  Note that predicates are normally
exported using the directive module/2. export/1 is meant to handle
export from dynamically created modules.

    \predicate{export_list}{2}{+Module, ?Exports}
Unifies \arg{Exports} with a list of predicate indicators, one for each
public predicate of \arg{Module}.  The order of the terms in
\arg{Exports} is not defined.   Predicate indicators are in canonical
form (i.e.\ always using Name/Arity and never the DCG form Name//Arity).
Future versions may also use the DCG form and include public operators.
See also predicate_property/2.
 
    \predicate{import_module}{2}{+Module, -Import}
True if \arg{Import} is defined as an import module for \arg{Module}.
All normal modules only import from \const{user}, which imports from
\const{system}. The predicates add_import_module/3 and
delete_import_module/2 can be used to manipulate the import list.

    \predicate{add_import_module}{3}{+Module, +Import, +StartOrEnd}
If \arg{Import} is not already an import module for \arg{Module}, add
it to this list at the \const{start} or \const{end} depending on
\arg{StartOrEnd}.  See also import_module/2 and delete_import_module/2.

    \predicate{delete_import_module}{2}{+Module, +Import}
Delete \arg{Import} from the list of import modules for \arg{Module}.
Fails silently if \arg{Import} is not in the list.

    \predicate{default_module}{2}{+Module, -Default}
Successively unifies \arg{Default} with the module names from which
a call in \arg{Module} attempts to use the definition.  For the
module \const{user}, this will generate \const{user} and \const{system}.
For any other module, this will generate the module itself, followed
by \const{user} and \const{system}.

Backward compatibility.  New code should use import_module/2.

    \predicate{module}{1}{+Module}
The call \exam{module(\arg{Module})} may be used to switch the default
working module for the interactive top-level (see prolog/0).  This may
be used to when debugging a module. The example below lists the clauses
of {file_of_label}/2 in the module \const{tex}.

\begin{code}
1 ?- module(tex).

Yes
tex: 2 ?- listing(file_of_label/2).
...
\end{code}
\end{description}

\section{Compatibility of the Module System}	\label{sec:modulecompat}

The SWI-Prolog module system is largely derived from the Quintus Prolog
module system, which is also adopted by SICStus, Ciao and YAP.
Originally, the mechanism for defining meta-predicates in SWI-Prolog was
based on the module_transparent/1 directive and strip_module/3. Since
5.7.4 it supports the de-facto standard meta_predicate/1 directive for
implementing meta-predicates, providing much better compatibility.

The support for the meta_predicate/1 mechanism however is considerably
different. On other systems, the \emph{caller} of a meta-predicate is
compiled differently to provide the required <module>:<term>
qualification. This implies that the meta-declaration must be available
to the the compiler when compiling code that calls a meta-predicate. In
practice, this implies that other systems pose the following
restrictions on meta-predicates:

\begin{itemize}
    \item Modules that provide meta-predicates for a module to-be-compiled
    must be loaded explicitly by that module.
    \item The meta_predicate directives of exported predicates must follow
    the module/2 directive immediately.
    \item After changing a meta-declaration, all modules that \emph{call}
    the modified predicates need to be recompiled.
\end{itemize}

In SWI-Prolog, meta-predicates are also \jargon{module-transparent} and
qualifying the module sensitive arguments is done inside the
meta-predicate. As a result, the caller need not be aware that it is
calling a meta-predicate and none of the above restrictions hold for
SWI-Prolog. However, code that aims at portability must obey the above
rules.

Other differences are listed below.

\begin{itemize}
    \item
If a module does not define a predicate, it is searched for in the
\jargon{import modules}. By default, the import module of any
user-defined module is the \const{user} module. In turn, the
\const{user} module imports from the module \const{system} that provides
all built-in predicates.  The auto-import hierarchy can be changed 
using add_import_module/3 and delete_import_module/2.

This mechanisms can be used to realise a simple object oriented system
or hierarchical module system.

    \item
Operator declarations are local to a module and may be exported. In
Quintus and SICStus all operators are global.  YAP and Ciao also use
local operators.  SWI-Prolog provides global operator declarations
from within a module using the following construct:

\begin{code}
:- op(precedence, type, user:(name)).
\end{code}
\end{itemize}

