\libdoc{clp/bounds}{Integer Bounds Constraint Solver}

\makebox[\linewidth]{\hfill Author: \emph{Tom Schrijvers}, K.U.Leuven}

\noindent
The bounds solver is a rather simple integer constraint solver, implemented
with attributed variables. Its syntax is a subset of the SICStus clp(FD)
syntax.
% See \secref{sicstus_compat} for more on compatibility with the SICStus
% clp(FD) solver.

The \pllib{bounds} library is \emph{not} an \jargon{autoload} library
and therefore it must be loaded explicitly before using it via:

\begin{code}
:- use_module(library(bounds)).
\end{code}


\subsection{Constraints}
%====================

The following constraints are supported:

\begin{description}
	\infixop{in}{-Var}{+Range}
		Varibale \arg{Var} is restricted to be in range \arg{Range}.
		A range is denoted by \texttt{L..U} where both \arg{L}
		and \arg{U} are integers.
	\infixop{in}{-Vars}{+Range}
		A list of variables \arg{Vars} are restriced to be in range
		\arg{Range}.
	\predicate{tuples_in}{2}{+Tuples, +Extension}
        	Where \arg{Tuples} is a list of tuples (lists) of variables
        	and integers, each of length~$N$, and \arg{Extension} is a list
        	of tuples of integers, each of length~$N$. Each tuple of 
		\arg{Tuples} is constrained to be in the relation
		defined by \arg{Extension}. See \secref{ex:tuplesin} for
		an example.
	\infixop{#>}{?Expr}{?Expr}
		The left-hand expression is constrained to be greater than the
		right-hand expressions.
	\infixop{#<}{?Expr}{?Expr}
		The left-hand expression is constrained to be smaller than the
		right-hand expressions.
	\infixop{#>=}{?Expr}{?Expr}
		The left-hand expression is constrained to be greater than
		or equal to the right-hand expressions.
	\infixop{#=<}{?Expr}{?Expr}
		The left-hand expression is constrained to be smaller than
		or equal to the right-hand expressions.
	\infixop{#=}{?Expr}{?Expr}
		The left-hand expression is constrained to be equal to the
		right-hand expressions.
	\infixop{#\=}{?Expr}{?Expr}
		The left-hand expression is constrained to be not equal to
		the right-hand expressions.
	\predicate{sum}{3}{+Vars,+Op,?Value}
		Here \arg{Vars} is a list of variables and integers,
		\arg{Op} is one of the binary constraint relation symbols above
		and \arg{Value} is an integer or variable. It represents the
		constraint ($\sum$\arg{Vars}) \arg{Op} \arg{Value}.
	\predicate{lex_chain}{1}{+VarsLists}
		The constraint enforces lexicographic ordering on the lists
		in the argument. The argument \arg{VarsLists} is a list of lists
		of variables and integers. The current implementation
		was contributed by Markus Triska.
	\predicate{all_different}{1}{+Vars}
		Constrains all variabls in the list \arg{Vars} to be pairwise
		not equal.
	\predicate{indomain}{1}{+Var}
		Unify variable \arg{Var} with a value in its
		domain. Backtracks over all possible values from
		lowest to greatest. Contributed by Markus Triska.
	\predicate{label}{1}{+Vars}
		Equivalent to labeling([], Vars).
	\predicate{labeling}{2}{+Options, +Vars}
		All variables in the list \arg{Vars} are assigned
		values from their respective domains such that no
		constraint on them is violated. \arg{Options} is a
		list of options.  One set of options lets you choose
		the variable selection strategy:

		\begin{description}
		    \termitem{leftmost}{}
			    Label the variables in the order they
			    occur in \arg{Vars} from left to right.
			    This is the default.

		    \termitem{ff}{}
			    Label the variable whose domain contains
			    the smallest number of elements among the
			    remaining variables next. This is called
			    "first-fail". The intention here is
			    twofold: First, to detect infeasibility
			    early by always considering the variable
			    most likely to cause failure; second, to
			    give priority to variables that are close
			    to running out of domain elements.

		    \termitem{min}{}
			    Label the variable whose lower bound is
			    the lowest among the remaining variables
			    next.

		    \termitem{max}{}
			    Label the variable whose upper bound is
			    the highest among the remaining variables
			    next.
		\end{description}

		Another set of options lets you search for extrema:

		\begin{description}
		    \termitem{min}{Expr}
		    \termitem{max}{Expr}
			    Label the variables such that \arg{Expr}
			    assumes the smallest/highest possible
			    value.
		\end{description}

	\predicate{serialized}{2}{+Starts,+Durations}
		\arg{Starts} = $[S_1,\ldots,S_n]$ is a list of
		variables or integers, and \arg{Durations} =
		$[D_1,\ldots,D_n]$ is a list of non-negative integers.
		\arg{Starts} are constrained to denote the starting
		times of non-overlapping tasks, i.e., $S_i + D_i =< S_j$
		or $S_j + D_j =< S_i$ for all $1 =< i < j =< n$.
\end{description}

\noindent Here \arg{Expr} can be one of
\begin{description}
	\item [integer]
	Any integer.
	\item [variable]
	A variable.
	\infixop{+}{?Expr}{?Expr}
	The sum of two expressions.
	\infixop{*}{?Expr}{?Expr}
	The product of two expressions.
	\infixop{-}{?Expr}{?Expr}
	The difference of two expressions.
	\predicate{max}{2}{?Expr,?Expr}
	The maximum of two expressions.
	\predicate{min}{2}{?Expr,?Expr}
	The minimum of two expressions.
	\infixop{mod}{?Expr}{?Expr}
	The first expression modulo the second expression.
	\predicate{abs}{1}{?Expr}
	The absolute value of an expression.
\end{description}

\subsection{Constraint Implication and Reified Constraints}
%===============================

The following constraint implication predicates are available:
\begin{description}
	\infixop{#=>}{+P}{+Q}
		\arg{P} implies \arg{Q}, where \arg{P} and \arg{Q} are reifyable constraints.
	\infixop{#<=}{+Q}{+P}
		\arg{P} implies \arg{Q}, where \arg{P} and \arg{Q} are reifyable constraints.
	\infixop{#<=>}{+P}{+Q}
		\arg{P} and \arg{Q} are equivalent, where \arg{P} and \arg{Q} are reifyable constraints.
\end{description}

\noindent
In addition, instead of being a reifyable constraint, either \arg{P} or
\arg{Q} can be a boolean variable that is the truth value of the corresponding constraint. 

\noindent
The following constraints are reifyable: \predref{#=}{2},
\predref{#\=}{2}, \predref{#<}{2}, \predref{#>}{2}, \predref{#=<}{2},
\predref{#>}{2}.

For example, to count the number of occurrences of a particular value in a list of constraint variables:
\begin{itemlist}
	\item [Using constraint implication]

\begin{code}
occurrences(List,Value,Count) :-
	occurrences(List,Value,0,Count).

occurrences([],_,Count,Count).
occurrences([X|Xs],Value,Acc,Count) :-
	X #= Value  #=> NAcc #= Acc + 1,
	X #\= Value #=> NAcc #= Acc,
	occurrences(Xs,Value,NAcc,Count).
\end{code}
	\item [Using reified constraints]

\begin{code}
occurrences(List,Value,Count) :-
	occurrences(List,Value,0,Count).

occurrences([],_,Count,Count).
occurrences([X|Xs],Value,Acc,Count) :-
	X #= Value #=> B,
	NAcc #= Acc + B,
	occurrences(Xs,Value,NAcc,Count).
\end{code}

\end{itemlist}


\subsection{Example 1: Send+More=Money}
%================

The following is an implementation of the classic alphametics puzzle
SEND + MORE = MONEY:

\begin{code}
:- use_module(library(bounds)).

send([[S,E,N,D], [M,O,R,E], [M,O,N,E,Y]])  :-
              Digits   =  [S,E,N,D,M,O,R,Y],
              Carries  =  [C1,C2,C3,C4],
              Digits  in  0..9,
              Carries in  0..1,

              M                #=              C4,
              O  +  10  *  C4  #=  M  +  S  +  C3,
              N  +  10  *  C3  #=  O  +  E  +  C2,
              E  +  10  *  C2  #=  R  +  N  +  C1,
              Y  +  10  *  C1  #=  E  +  D,

              M  #>=  1,
              S  #>=  1,
              all_different(Digits),
              label(Digits).
\end{code}

\subsection{Example 2: Using tuples_in for a train schedule}
\label{sec:ex:tuplesin}

This example demonstrates tuples_in/2. A train schedule is represented
as a list~$Ts$ of quadruples, denoting departure and arrival places and
times for each train. The \emph{path/3} predicate given below
constrains~$Ps$ to a feasible journey from~$A$ to~$D$ via 3~trains that
are part of the given schedule.

\begin{code}
:- use_module(library(bounds)).

schedule(Ts) :-
	Ts = [[1,2,0,1],[2,3,4,5],[2,3,0,1],[3,4,5,6],[3,4,2,3],[3,4,8,9]].

path(A, D, Ps) :-
	schedule(Ts),
	Ps = [[A,B,_T0,T1],[B,C,T2,T3],[C,D,T4,_T5]],
	tuples_in(Ps, Ts),
	T2 #> T1,
	T4 #> T3.
\end{code}

An example query:

\begin{code}
?- path(1, 4, Ps), flatten(Ps, Vars), label(Vars).

Ps = [[1, 2, 0, 1], [2, 3, 4, 5], [3, 4, 8, 9]]
\end{code}


\subsection{SICStus clp(FD) compatibility}	%\label{sec:sicstus_compat}
%======================================

Apart from the limited syntax, the bounds solver differs in the following
ways from the SICStus clp(FD) solver:

\begin{itemlist}
	\item [\texttt{inf} and \texttt{sup}]
	The smallest lowerbound and greatest upperbound in bounds are
	\texttt{max_integer} and \texttt{min_integer + 1}.
\end{itemlist}
