<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog 5.6.17 Reference Manual: Section 2.13</TITLE><LINK REL=home HREF="index.html">
<LINK REL=contents HREF="Contents.html">
<LINK REL=index HREF="DocIndex.html">
<LINK REL=previous HREF="hooks.html">
<LINK REL=next HREF="gc.html">
<style type="text/css"> 
dd.defbody 
{ margin-bottom: 1em; 
}

dt.pubdef 
{ background-color: #c5e1ff; 
}

pre.code 
{ margin-left: 1.5em; 
margin-right: 1.5em; 
border: 1px dotted; 
padding-top: 5px; 
padding-left: 5px; 
padding-bottom: 5px; 
background-color: #f8f8f8; 
}

div.navigate
{ text-align: center; 
background-color: #f0f0f0; 
border: 1px dotted; 
padding: 5px;
}
</style>
</HEAD>
<BODY BGCOLOR="white"><DIV class="navigate"><A HREF="index.html"><IMG SRC="home.gif" BORDER=0 ALT="Home"></A>
<A HREF="Contents.html"><IMG SRC="index.gif" BORDER=0 ALT="Contents"></A>
<A HREF="DocIndex.html"><IMG SRC="yellow_pages.gif" BORDER=0 ALT="Index"></A>
<A HREF="hooks.html"><IMG SRC="prev.gif" BORDER=0 ALT="Previous"></A>
<A HREF="gc.html"><IMG SRC="next.gif" BORDER=0 ALT="Next"></A>
</DIV>

<H2><A NAME="sec:2.13">2.13 Automatic loading of libraries</A></H2>

<A NAME="sec:autoload"></A>

<P>If ---at runtime--- an undefined predicate is trapped the system will 
first try to import the predicate from the module's default module. If 
this fails the <EM>auto loader</EM> is activated. On first activation an 
index to all library files in all library directories is loaded in core 
(see <A NAME="idx:librarydirectory1:182"></A><A HREF="consulting.html#library_directory/1">library_directory/1</A> 
and <A NAME="idx:filesearchpath2:183"></A><A HREF="consulting.html#file_search_path/2">file_search_path/2</A>). 
If the undefined predicate can be located in the one of the libraries 
that library file is automatically loaded and the call to the 
(previously undefined) predicate is restarted. By default this mechanism 
loads the file silently. The <A NAME="idx:currentprologflag2:184"></A><A HREF="flags.html#current_prolog_flag/2">current_prolog_flag/2</A> <CODE>verbose_autoload</CODE> 
is provided to get verbose loading. The prolog-flag <CODE>autoload</CODE> 
can be used to enable/disable the entire auto load system.

<P>The auto-loader only works if the unknown flag (see <A NAME="idx:unknown2:185"></A><A HREF="debugger.html#unknown/2">unknown/2</A>) 
is set to
<CODE>trace</CODE> (default). A more appropriate interaction with this 
flag should be considered.

<P>Autoloading only handles (library) source files that use the module 
mechanism described in <A HREF="modules.html">chapter 5</A>. The files 
are loaded with <A NAME="idx:usemodule2:186"></A><A HREF="import.html#use_module/2">use_module/2</A> 
and only the trapped undefined predicate will be imported to the module 
where the undefined predicate was called. Each library directory must 
hold a file <CODE>INDEX.pl</CODE> that contains an index to all library 
files in the directory. This file consists of lines of the following 
format:

<PRE class="code">
index(Name, Arity, Module, File).
</PRE>

<P>The predicate <A NAME="idx:make0:187"></A><A HREF="consulting.html#make/0">make/0</A> 
updates the autoload index. It searches for all library directories (see <A NAME="idx:librarydirectory1:188"></A><A HREF="consulting.html#library_directory/1">library_directory/1</A> 
and <A NAME="idx:filesearchpath2:189"></A><A HREF="consulting.html#file_search_path/2">file_search_path/2</A>) 
holding the file <CODE>MKINDEX.pl</CODE> or <CODE>INDEX.pl</CODE>. If 
the current user can write or create the file <CODE>INDEX.pl</CODE> and 
it does not exist or is older than the directory or one of its files, 
the index for this directory is updated. If the file <CODE>MKINDEX.pl</CODE> 
exists updating is achieved by loading this file, normally containing a 
directive calling
<A NAME="idx:makelibraryindex2:190"></A><A HREF="autoload.html#make_library_index/2">make_library_index/2</A>. 
Otherwise <A NAME="idx:makelibraryindex1:191"></A><A HREF="autoload.html#make_library_index/1">make_library_index/1</A> 
is called, creating an index for all <CODE>*.pl</CODE> files containing 
a module.

<P>Below is an example creating a completely indexed library directory.

<PRE class="code">
% mkdir ~/lib/prolog
% cd !$
% pl -g true -t 'make_library_index(.)'
</PRE>

<P>If there are more than one library files containing the desired 
predicate the following search schema is followed:

<P><OL>
<LI>If there is a library file that defines the module in which the 
undefined predicate is trapped, this file is used.
<LI>Otherwise library files are considered in the order they appear in 
the <A NAME="idx:librarydirectory1:192"></A><A HREF="consulting.html#library_directory/1">library_directory/1</A> 
predicate and within the directory alphabetically.
</OL>

<DL>
<DT class="pubdef"><A NAME="make_library_index/1"><STRONG>make_library_index</STRONG>(<VAR>+Directory</VAR>)</A></DT>
<DD class="defbody">
Create an index for this directory. The index is written to the file 
'INDEX.pl' in the specified directory. Fails with a warning if the 
directory does not exist or is write protected.</DD>
<DT class="pubdef"><A NAME="make_library_index/2"><STRONG>make_library_index</STRONG>(<VAR>+Directory, 
+ListOfPatterns</VAR>)</A></DT>
<DD class="defbody">
Normally used in <CODE>MKINDEX.pl</CODE>, this predicate creates <CODE>INDEX.pl</CODE> 
for <VAR>Directory</VAR>, indexing all files that match one of the 
file-patterns in <VAR>ListOfPatterns</VAR>.

<P>Sometimes library packages consist of one public load file and a 
number of files used by this load-file, exporting predicates that should 
not be used directly by the end-user. Such a library can be placed in a 
sub-directory of the library and the files containing public 
functionality can be added to the index of the library. As an example we 
give the XPCE library's <CODE>MKINDEX.pl</CODE>, including the public 
functionality of <CODE>trace/browse.pl</CODE> to the autoloadable 
predicates for the XPCE package.

<PRE class="code">
:- make_library_index('.',
                      [ '*.pl',
                        'trace/browse.pl'
                      ]).
</PRE>

</DD>
<DT class="pubdef"><A NAME="reload_library_index/0"><STRONG>reload_library_index</STRONG></A></DT>
<DD class="defbody">
Force reloading the index after modifying the set of library directories 
by changing the rules for <A NAME="idx:librarydirectory2:193"></A><B>library_directory/2</B>, <A NAME="idx:filesearchpath2:194"></A><A HREF="consulting.html#file_search_path/2">file_search_path/2</A>, 
adding or deleting <CODE>INDEX.pl</CODE> files. This predicate does <EM>not</EM> 
update the <CODE>INDEX.pl</CODE> files. Check <A NAME="idx:makelibraryindex12:195"></A><A HREF="autoload.html#make_library_index/1">make_library_index/[1,2]</A> 
and
<A NAME="idx:make0:196"></A><A HREF="consulting.html#make/0">make/0</A> 
for updating the index files.

<P>Normally, the index is reloaded automatically if a predicate cannot 
be found in the index and the set of library directories has changed. 
Using
<A NAME="idx:reloadlibraryindex0:197"></A><A HREF="autoload.html#reload_library_index/0">reload_library_index/0</A> 
is necessary if directories are removed or the order of the library 
directories is changed.
</DD>
</DL>

<P></BODY></HTML>