\chapter{User Defined Classes}
\label{sec:udc}

The user defined classes interface provides a natural way to define new
XPCE classes. It is both used to create higher level libraries that have
the same interface as the built-in XPCE classes as to define entire
applications. Many of the library modules and XPCE/Prolog demo programs
are implemented as user-defined classes. The PceDraw demo is an
elaborated example defined entirely as user-defined classes.

A user defined class lives in XPCE, just as any other XPCE class. There
is no difference. Both use dynamic resolution of messages to method
objects and then execute the method object. Both use the same
object-management and storage facilities.

XPCE/Prolog user-defined classes have their methods implemented
in Prolog.  This provides a neat and transparent interface between
the two systems.%
    \footnote{XPCE defines four implementation techniques for methods.
    {\em C-function pointers} are used for almost all the built-in
    behaviour. {\em C++-function pointers} are used when classes are
    defined in C++ (\cite{PCE:cpp}). Instances of \class{cpointer} are
    left to the host object for interpretation and finally, \class{code}
    objects are executed.}

User defined classes are defined using Prolog syntax, where some
operators have special meaning. The definition of an XPCE/Prolog class
is enclosed in

\begin{code}
:- pce_begin_class(<Class>, <Super>, [<Comment>]).
<Class definition>
:- pce_end_class.
\end{code}

Multiple classes may be defined in the same Prolog sourcefile, but class
definitions may not be nested.


\section{The Class Definition Skeleton}

We introduce the syntax for user-defined classes using a skeleton.
Except from the pce_begin_class/[2,3] and pce_end_class/0, everything in
the skeleton is optional and may be repeated multiple times. The order
of declarations is not important, but the order of the skeleton is the
proposed order.  An exception to this rule is the pce_group/1 directive,
that may be placed anywhere and defines the group-identifier for the
declaration that follows.

\begin{boxed}
\tt
\newcommand{\cbo}{{\it \{}}
\newcommand{\cbc}{{\it \}}}
\newcommand{\sbo}{{\it [}}
\newcommand{\sbc}{{\it ]}}
\begin{tabbing}
xxxxxxxx\=\kill
:- pce_begin_class(\sbo<Meta>:\sbc<Class>\sbo(\cbo<TermName>\cbc)\sbc, <Super>, \sbo<Summary>\sbc).\\[2ex]

:- use_class_template(<TemplateClass>.\\
:- send(@class, <Selector>\cbo, <Arg>\cbc).\\
:- pce_class_directive(<Goal>).\\[2ex]

variable(<Name>, <Type>\sbo:= <Value>\sbc, <Access>, \sbo<Summary>\sbc).
\\[2ex]

delegate_to(<VarName>).\\[2ex]

resource(<Name>, <Type>, <Default>, \sbo<Summary>\sbc).\\[2ex]

handle(<X>, <Y>, <Kind>, <Name>).\\[2ex]

:- pce_group(<Group>).\\[2ex]

<SendSelector>(<Rec>\cbo, <Arg>\sbo:\sbo<AName>=\sbc<Type>\sbc\cbc) \verb$:->$\\\relax
	\>\sbo<Summary>::\sbc\\
	\><PrologBody>.\\[2ex]

<GetSelector>(<Rec>\cbo, <Arg>\sbo:\sbo<AName>=\sbc<Type>\sbc\cbc, <RVal>\sbo:<Type>\sbc) \verb$:<-$\\\relax
	\>\sbo<Summary>::\sbc\\
	\><PrologBody>.\\[2ex]

:- pce_end_class.
\end{tabbing}
\end{boxed}

\subsection{Definition of the Template Elements}

\begin{description}
    \directive{pce_begin_class}{[2,3]}{+Class, +Super, [+Summary]}
Start the definition of an XPCE user-defined class.  This directive can
appear anywhere in a Prolog sourcefile.  The definition must be closed
using pce_end_class/0 and definitions may not be nested.  {\em Class}
describes the class to be created.  Besides giving the class-name, the
meta-class (class of the class) may be specified.  When omited, 
the meta-class of the {\em Super} will be used, which is normally
class \class{class}.  The PceDraw shape infrastructure uses the meta-class
mechanism.

The class-name may be followed by a list of {\em TermNames} that define
the result of object/2.  This predicate will unify its second argument
with a term whose functor is the name of the class and whose arguments
are the result of a `get' operation using the {\em TermName} as selector.
For example, \mbox{\tt point(x,y)} specifies that object(P,~T) unifies
T to a term point\mbox{}/2 with the <-x and <-y of the point instance
as arguments.  When omited, the term-description of the super-class
is inherited.
    \directive{use_class_template}{1}{TemplateClass}
Import a class template.  See section~\ref{sec:template}.
    \directive{send}{[2-12]}{@class, ...}
Directives like this may be used to invoke methods of the class under
construction. See also pce_class_directive/1 and
section~\ref{sec:ucdimplementation}.
    \directive{pce_class_directive}{1}{+:Goal}
Define {\em Goal} to be a goal that manipulates the class instance
directly.  See section~\ref{sec:ucdimplementation}.
    \predicate{variable}{[3,4]}{Name, Type, Access, [Summary]}
Define a new instance variable.  {\em Name} is the name of the variable,
which is local to the class and its subclasses.  {\em Type} defines
the type. See section~\ref{sec:atype} and section~\ref{sec:moretypes}.
The type may be postfixed with \mbox{{\tt := \em Value}}, in which case
the instance-allocation will fill the slot with the given value. See
also section~\ref{sec:omsmethods}.  {\em Access} defines which implicit
side-effect-free methods will be assiciated with the variable. See also
section~\ref{sec:slots}.
    \predicate{delegate_to}{1}{VariableName}
Declares the variable named {\em VariableName} to be a candidate for
delegation.  See section~\ref{sec:delegation}.
    \predicate{resource}{[3,4]}{Name, Type, Default, [Summary]}
Declare a resource for the class.  Resources are like class-variables
that may be set from the X11 resource file%
    \footnote{Or its Win32 equivalent, See README.WIN32}
The {\em Default} entry describes the default value if the resource
is not defined in any of the standard resource locations.  It is
a textual description (an atom) of the value in XPCE's resource
syntax (see section~\ref{sec:resources}).  As this syntax is very
close to the Prolog syntax, a passed Prolog term will be translated
to the default value using term_to_atom/2.
    \predicate{handle}{3,4}{X, Y, Kind, Name}
Equivalent to \mbox{\tt :- send(@class, handle, handle(X, Y, Kind,
Name).}
    \directive{pce_group}{1}{GroupIdentifier}
Sets the `behaviour <->group' attribute of any variable or method
definition following this directive.  Groups are used to organise
methods by the ClassBrowser.  Groups have no semantical implications.
\mbox{\tt :- pce_group(@default).} makes methods inherit their group
from the method that is re(de)fined.  If no method is re(de)fined,
the group will be {\tt miscellaneous}.
\end{description}

\subsubsection{Syntax Details}

Below we describe the details of the non-terminals in the above skeleton
in more detail.  The notation is an incomplete BNF notation.

\newcommand{\isa}{\>::=~}
\newcommand{\cmt}[1]{\>\parbox[t]{3in}{#1}}
\begin{tabbing}
xxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxx\=\kill
<Meta>		\isa <Name>	\cmt{Name of the class this class
				     will be an instance of.  Default
				     is the meta-class of the
				     super-class} \\
<Class>		\isa <Name>	\cmt{Name of the class to be defined} \\
<TermName>	\isa <Name>	\cmt{Selector name to fetch object/2
				     argument.  For example, a point
				     is translated into point(<X>, <Y>) and
				     the description is {\tt point(x,y)}} \\
<Super>		\isa <Name>	\cmt{Name of the super-class.  {\tt object}
				     refers to the most general class} \\
<Summary>	\isa {\tt "}\{<Char>\}{\tt "}
				\cmt{Summary description as appearing in
				     the online manual.  $< 40$ characters,
				     no newlines, Prolog string} \\
<TemplateClass>	\isa <Name>	\cmt{Import a template class.  See
				     section~\ref{sec:template}} \\
<Selector>	\isa <Name>	\cmt{Name of a method} \\
<X>		\isa <IntExpr>	\cmt{See class \class{handle}} \\
<Y>		\isa <IntExpr>	\cmt{See class \class{handle}} \\
<Kind>		\isa <Name>	\cmt{Category indicator.  See class
				     \class{handle}} \\
<Access>	\isa {\small\tt both|get|send|none}
				\cmt{Defines the access right to this
				     variable} \\
<VarName>	\isa <Name>	\cmt{Name of variable used for
				     delegation} \\
<Group>		\isa <Name>	\cmt{Functional group of the following
				     methods or variables.  Used to
				     organise the ClassBrowser} \\
<SendSelector>	\isa <Name>	\cmt{Name of send-method to define} \\
<GetSelector>	\isa <Name>	\cmt{Name of get-method to define} \\
<Rec>		\isa <Variable>	\cmt{Prolog variable bound to the receiver} \\
<Arg>		\isa <Variable> \cmt{Prolog variable bound to argument} \\
<RVal>		\isa <Variable>	\cmt{Prolog variable that should be bound
				     to the return value} \\
<AName>		\isa <Name>	\cmt{XPCE name for named argument} \\
<Type>		\>		\cmt{See section~\ref{sec:atype} and
				     \ref{sec:moretypes}} \\
<PrologBody>	\>		\cmt{Ordinary Prolog code} \\ 
<Value>		\>		\cmt{Initial value for the instance variable.
				     At this moment, only using constants
				     is supported (int, name, bool)} \\
\end{tabbing}


\section{Accessing Instance Variables (slots)}	\label{sec:slots}

The method `object <->slot' is used to access slots directly and
bypassing possible methods with the same name. It should normally only
be used in ->initialise (see below) and when defining a method with the
same name as a variable. Below is a fragment where a {\tt type} slot is
displayed by a text object named {\tt type} in a graphical object. The
... indicate where the fragment is incomplete.

\begin{code}
variable(type,	name,	get, "Epistemological type").

initialise(D, Type:name, ...) :->
	send(D, send_super, initialise),
	send(D, slot, type, Type),
	send(D, display, new(T, text(Type))),
	send(T, name, type),
	...

type(D, Type:type) :->
	"Modify the epistemological type"::
	send(D, slot, type, Type),
	get(D, member, type, Text),
	send(Text, string, Type).
\end{code}

\begin{description}
    \sendmethod{object}{slot}{name, unchecked}
\emptydescription
    \getmethod{object}{slot}{name}{unchecked}%
Read or write slot without side-effects.  The value will be converted to
the type of the instance variable addressed.  An error is raised if this
conversion is not defined or the slot does not exist.
\end{description}


\section{Re(de)fining methods}

Re(de)fining methods is a common technique in object-oriented
programming. This section describes how methods can be re(de)fined and
what methods have special meaning in XPCE and are commonly redefined.

The method definition for a re(de)fined method is exactly the same
as for a new method.  The redefined method will inherit its group
(see pce_group/1) from the method of the super-class.

If the body wants to use the definition of the super-class (refinement),
it can activate this behaviour using ->send_super or <-get_super:

\begin{description}
    \sendmethod{object}{send_super}{selector, unchecked ...}
\emptydescription
    \getmethod{object}{get_super}{selector, unchecked ...}{unchecked}
If invoked from a method implementation, the method called {\em
selector} from the super-class of the class containing the running
method will be activated.  Calling from any other context is illegal
and raises an error.  Normally, {\em selector} should be the name of
the currently running method, but this is currently {\em not} verified.

The most commonly redefined method is the ->initialise method.  Below
is an example from the definition of a graphical device displaying a
box and a centered text.  See also section~\ref{sec:omsmethods}.

\begin{code}
initialise(D, W:int, H:int, Str:string) :->
	"Create from width, height and text"::
	send(D, send_super, initialise),
	send(D, display, new(B, box(W, H))),
	new(T, text(Str)),
	send(T, center, B?center),
	send(D, display, T).
\end{code}
\end{description}


\subsection{Gen<eral Redefinitions}	\label{sec:omsmethods}

The most commonly redefined methods are ->initialise and ->unlink to
redefine object creation and destruction.

\begin{description}
    \sendmethod{object}{initialise}{<Class-Defined>}
Initialise a new instance of the class.  The initialisation is not allowed
to access behaviour or slots of the super-class without performing the
->send_super: initialise <SuperClass-Defined>.  Not performing the
->send_super: initialise is a common source of errors, often leading
to crashes.

The initialise method should initialise all slots declared in this
class that have no specified value in the variable declaration and
cannot have the value @nil.  See also checkpce/0.

If ->initialise fails, the exception {\tt initialise_failed} will be
raised, passing the instance and the argument vector.  Afterwards, 
a possible named reference is destroyed and the object, all slots are
set back to @nil and the instance is deallocated.  ->unlink (see below)
will not be called.  In general, it is not considered good programming
style to let ->initialise fail.
    \sendmethod{object}{unlink}{}%
Called from the object-management system if the object is to be destroyed.
This method {\em must} call ->send_super: unlink somewhere in the process.
It is considered an error if ->unlink fails.

This method is normally used to unlink the object from related objects.
There is no need to reset slot-values as dereferencing the slot-values
will be done by the object-management system after ->unlink has finished.

->unlink is called no matter why the object was destroyed using ->free
or due to the garbage-collector.
    \getmethod{object}{convert}{<Class-Defined>}{Instance}
This get method converts another object into an object of this class. The
receiver is not defined during the execution of this method.  The method
should either fail or succeed and return an instance of the requested
class or one of its super-classes.  The argument vector consists of
a single argument.  The type-conversion system guarantees the argument
is of the satisfied type.  It is allowed, but not obligatory to use
the method of the super-class.
    \getmethod{object}{lookup}{<Class-Defined>}{Instance}
Called from the new() virtual machine operation to deal with {\em
reusable} objects before ->initialise is considered. The arguments are
normally the same as for ->initialise. If this method returns an instance,
this will be the value returned by new().  If it fails, a new instance
is allocated and ->initialised.
\end{description}


\subsection{Redefinition in Graphical Classes}
\label{sec:graphmethods}

The generic graphical class \class{graphical} is prepared is prepared
to have several of its methods redefined in subclasses.  This section
describes the most important of these methods.

\begin{description}
    \sendmethod{graphical}{event}{event}
Called when a user-event needs to be dispatched. This message is
initialy sent to the window object receiving the event.
Graphical devices (and thus windows) will collect all graphicals
for which `graphical ->in_event_area' succeeds.  This are normally
all graphicals that overlap with the current position of the pointer.
It will short these objects to their stacking order, topmost object
first.  See `device <-pointed'.  Next the device will use `event->post'
to post the event to each of these graphicals until one accepts the
event.  Finally `graphical->event' will be invoked, trying all the
\class{recogniser} objects associated with this graphical.

Notably most subclasses of class \class{dialog_item} redefine ->event.

The method ->event is commonly redefined in user-defined graphicals to
make them sensitive to the mouse. The following fragment makes it
possible to resize and move instances of this class.

\begin{code}
:- pce_global(@resize_and_move_recogniser,
	      new(handler_group(new(resize_gesture),
				new(move_gesture)))).

event(Gr, Ev:event) :->
	"Make the object resizeable and moveable"::
	(   send(Gr, send_super, event, Ev)
	;   send(@resize_and_move_recogniser, event, Ev)
	).
\end{code}

Note that the implementation first tries the super-class. If the
super-class has no specific event-handling, this allows recognisers to
be attached that overrule the resize/move behaviour. Also, if it is a
\class{device}, invoking the super-class behaviour will test components
displayed on the device to be considered before the device as a whole.

It is not obligatory to use ->send_super and if it is used, no specific
ordering is required.  If there is no behaviour of the super-class
that conflicts with your extension we recommend to try ->send_super
first.

Note the way recognisers are activated from event methods.  The
graphical object itself is not passed.  Instead, `recogniser->event'
reads the receiver from `event <-receiver' set by `event ->post'.

As a consequence, do not call `graphical ->event' yourself.  An event
is directed to a graphical using `event ->post'.
    \sendmethod{graphical}{geometry}{X:[int], Y:[int], W:[int], H:[int]}
Requests the receiver to position itself at the $X,Y$ and to be $W
\times H$ pixels in size. Any of these values may be @default,
indicating that the specific parameter is not to be changed.

Redefining ->geometry is proper way to interfere with positioning or
resizing as this is the central method called by all move and resize
methods.

The example below takes the text-box to ensure proper geometry handling
by this class.  Note that (1) the size of a device is by definition the
bounding box of all displayed graphicals and (2) the text must be
centered again.

\begin{code}
geometry(D, X:[int], Y:[int], W:[int], H:[int]) :->
	get(D, member, box, B),
	get(D, member, text, T),
	send(B, set, @default, @default, W, H),
	send(T, center, B?center),
	send(D, send_super, geometry, X, Y).
\end{code}

\index{constraint,vs. method}
Note that the relation between the text and the box could also be
maintained using a \class{constraint} object.  The above implementation
however is only executed when the geometry of the device is changed,
while constraints will be executed whenever a message arrives on the
box or text.
    \sendmethod{graphical}{request_geometry}{X:[int], Y:[int], W:[int], H:[int]}
Is much like ->geometry, except that the interpretation of the units is
left to the graphical.  For example \class{editor} will use the current
font to translate $W$ and $H$ to pixels and then invoke ->geometry.  Not
used very often.
    \sendmethod{graphical}{compute}{}
This method cooperates with ->request_compute and may be used to delay
expensive graphical operations. Suppose we have a graphical
representation and a database object linked using a \class{hyper} like
this:

\begin{code}
	new(_, hyper(Db, Gr, controller, model))
\end{code}

If the database object (model) is modified, it could use the following
to signal all associated controllers of the change:

\begin{code}
	send(Db, send_hyper, controller, request_compute)
\end{code}

The controller could react immediately, but it can also delay until it needs
to be painted:

\begin{code}
compute(C) :->
	"Update according to model"::
	get(C, get_hyper, model, name, Name),
	get(C, member, text, T),
	send(T, string, Name),
	send(C, send_super, compute).
\end{code}
\end{description}


\section{Related Predicates}

There is a small number of predicates that support the definition of
classes.  These are listed below:

\begin{description}
    \predicate{default}{3}{+Argument, +Default, -Value}
Used to specify and compute defaults for arguments.  {\em Argument}
is the actual argument passed to the method implementation, {\em
Default} is any valid XPCE object description (reference, integer,
real, atom or compound ground term describing an object, see
send/[2-12]).  {\em Default} can also be the term
\begin{code}
resource(<Object>, <Name>)
\end{code}
In which case the <-resource_value: <Name> from <Object> will be
used as default value.  {\em Value} is unified with {\em Argument}
if {\em Argument} is not @default and with {\em Default} otherwise.
    \predicate{pce_predicate_reference}{2}{?:Head, ?Reference}
Converts between a Prolog predicate and an XPCE object referencing this
predicate. A Prolog predicate is described by a \class{c_pointer}
object.

This predicate is used by the class compiler.
	
The following example generates a PCE reference to the Prolog predicate
bar/2 in the Prolog module foo.
	
\begin{code}
?- pce_begin_class(foo:bar(_,_), X).
\end{code}

These reference objects are stored in the `method <->message' slot.
Except for finding the predicate implementing a method, there are
probably few sensible applications of the predicate.
\end{description}


\section{Advanced Topics}

\subsection{More on Type Declarations}		\label{sec:moretypes}

The basic XPCE type-syntax is described in section~\ref{sec:atype} of
this manual.  Types are first-class reusable XPCE objects that are
created from the type-declaration in arguments and variables.  The
conversion from the textual representation to the object is performed
by XPCE itself (together with the resource syntax, one of the few
places where XPCE defines syntax).  All types can be specified as
Prolog quoted atoms.  For example:

\begin{code}
mymethod(Me, A:'graphical|dict_item|0..') :->
	...
\end{code}

For most cases however this is not necessary. If the type is not
an atom, the class-compiler will write the term to an atom and
canonise the result.  Hence, {\tt [point]} will translate to the
atom '[point]', which is interpreted by XPCE as ``an instance
\class{point} or the constant @default. The atoms {\tt *} and {\tt
...} are defined as postfix operators, while {\tt ..} is an infix
operator.  This makes \mbox{\tt any ...} a valid notation for
``any number of anything'' (see section~\ref{sec:varargs} below)
and {\tt 0..5} a valid expression for ``an integer in the range
0 to 5 (including the boundaries).

Also, {\tt [box|circle]} is a valid description for ``an instance of
\class{box} or \class{circle} or the constant @default.  Note however
that {\tt [box|circle|ellipse]} is {\em not} valid syntax and should
be written as {\tt '[box|circle|ellipse]'}.  Whenever you are in doubt,
use quotes to prevent surprises.


\subsection{Methods with variable number of arguments} \label{sec:varargs}

Methods such as `chain->initialise' and `string->format' handle an
arbitrary number of arguments. The argument declaration for such a
method first defines a number (possible zero) of `normal' arguments. The
last argument may be postfixed with {\tt ...}. The variable will be
bound to a \class{vector} object containing all arguments assigned to
this variable. Below is a refinement of `label ->report' that will
colour the label depending on the nature of the message.

\begin{code}
:- pce_begin_class(coloured_reporter, label,
		   "Coloured reporter label").

report(L, Kind:name, Format:char_array, Args:any ...) :->
	send(L, send_super_vector, report, Kind, Format, Args),
	get(L, colour_from_report_category, Kind, Colour),
	send(L, colour, Colour).

colour_from_report_category(L, Kind:name, Colour:colour) :<-
	"Determine colour on the nature of report"::
	get(L?display, visual_type, Type),
	report_colour(Type, Kind, ColourName),
	new(Colour, colour(ColourName)).

report_colour(monochrome, _, black).
report_colour(static_grey, _, black).
report_colour(grey_scale, _, black).
report_colour(_, status,   dark_green).
report_colour(_, inform,   black).
report_colour(_, progress, green).
report_colour(_, done,     black).
report_colour(_, warning,  orange).
report_colour(_, error,	   red).

:- pce_end_class.
\end{code}

The method ->send_super_vector is a contraction of ->send_super and
->send_vector.  ->send_vector and friends are used to {\em invoke}
methods if the number of arguments is not known beforehand.  Note
that the implementing method need not be a method accepting an
argument vector.  Consider:

\begin{code}
?- send(new(P, picture), send_vector, vector(open)).
\end{code}

\begin{description}
    \sendmethod{object}{send_vector}{unchecked ..., vector [,int]}
Although the formal argument specification is {\tt unchecked ...}, the
above describes the actual argument syntax.  This method creates a
vector of arguments consisting of
\begin{itemize}
    \item The leading arguments
    \item followed by the members of the vector, where the first
          `int' arguments are skipped.
\end{itemize}
The first argument of the created vector will be used for the selector.
The remaining arguments are passed to the method.
    \sendmethod{object}{send_super_vector}{unchecked ..., vector [,int]}
Contraction of ->send_vector and ->send_super.  The argument vector is
constructed as in ->send_vector and the method resolution is from
->send_super.
    \getmethod{object}{get_vector}{unchecked ..., vector [,int]}{unchecked}
Like ->send_vector, but to fetch a result.
\end{description}


\subsubsection{Using Class Templates}		\label{sec:template}

XPCE provides two alternatives to multiple inheritance. Delegation is
discussed in section~\ref{sec:delegation}. See also the directive
delegate_to/1 for user-defined class definitions.  The {\em template}
mechanism is much closer to real multiple inheritance.  A template
is a named partial class-definition that may be included in other
classes.  It behaves as if the source-code of the template definition
was literally included at the place of the use_class_template/1
directive.

In fact, the class-attributes (variables, method objects) are {\em
copied}, while the implementation (the Prolog clauses) are {\em shared}
between multiple usages of the same template.

Templates itself form a hierarchy below class \class{template}, which
is an immediate subclass of \class{object}.  Including a template will
make all variables and methods defined between the template class and
class \class{template} available to the receiving class.

We illustrate the example below, making both editable boxes as editable
ellipses.  First we define the template class.

\begin{code}
:- use_module(library(pce_template)).

:- pce_begin_class(editable_graphical, template).

:- pce_global(@editable_graphical_recogniser,
	      make_editable_graphical_recogniser).

make_editable_graphical_recogniser(G) :-
	Gr = @arg1,
	new(Dev, Gr?device),
	new(P, popup),
	send_list(P, append,
		  [ menu_item(cut, message(Gr, free)),
		    menu_item(duplicate,
			      message(Dev, display, Gr?clone,
				      ?(Gr?position, plus,
					point(10,10))))
		  ]),
	new(G, handler_group(new(resize_gesture),
			     new(move_gesture),
			     popup_gesture(P))).


event(G, Ev:event) :->
	(   send(G, send_super, event, Ev)
	;   send(@editable_graphical_recogniser, event, Ev)
	).
:- pce_end_class.
\end{code}

The main program can now be defined as:

\begin{code}
:- require([use_class_template/1]).

:- pce_begin_class(editable_box, box).
:- use_class_template(editable_graphical).
:- pce_end_class.

:- pce_begin_class(editable_ellipse, ellipse).
:- use_class_template(editable_graphical).
:- pce_end_class.

test :-
	send(new(P, picture('Template Demo')), open),
	send(P, display,
	     editable_box(100,50), point(20,20)),
	send(P, display,
	     editable_ellipse(100, 50), point(20, 90)).
\end{code}


Note that use_class_template/1 {\em imports} the definitions from the
template in the current class.  Thus, the following {\bf will not 
extend} further on the `editable_graphical ->event' definition, but
instead {\bf replace} this definition.  Of course it is allowed to
subclass the definition of editable_box above are further refine the
event method in the subclass.

\begin{code}
:- require([use_class_template/1]).

:- pce_begin_class(editable_box, box).
:- use_class_template(editable_graphical).

event(Gr, Ev:event) :->
	(   send(Gr, send_super, event, Ev)
	;   ...
	).
:- pce_end_class.
\end{code}


\subsection{Implementation Notes}	\label{sec:ucdimplementation}

The XPCE/Prolog class-compilation is defined using the Prolog
preprocessing capabilities of term_expansion/2. While the class is
compiled, Prolog simply gathers the expressions belonging to the class.
The expansion of \mbox{\tt :- pce_end_class} emits the actual code for
the class.

The method implementation is realised by a set of predicates for
different number of arguments.  Each clause in these predicates
implements a method.%
    \footnote{Earlier versions used one predicate per method.  This
	      choice appears to consume less memory at the cost of
	      only a small performance degradation.  Try to avoid
	      relying on the compilation process as compatibility
	      cannot be guaranteed.  The process is described to
	      help you understand occurring problems.}
Thus

\begin{code}
:- pce_begin_class(gnus, ...
gnu(X, A:int) :-> ...
gnat(X, A:name) :-> ...
gnats(X, A:name, B:int) :-> ...
\end{code}

is translated into

\begin{code}
send_gnus(gnu, A) :- ...
send_gnat(gnat, A) :- ...
send_gnats(gnats, A, B) :- ...
\end{code}

The remainder of the class specification is translated into a number of
Prolog clauses describing the class. No XPCE class is created. If XPCE
generates an {\tt undefined_class} exception, it will scan for the
class-description in the Prolog database and create the XPCE
\class{class} instance.  No methods are associated with the new class.
Instead, all method binding is again based on exception handling.

Modifications to the class beyond what is provided by the preprocessing
facilities (for example changing the `variable ->clone_style') cannot
be made by sending messages to the class inside the class definition
body as this would address the not-yet-existing class.  Instead, they
should be embedded in the pce_class_directive/1 directive.%
    \footnote{To facilate the translation of old code, the construct
	      \mbox{\tt :- send(@class, ...} is treated automatically
	      as if it was embedded using pce_class_directive/1}.
The {\em Goal} argument of pce_class_directive/1 should refer to the
class using the XPCE \class{var} object @class.  When the class is
realised the exception system will bind @class to the current class
while invoking {\em Goal}.  {\em Goal} is invoked as if it was called
from the Prolog module in which the class is defined.

\index{runtime generation}
The main reason for the above approach is to exploit the
runtime-generation facilities of the hosting Prolog system to create
fast-starting portable and (depending on the hosting Prolog's
capabilities) stand-alone executables.

One of the consequences of the chosen approach is that the
class-building directives are not accessible as predicates.  There is
no preprocessing support for the dynamic creation of classes and the
programmer should thus fall back to raw manipulation of the XPCE class
objects.

