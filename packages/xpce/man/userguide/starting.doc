\chapter{Getting started}		\label{sec:starting}

This section introduces programming the PCE/Prolog environment: the
entities (objects), referencing objects and manipulating objects.
Most of the material is introduced with examples.  A complete
definition of the interface primitives may be found in
appendix~\ref{sec:interface}.

\section{Starting PCE/Prolog}

PCE may be connected to several Prolog implementations.  It is a
normal Unix executable and may be started from the Unix shell like
any other program.  When PCE/Prolog is started, it appears just like
the Prolog system it is based on, except for the banner message.
Below we started PCE/SWI-Prolog (\cite{SWI-Prolog:manual}).

\begin{code}
% xpce
~/.plrc compiled, 0.00 sec, 928 bytes.
PCE Release 4.7.1, March 1994 for sparc-sunos-4.1.3 and X11R5
Copyright 1993, 1994, University of Amsterdam.  All rights reserved.
The host-language is SWI-Prolog version 1.8.10 March 1994
~/.xpcerc compiled, 0.03 sec, 1,140 bytes.

For HELP, please invoke the predicate `manpce'.

1 ?- 
\end{code}

\index{version}
SWI-Prolog's prompt is ``$<$n$>$ ?-'' where $<$n$>$ is the
history-number of the command. The banner indicates the PCE version.
The current version is 4.7 and the patch-level is 1.

\section{Prolog ... and what?}

This section describes the 4 basic Prolog predicates used to
control PCE from Prolog.  These 4 predicates map onto the 4 basic
functions of PCE's virtual machine: creating, destroying,
manipulating and querying {\em objects}, the basic entifies of
PCE.

For those not familiar with this jargon, an object is an observable
entity with a persistent state and associated procedures (called {\em
methods}).  Objects may represent just about anything.  In PCE's world
there are objects representing a position in a two-dimensional plane
as well as an entire window on your screen.  Each object belongs to a
{\em class}.  The class defines the constituents of the persistent
state as well as the procedures associated with the object.  For
example a position in a two-dimensional plane is represented by a
object of class {\em point}.  The state of a point object consists of
its X- and Y-coordinates.

\subsection{New: creating objects}

\index{object,reference}\index{reference, object}
The predicate new/2 (new(?Reference,~+NewTerm)) {\em creates} an
object in the PCE world and either assigns the given {\em reference}
to it or unifies the first argument with a PCE generated reference.
An (object-) reference is a unique handle used in further
communication with the object.  Below are some examples (\verb$?-$ is
the Prolog prompt):

\begin{code}
1 ?- new(P, point(10,20)).
P = @772024

2 ?- new(@demo, dialog('Demo Window')).
\end{code}

The first example creates an instance of class point from the
arguments `10' and `20'.  The reference is represented in Prolog using
the prefix operator \predrefer{@}{1}.  For PCE generated references
the argument of this term is a PCE generated integer value.  These
integers are guaranteed to be unique.  The second example creates a
dialog object.  A dialog is a window that is specialised for
displaying structured UI objects such as buttons, text-entry-fields,
etc.  In this example we have specified the reference.  Such a
reference must be of the form @Atom. PCE will associate the created
object with this reference.%
    \footnote{Normal applications use almost only PCE generated
	      references.  Many of the examples in this manual are
	      typed from the terminal and Prolog specified references
	      are easier to type.}

As illustrated by the examples above, the second argument to new/2
is a term.  The principal functor denotes the name of the class of
which a instance is to be created and the arguments are the
initialisation parameters.  The complete transformation rules are
given in appendix~\ref{sec:interface}.

As stated before, an object has persistent state.  At creation time,
the initial state is defined by the class from which the object is
created and the initialisation arguments.  In our example, the point
will be assigned an x-value of 10 and and y-value of 20.  The dialog
will be assigned a label `Demo Window'.  A dialog window has many {\em
instance variables}: local variables that serve as place-holders for
the persistent state associated with the object.  The example defines the
`label' instance variable. All the others default according to the
class definition. 


\subsection{Send: modifying object state}

The state of an object may be manipulated using the predicate
send/[2-12] (send(+Receiver, +Selector, ...Args...)).  The first two
arguments of this predicate are an object reference and the name of
the operation to perform (called {\em selector}). The example below
assumes the previous example to be typed in.%
    \footnote{Replace @772024 with the reference returned in
	      the previous example.} 
    
\begin{code}
3 ?- send(@772024, x, 15).
4 ?- send(@demo, append, text_item(name)).
\end{code}

The first example invokes the {\em method} `x' of the point object.
This method is declared at class point.  It sets the instance variable
x of the corresponding point object to the argument value.  The second
example invokes the method append of class dialog.  This method
appends a UI component to the dialog window.  The component is
specified by the term `text_item(name)', which is converted into an
object just as the second argument of new/2.

The query below will open the dialog window.

\begin{code}
5 ?- send(@demo, open).
\end{code}

If everything is ok, a window as shown in figure~\ref{fig:dialog}
should appear on your screen.  The outside (in the figure this is the
title-bar displayed above the window) is determined by the window
manager you are using.  It should look the same as any other window
on your terminal.  If an error of any kind appears, please refer
to appendix~\ref{sec:trouble}.


\postscriptfig{dialog}{Example Dialog Window}

\subsection{Get: querying objects}

The next fundamental interface predicate is get/[3-13].  It is used to
obtain information on the state of objects.  Again, the first two
arguments are the reference and selector.  The last argument is
unified with the return-value and the remaining arguments are
treated the same as with send/[2-12].  Examples:

\begin{code}
6 ?- get(@772024, y, Y).
Y = 20
7 ?- get(@demo, display, D).
D = @display/display
8 ?- get(@772024, distance, point(100,100), Distance).
Distance = 117
\end{code}

The first example just obtains the value of the `y' instance variable.
The second example returns the display object on which @demo is
displayed.  This is the reference to an object of class display that
represents your screen.%
    \footnote{Prolog would normally print `@display'.  The library
	      pce_portray defines a clause for the Prolog predicate
	      portray/1 that prints object references as
	      `@Reference/Class'.  This library is used throughout
	      all the examples of this manual.}
The last example again shows the creation of objects from the
arguments to send/[2-12] and get/[3-13] and also shows that the
returned value does not need to be a direct instance variable of the
object.  The return value is an integer representing the (rounded)
distance between @772024 and point(100,100).

The second example illustrates that get/[3-13] returns objects by
their reference.  This reference may be used for further queries.
The example below computes the width and height of your screen.

\begin{code}
9 ?- get(@display, size, Size),
     get(Size, width, W),
     get(Size, height, H).
Size = @4653322, W = 1152, H = 900
\end{code}

As a final example, type something in the text entry field and try
the following:

\begin{code}
10 ?- get(@demo, member, name, TextItem),
      get(TextItem, selection, Text).
TextItem = @573481/text_item, Text = hello
\end{code}

\index{graphical,finding}\index{finding,graphical}
The first get operation requests a member of the dialog with the given
name (`name').  This will return the object reference of the text_item
object appended to the dialog.  The next request obtains the
`selection' of the text_item.  This is the text typed in the text
entry field.


\subsection{Free: removing objects}

\index{remove,objects}\index{object,remove}
The final principal interface predicate is free/1.  Its argument is
an object reference as returned by new/2 or get/[3-13].  It will remove
the object from the PCE object base.  Examples:

\begin{code}
12 ?- free(@772024).
13 ?- free(@demo).
14 ?- free(@display).
No
\end{code}

The second example not only removed the dialog window object from
the PCE object base, it also removes the associated X-window from
the screen.  The last example illustrates that certain system objects
have been protected against freeing.


\section{Optional arguments}

\index{default arguments}\index{optional arguments}\index{argument,optional}
Arguments to PCE methods are identified by their position.  Many
methods have both obligatory and optional arguments.  If obligatory
arguments are omitted PCE will generate a warning.  If optional
arguments are omitted PCE will fill the argument with the constant
@default.  The interpretation of @default is left to the
implementation of the receiving method.  See also
section~\ref{sec:online}.

\section{Named arguments}

\index{argument,named}\index{named argument}
Some methods take a lot of arguments of which you generally only want
to specify a few.  A good example is `style ->initialise'%
	\footnote{The ->initialise method is called by new/2 and
		  controls creating a new instance.}
taking 7 arguments.  Both calls below create a style object representing
an underlined text-fragment:

\begin{code}
1 ?- new(X, style(@default, @default, @default, @default, @on)).
2 ?- new(X, style(underline := @on)).
\end{code}

The names of arguments are specified in the reference manual.  For
example, the method `area ->set' has the following specification.

\begin{code}
area->set: x=[int], y=[int], width=[int], heigth=[int]
\end{code}

The following example illustrates the usage of this method:

\begin{code}
1 ?- new(A, area),
     send(A, set, y := 10, heigth := 50).
\end{code}


\section{A Prolog tracing dialog}	\label{sec:dialogexample}

The following examples contain simple, but complete programs.  We will
introduce a number of new aspects of argument processing in
send/[2-12] and how PCE UI components can activate application code.
First an example:

\begin{code}
trace_dialog :-
	new(D, dialog('Trace')),
	send(D, append, new(M, menu(trace, marked))),
	send(M, layout, horizontal),
	send(M, append, menu_item(off, message(@prolog, notrace))),
	send(M, append, menu_item(on, message(@prolog, trace))),
	send(D, open).
\end{code}

The dialog window generated by this code is shown in
figure~\ref{fig:tracedialog}.  It shows a \idx{radio-button} that
allows the user to toggle trace/notrace mode for Prolog.  First a
menu is appended to the dialog window.  As we want to attach items
to this menu we need its reference.
\index{new/2,in argument}
Embedding the argument in a term new/2 will create the object from the
second argument and unify the reference to the first.

\postscriptfig{tracedialog}{Dialog box to switch trace mode}

Next, two items are attached to the menu.  When clicked, we would like
Prolog to switch to trace/notrace mode.  This is achieved by
associating a \class{message} object to the menu items.  A message
object is a kind of dormant send operation.  It is activated by the
menu item when clicked, after which it will do exactly the same as:

\begin{code}
?- send(@prolog, trace).
\end{code}

The predefined object @prolog refers to your Prolog interpreter.  A
message send to @prolog will call the specified predicate with the
specified arguments:

\begin{code}
?- send(@prolog, write, hello).
hello
?- send(@prolog, fail).
No
\end{code}

The first example calls write/1.  The second calls fail/0 which cannot
be proven by the Prolog system.  Success or failure in proving the
goal is mapped on success or failure of sending the message to
@prolog. 

\index{window,destroying}
The second example illustrates two additional aspects of message
objects.  The first deals with argument forwarding.  The second
illustrates that messages need not be send to @prolog, but to any
object: pressing the `Quit' button will destroy the dialog window.

\begin{code}
prolog_dialog :-
	new(D, dialog('Prolog')),
	send(D, append, text_item(consult, '',
		                  message(@prolog, consult, @arg1))),
	send(D, append, button(quit, message(D, destroy))),
	send(D, open).
\end{code}

The predefined object reference @arg1 is a var object that is bound
to the text typed in the text_item when the message is executed.
Create this example.  Then enter the name of a file to be consulted
and press the {\sc return} key.  

\section{Summary}

PCE's world consists of objects.  An object is an entity with
persistent state that belongs to a class.  The PCE/Prolog interface
defines four basic predicates: new/2 to create objects from a
description and returns an object reference.  The predicate
send/[2-12] changes the state of an object and succeeds if the
requested change could be made.  The predicate get/[3-13] requests an
object to compute a value and return it.  Finally, free/1 removes
objects from the PCE database.

Objects of the class message are `dormant' send operations.  They
may be activated by other objects (button, text_item, ...).  In this
case a send operation is started.

The object @prolog (class host) allows to call Prolog predicates
from the PCE environment.


